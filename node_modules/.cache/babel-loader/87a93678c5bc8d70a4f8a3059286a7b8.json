{"ast":null,"code":"import { types } from '@algo-builder/web';\nimport { AppActions } from '../constants/constants.js';\nconst {\n  tryExecuteTx,\n  getCustodialWallets,\n  chunkArray,\n  OptAppID\n} = require('./common.js');\n\n/**\n * Find and vote by each custodial wallets (which haven't voted before) for algorand governance.\n */\n// `af/gov1:j[5,\"a\"]`;\nexport async function voteByCustodialWallets(web, memo, network, adminAddr, governanceAddr) {\n  // extract custodial wallets from indexer, which we will fund\n  const custodialWallets = await getCustodialWallets(OptAppID(network), {\n    registered: true,\n    voted: false\n  }, network, adminAddr, 200);\n\n  // split whole custodial wallets array into chunks of 3\n  // as max 4 accounts can be passed in a tx group and we need\n  // the last one as the governance address\n  const txAccountArrays = chunkArray(custodialWallets, 3);\n\n  // after getting wallets, let's construct the transactions\n  const txArray = [];\n  for (let i = 0, j = 0; i < custodialWallets.length; i += 3, j++) {\n    // in each iteration we're funding 4 wallets\n    txArray.push({\n      type: types.TransactionType.CallApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: adminAddr,\n      appID: OptAppID(network),\n      payFlags: {\n        totalFee: 1000 + 1000 * txAccountArrays[j].length\n      },\n      accounts: [...txAccountArrays[j], governanceAddr],\n      // append gov address\n      appArgs: [AppActions.VOTE, `addr:${governanceAddr}`, `str:${memo}`]\n    });\n  }\n\n  // finally assemble transactions into groups of 16. Submit each group to network\n  const txGroups = chunkArray(txArray, 16);\n  for (const grp of txGroups) {\n    await tryExecuteTx(web, grp);\n  }\n}","map":{"version":3,"names":["types","AppActions","tryExecuteTx","getCustodialWallets","chunkArray","OptAppID","require","voteByCustodialWallets","web","memo","network","adminAddr","governanceAddr","custodialWallets","registered","voted","txAccountArrays","txArray","i","j","length","push","type","TransactionType","CallApp","sign","SignType","SecretKey","fromAccountAddr","appID","payFlags","totalFee","accounts","appArgs","VOTE","txGroups","grp"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/vote.js"],"sourcesContent":["import { types } from '@algo-builder/web';\nimport { AppActions } from '../constants/constants.js';\nconst {\n    tryExecuteTx,\n    getCustodialWallets,\n    chunkArray,\n    OptAppID\n} = require('./common.js');\n\n/**\n * Find and vote by each custodial wallets (which haven't voted before) for algorand governance.\n */\n// `af/gov1:j[5,\"a\"]`;\nexport async function voteByCustodialWallets(\n    web,\n    memo,\n    network,\n    adminAddr,\n    governanceAddr\n) {\n    // extract custodial wallets from indexer, which we will fund\n    const custodialWallets = await getCustodialWallets(\n        OptAppID(network),\n        {\n            registered: true,\n            voted: false\n        },\n        network,\n        adminAddr,\n        200\n    );\n\n    // split whole custodial wallets array into chunks of 3\n    // as max 4 accounts can be passed in a tx group and we need\n    // the last one as the governance address\n    const txAccountArrays = chunkArray(custodialWallets, 3);\n\n    // after getting wallets, let's construct the transactions\n    const txArray = [];\n    for (let i = 0, j = 0; i < custodialWallets.length; i += 3, j++) {\n        // in each iteration we're funding 4 wallets\n        txArray.push({\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: adminAddr,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 1000 + 1000 * txAccountArrays[j].length },\n            accounts: [...txAccountArrays[j], governanceAddr], // append gov address\n            appArgs: [AppActions.VOTE, `addr:${governanceAddr}`, `str:${memo}`]\n        });\n    }\n\n    // finally assemble transactions into groups of 16. Submit each group to network\n    const txGroups = chunkArray(txArray, 16);\n    for (const grp of txGroups) {\n        await tryExecuteTx(web, grp);\n    }\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,mBAAmB;AACzC,SAASC,UAAU,QAAQ,2BAA2B;AACtD,MAAM;EACFC,YAAY;EACZC,mBAAmB;EACnBC,UAAU;EACVC;AACJ,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAE1B;AACA;AACA;AACA;AACA,OAAO,eAAeC,sBAAsB,CACxCC,GAAG,EACHC,IAAI,EACJC,OAAO,EACPC,SAAS,EACTC,cAAc,EAChB;EACE;EACA,MAAMC,gBAAgB,GAAG,MAAMV,mBAAmB,CAC9CE,QAAQ,CAACK,OAAO,CAAC,EACjB;IACII,UAAU,EAAE,IAAI;IAChBC,KAAK,EAAE;EACX,CAAC,EACDL,OAAO,EACPC,SAAS,EACT,GAAG,CACN;;EAED;EACA;EACA;EACA,MAAMK,eAAe,GAAGZ,UAAU,CAACS,gBAAgB,EAAE,CAAC,CAAC;;EAEvD;EACA,MAAMI,OAAO,GAAG,EAAE;EAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGL,gBAAgB,CAACO,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAEC,CAAC,EAAE,EAAE;IAC7D;IACAF,OAAO,CAACI,IAAI,CAAC;MACTC,IAAI,EAAEtB,KAAK,CAACuB,eAAe,CAACC,OAAO;MACnCC,IAAI,EAAEzB,KAAK,CAAC0B,QAAQ,CAACC,SAAS;MAC9BC,eAAe,EAAEjB,SAAS;MAC1BkB,KAAK,EAAExB,QAAQ,CAACK,OAAO,CAAC;MACxBoB,QAAQ,EAAE;QAAEC,QAAQ,EAAE,IAAI,GAAG,IAAI,GAAGf,eAAe,CAACG,CAAC,CAAC,CAACC;MAAO,CAAC;MAC/DY,QAAQ,EAAE,CAAC,GAAGhB,eAAe,CAACG,CAAC,CAAC,EAAEP,cAAc,CAAC;MAAE;MACnDqB,OAAO,EAAE,CAAChC,UAAU,CAACiC,IAAI,EAAG,QAAOtB,cAAe,EAAC,EAAG,OAAMH,IAAK,EAAC;IACtE,CAAC,CAAC;EACN;;EAEA;EACA,MAAM0B,QAAQ,GAAG/B,UAAU,CAACa,OAAO,EAAE,EAAE,CAAC;EACxC,KAAK,MAAMmB,GAAG,IAAID,QAAQ,EAAE;IACxB,MAAMjC,YAAY,CAACM,GAAG,EAAE4B,GAAG,CAAC;EAChC;AACJ"},"metadata":{},"sourceType":"module"}