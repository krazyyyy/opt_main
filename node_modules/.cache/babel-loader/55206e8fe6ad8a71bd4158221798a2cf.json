{"ast":null,"code":"import { mkTxParams, tx, types } from '@algo-builder/web';\nimport { GlobalStateKeys, LocalStateKeys, NetworkArray, Wallet } from '../constants/constants';\nimport { indexerClient } from './algob.config';\nconst {\n  getApplicationAddress,\n  assignGroupID,\n  encodeUnsignedTransaction\n} = require('algosdk');\nlet OptimumASA = {\n  \"mainnet\": {\n    \"timestamp\": 1672621838734,\n    \"metadata\": {},\n    \"asa\": {\n      \"OptimumASA\": {\n        \"creator\": \"2UBZKFR6RCZL7R24ZG327VKPTPJUPFM6WTG7PJG2ZJLU234F5RGXFLTAKA\",\n        \"txId\": \"2WSA2INHLLNW7JI6NPZPWX7WKG47NKLTYGGRQDKV6WMTFHXS4F6A\",\n        \"assetIndex\": 996657698,\n        \"confirmedRound\": 25969935,\n        \"assetDef\": {\n          \"total\": \"10000000000000000\",\n          \"decimals\": 6,\n          \"unitName\": \"OPT\",\n          \"url\": \"https://<name>.com\",\n          \"metadataHash\": \"12312442142141241244444411111133\",\n          \"note\": \"Algorand governance Optimum ASA\",\n          \"manager\": null,\n          \"reserve\": null,\n          \"freeze\": null,\n          \"clawback\": null,\n          \"defaultFrozen\": false,\n          \"name\": \"OptimumASA\"\n        },\n        \"deleted\": false\n      }\n    },\n    \"ssc\": {},\n    \"dLsig\": {}\n  }\n};\nlet OptimumApp = {\n  \"mainnet\": {\n    \"timestamp\": 1672621846342,\n    \"metadata\": {},\n    \"asa\": {},\n    \"ssc\": {\n      \"Optimum App\": {\n        \"1672621846\": {\n          \"creator\": \"2UBZKFR6RCZL7R24ZG327VKPTPJUPFM6WTG7PJG2ZJLU234F5RGXFLTAKA\",\n          \"txId\": \"5RDBACFR3ZEN7ZHJIFZAXBTZERWSYOV2GAY7IQXOVHDKRCKW2REA\",\n          \"confirmedRound\": 25969937,\n          \"appID\": 996657780,\n          \"applicationAccount\": \"I6AVUENYYJCIYONJCEYFSK3LNYUKASDLFQGGIKQDN3UU4DMIPPUEDB4CTA\",\n          \"timestamp\": 1672621846,\n          \"deleted\": false\n        }\n      }\n    },\n    \"dLsig\": {}\n  }\n};\nasync function readAppLocalState(account, appID, network) {\n  const accountInfoResponse = await indexerClient(network).lookupAccountByID(account).do();\n  for (const app of accountInfoResponse.account['apps-local-state']) {\n    if (app.id === appID) {\n      let localStateMap = new Map();\n      if (app['key-value']) {\n        localStateMap = decodeState(app[`key-value`]);\n      }\n      return localStateMap;\n    }\n  }\n  return undefined;\n}\nasync function executeRekeyedTx(web, txnParameters, authAddr, selectedWalletType) {\n  try {\n    const txns = [];\n    const groupTxn = assignGroupID(txnParameters);\n    for (const txn of groupTxn) {\n      if (selectedWalletType === Wallet.ALGOSIGNER) {\n        txns.push({\n          txn: Buffer.from(encodeUnsignedTransaction(txn)).toString('base64'),\n          signers: [authAddr],\n          authAddr: authAddr\n        });\n      } else {\n        txns.push({\n          txn: txn,\n          signers: authAddr\n        });\n      }\n    }\n    if (selectedWalletType === Wallet.ALGOSIGNER) {\n      const signTxns = await web.signTransaction(txns);\n      const txInfo = await web.sendGroupTransaction(signTxns);\n      const confirmedTx = await web.waitForConfirmation(txInfo.txId);\n    } else {\n      const txnsGroup = txns.map(v => v.txn);\n      const signTxns = await web.connector.signTransaction(txnsGroup.map(txn => txn.toByte()), {\n        overrideSigner: authAddr\n      });\n      const Uint8ArraySignedTx = signTxns === null || signTxns === void 0 ? void 0 : signTxns.map(stxn => stxn.blob);\n      const confirmedTx = await web.sendAndWait(Uint8ArraySignedTx);\n    }\n  } catch (e) {\n    console.error('Rekeyed Transaction Failed', e);\n    throw e;\n  }\n}\nasync function tryExecuteTx(web, txnParams) {\n  try {\n    const txnParameters = Array.isArray(txnParams) ? txnParams : [txnParams];\n    return await web.executeTx(txnParameters);\n  } catch (e) {\n    console.error('Transaction Failed', e);\n    throw e;\n  }\n}\nasync function getGovernanceNonce(adminAddr, network) {\n  var _appGlobalState$get;\n  const appGlobalState = await readAppGlobalState(adminAddr, OptAppID(network), network);\n\n  // during first governance period, simply return the algoAmt\n  const governanceNonce = (_appGlobalState$get = appGlobalState.get(GlobalStateKeys.GOVERNANCE_NONCE)) !== null && _appGlobalState$get !== void 0 ? _appGlobalState$get : 0;\n  return governanceNonce;\n}\n\n/**\n * Returns a list of custodial wallet addresses with a particular deposit amount.\n * Each account must be whitelisted and rekeyed to the optimum app.\n * + We use the indexer to query all accounts opted in & rekeyed to app,\n * and then we filter according to local state (whitelisted == 1, amt == depositAmt, register status, vote status)\n */\nasync function getCustodialWallets(optAppID, config, network, adminAddr) {\n  let limit = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100;\n  let getNextToken = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n  let nextTokenFromComp = arguments.length > 6 ? arguments[6] : undefined;\n  let nextToken = nextTokenFromComp;\n  const custodialWallets = [];\n  await (async () => {\n    while (custodialWallets.length < limit) {\n      let response = await indexerClient(network).searchAccounts().applicationID(OptAppID(network)).authAddr(getApplicationAddress(OptAppID(network))).nextToken(nextToken).do();\n      let transactions = response['accounts'];\n      if (transactions.length) {\n        nextToken = response['next-token'];\n        for (const acc of transactions) {\n          const localState = await readAppLocalState(acc.address, optAppID, network);\n          if (localState === undefined) {\n            continue;\n          }\n\n          // each wallet must be whitelistest irrespectively\n          const whitelisted = localState.get(LocalStateKeys.WHITELISTED);\n          let shouldPush = true;\n          if (whitelisted !== 1) {\n            shouldPush = false;\n          }\n\n          // check for all keys passed in config, if their values match\n          // if anyone doesn't, we don't push that address\n          if (config) {\n            for (const key in config) {\n              // for withdraw rewards\n              if (key === 'extraBalance') {\n                // note: taking into account that 0.5 ALGO must be present in the wallet\n                // to maintain min balance requirment and pay transaction fees\n                const bal = Math.floor(acc.amount - (100e6 + 0.5e6));\n                if (bal <= 0) {\n                  shouldPush = false;\n                }\n              } else {\n                const v = localState.get(key);\n\n                /*\n                 * Logic: If boolean is passed against \"registered\" & \"voted\", then\n                 * + if true, it means the value \"must be equal to governance nonce\", i.e registered/voted\n                 * + if false, it means the value \"must be LESS THAN governance nonce\" , i.e NOT registered/voted\n                 */\n                if (key === 'registered' || key === 'voted' && typeof config[key] === 'boolean') {\n                  const governanceNonce = await getGovernanceNonce(adminAddr, network);\n                  if (config[key] === true && v !== governanceNonce) {\n                    shouldPush = false;\n                    break;\n                  }\n                  if (config[key] === false && v >= governanceNonce) {\n                    shouldPush = false;\n                    break;\n                  }\n                } else {\n                  if (v !== config[key]) {\n                    shouldPush = false;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n          if (shouldPush === true) {\n            // need all information\n            if (!config) {\n              custodialWallets.push(acc);\n            } else {\n              custodialWallets.push(acc.address);\n            }\n          }\n        }\n      } else {\n        nextToken = undefined;\n        break;\n      }\n    }\n  })().catch(e => {\n    console.log(e);\n  });\n  if (getNextToken) {\n    return {\n      custodialWallets,\n      nextToken: nextToken\n    };\n  }\n  return custodialWallets;\n}\n\n/**\n * Returns an array with arrays of the given size.\n *\n * @param myArray {Array} array to split\n * @param chunk_size {Integer} Size of every group\n */\nfunction chunkArray(myArray, chunk_size) {\n  var index = 0;\n  var arrayLength = myArray.length;\n  var tempArray = [];\n  for (index = 0; index < arrayLength; index += chunk_size) {\n    let myChunk = myArray.slice(index, index + chunk_size);\n    // Do something if you want with the group\n    tempArray.push(myChunk);\n  }\n  return tempArray;\n}\nfunction decodeState(state) {\n  const stateMap = new Map();\n  for (const g of state) {\n    const key = Buffer.from(g.key, 'base64').toString();\n    if (g.value.type === 1) {\n      stateMap.set(key, g.value.bytes);\n    } else {\n      stateMap.set(key, g.value.uint);\n    }\n  }\n  return stateMap;\n}\nasync function readAppGlobalState(creator, appID, network) {\n  const appInfoResponse = await indexerClient(network).lookupApplications(appID).do();\n  let globalStateMap = new Map();\n  globalStateMap = decodeState(appInfoResponse.application.params['global-state']);\n  return globalStateMap;\n}\n\n// retuns an object containing the addresses + local_opt_balance for all accounts (accounts who deposited and got some OPT)\n// eg. { <addr1>: <amt1> , ..}\nasync function localOPTBalances(network) {\n  const accounts = await indexerClient(network).searchAccounts().applicationID(OptAppID(network)).do();\n  let localOptBalances = {};\n  for (const acc of accounts.accounts) {\n    const localState = await readAppLocalState(acc.address, OptAppID(network), network);\n    if (localState === undefined) {\n      continue;\n    }\n\n    // local OPT in user state\n    const localOptAmount = localState.get('local_opt_amt');\n    if (localOptAmount && localOptAmount > 0) {\n      localOptBalances[acc.address] = localOptAmount;\n    }\n  }\n  return localOptBalances;\n}\nasync function localOPTRewardAmt(network) {\n  const accounts = await indexerClient(network).searchAccounts().applicationID(OptAppID(network)).do();\n  let localOptRewardData = [];\n  for (const acc of accounts.accounts) {\n    const localState = await readAppLocalState(acc.address, OptAppID(network), network);\n    if (localState === undefined) {\n      continue;\n    }\n    const localOptRewardAmount = localState.get('local_opt_reward_amt');\n    const localOptAmount = localState.get('local_opt_amt');\n    localOptRewardData.push({\n      address: acc.address,\n      stake: localOptAmount && localOptAmount > 0 ? localOptAmount / 1e6 : 'Nil',\n      reward: localOptRewardAmount && localOptRewardAmount > 0 ? localOptRewardAmount / 1e6 : 'Nil'\n    });\n  }\n  return localOptRewardData;\n}\nasync function getAssetHolding(accountAddress, assetID, network) {\n  var _accountInfo$account;\n  const accountInfo = await indexerClient(network).lookupAccountByID(accountAddress).do();\n  console.log(\"account info***\", accountInfo);\n  if (accountInfo !== null && accountInfo !== void 0 && (_accountInfo$account = accountInfo.account) !== null && _accountInfo$account !== void 0 && _accountInfo$account.assets) {\n    for (const asset of accountInfo.account.assets) {\n      if (asset['asset-id'] === assetID) {\n        return asset;\n      }\n    }\n  }\n  return undefined;\n}\nasync function getContractAlgoHolding(network) {\n  const appAccountInfo = await indexerClient(network).lookupAccountByID(getApplicationAddress(OptAppID(network))).do();\n  return appAccountInfo.account.amount / 1e6;\n}\nasync function isApplicationOpted(accountAddress, appID, network) {\n  const accountInfo = await indexerClient(network).lookupAccountAppLocalStates(accountAddress).do();\n  if (accountInfo !== null && accountInfo !== void 0 && accountInfo['apps-local-states']) {\n    for (const app of accountInfo['apps-local-states']) {\n      if (app['id'] === appID) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nasync function optInApp(senderAddr, appID, web) {\n  try {\n    const execParam = {\n      type: types.TransactionType.OptInToApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAddr,\n      appID: appID,\n      payFlags: {\n        totalFee: 1000\n      }\n    };\n    await tryExecuteTx(web, execParam);\n  } catch (error) {\n    throw error;\n  }\n}\nasync function optInASA(senderAddr, assetID, web) {\n  try {\n    const execParam = {\n      type: types.TransactionType.OptInASA,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAddr,\n      assetID: assetID,\n      payFlags: {\n        totalFee: 1000\n      }\n    };\n    await tryExecuteTx(web, execParam);\n  } catch (error) {\n    throw error;\n  }\n}\nconst networkKey = network => {\n  switch (network) {\n    case NetworkArray[0]:\n      return 'mainnet';\n    case NetworkArray[1]:\n      return 'testnet';\n    case NetworkArray[3]:\n      return 'default';\n    default:\n      break;\n  }\n};\nconst OptAsaID = network => {\n  try {\n    return OptimumASA[networkKey(network)].asa.OptimumASA.assetIndex;\n  } catch {\n    return JSON.parse(OptimumASA.replace(\"module.exports = \", \"\"))[network.toLowerCase()].asa.OptimumASA.assetIndex;\n  }\n};\n_c = OptAsaID;\nconst OptAppID = network => {\n  try {\n    return Object.values(OptimumApp.default[networkKey(network)].ssc['Optimum App'])[0].appID;\n  } catch {\n    return Object.values(JSON.parse(OptimumApp.default.replace(\"module.exports = \", \"\"))[network.toLowerCase()].ssc['Optimum App'])[0].appID;\n  }\n};\n_c2 = OptAppID;\nconst TotalOPTMinted = network => {\n  return JSON.parse(OptimumASA.replace(\"module.exports = \", \"\"))[network.toLowerCase()].asa.OptimumASA.JSON.parse(OptimumASA.replace(\"module.exports = \", \"\"))[network.toLowerCase()].asa.OptimumASA.assetIndex.total;\n  // return OptimumASA[networkKey(network)].asa.OptimumASA.assetDef\n  //     .total;\n};\n_c3 = TotalOPTMinted;\nconst FEE_ADDR = 'EW4VAAYXIZ7ZAODYELMY5ZD335QYRAQAP6N527DIJYBLL52UVREDC4FROI';\nconst WEEKS_IN_GOVERNANCE_PERIOD = 13;\n\n// here we will generate 10 accounts. Change this no. if you want to generate more accounts\nconst GEN_ACCOUNTS_CNT = 10;\nexport { tryExecuteTx, GEN_ACCOUNTS_CNT, getCustodialWallets, chunkArray, readAppLocalState, readAppGlobalState, getAssetHolding, getContractAlgoHolding, OptAsaID, OptAppID, getGovernanceNonce, FEE_ADDR, localOPTBalances, WEEKS_IN_GOVERNANCE_PERIOD, localOPTRewardAmt, isApplicationOpted, decodeState, TotalOPTMinted, executeRekeyedTx, optInASA, optInApp };\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"OptAsaID\");\n$RefreshReg$(_c2, \"OptAppID\");\n$RefreshReg$(_c3, \"TotalOPTMinted\");","map":{"version":3,"names":["mkTxParams","tx","types","GlobalStateKeys","LocalStateKeys","NetworkArray","Wallet","indexerClient","getApplicationAddress","assignGroupID","encodeUnsignedTransaction","require","OptimumASA","OptimumApp","readAppLocalState","account","appID","network","accountInfoResponse","lookupAccountByID","do","app","id","localStateMap","Map","decodeState","undefined","executeRekeyedTx","web","txnParameters","authAddr","selectedWalletType","txns","groupTxn","txn","ALGOSIGNER","push","Buffer","from","toString","signers","signTxns","signTransaction","txInfo","sendGroupTransaction","confirmedTx","waitForConfirmation","txId","txnsGroup","map","v","connector","toByte","overrideSigner","Uint8ArraySignedTx","stxn","blob","sendAndWait","e","console","error","tryExecuteTx","txnParams","Array","isArray","executeTx","getGovernanceNonce","adminAddr","appGlobalState","readAppGlobalState","OptAppID","governanceNonce","get","GOVERNANCE_NONCE","getCustodialWallets","optAppID","config","limit","getNextToken","nextTokenFromComp","nextToken","custodialWallets","length","response","searchAccounts","applicationID","transactions","acc","localState","address","whitelisted","WHITELISTED","shouldPush","key","bal","Math","floor","amount","catch","log","chunkArray","myArray","chunk_size","index","arrayLength","tempArray","myChunk","slice","state","stateMap","g","value","type","set","bytes","uint","creator","appInfoResponse","lookupApplications","globalStateMap","application","params","localOPTBalances","accounts","localOptBalances","localOptAmount","localOPTRewardAmt","localOptRewardData","localOptRewardAmount","stake","reward","getAssetHolding","accountAddress","assetID","accountInfo","assets","asset","getContractAlgoHolding","appAccountInfo","isApplicationOpted","lookupAccountAppLocalStates","optInApp","senderAddr","execParam","TransactionType","OptInToApp","sign","SignType","SecretKey","fromAccountAddr","payFlags","totalFee","optInASA","OptInASA","networkKey","OptAsaID","asa","assetIndex","JSON","parse","replace","toLowerCase","Object","values","default","ssc","TotalOPTMinted","total","FEE_ADDR","WEEKS_IN_GOVERNANCE_PERIOD","GEN_ACCOUNTS_CNT"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/common.js"],"sourcesContent":["import { mkTxParams, tx, types } from '@algo-builder/web';\nimport {\n    GlobalStateKeys,\n    LocalStateKeys,\n    NetworkArray,\n    Wallet\n} from '../constants/constants';\nimport { indexerClient } from './algob.config';\nconst {\n    getApplicationAddress,\n    assignGroupID,\n    encodeUnsignedTransaction\n} = require('algosdk');\n\nlet OptimumASA = {\"mainnet\":{\"timestamp\":1672621838734,\"metadata\":{},\"asa\":{\"OptimumASA\":{\"creator\":\"2UBZKFR6RCZL7R24ZG327VKPTPJUPFM6WTG7PJG2ZJLU234F5RGXFLTAKA\",\"txId\":\"2WSA2INHLLNW7JI6NPZPWX7WKG47NKLTYGGRQDKV6WMTFHXS4F6A\",\"assetIndex\":996657698,\"confirmedRound\":25969935,\"assetDef\":{\"total\":\"10000000000000000\",\"decimals\":6,\"unitName\":\"OPT\",\"url\":\"https://<name>.com\",\"metadataHash\":\"12312442142141241244444411111133\",\"note\":\"Algorand governance Optimum ASA\",\"manager\":null,\"reserve\":null,\"freeze\":null,\"clawback\":null,\"defaultFrozen\":false,\"name\":\"OptimumASA\"},\"deleted\":false}},\"ssc\":{},\"dLsig\":{}}}\nlet OptimumApp = {\"mainnet\":{\"timestamp\":1672621846342,\"metadata\":{},\"asa\":{},\"ssc\":{\"Optimum App\":{\"1672621846\":{\"creator\":\"2UBZKFR6RCZL7R24ZG327VKPTPJUPFM6WTG7PJG2ZJLU234F5RGXFLTAKA\",\"txId\":\"5RDBACFR3ZEN7ZHJIFZAXBTZERWSYOV2GAY7IQXOVHDKRCKW2REA\",\"confirmedRound\":25969937,\"appID\":996657780,\"applicationAccount\":\"I6AVUENYYJCIYONJCEYFSK3LNYUKASDLFQGGIKQDN3UU4DMIPPUEDB4CTA\",\"timestamp\":1672621846,\"deleted\":false}}},\"dLsig\":{}}}\n\nasync function readAppLocalState(account, appID, network) {\n    const accountInfoResponse = await indexerClient(network)\n        .lookupAccountByID(account)\n        .do();\n\n    for (const app of accountInfoResponse.account['apps-local-state']) {\n        if (app.id === appID) {\n            let localStateMap = new Map();\n            if (app['key-value']) {\n                localStateMap = decodeState(app[`key-value`]);\n            }\n            return localStateMap;\n        }\n    }\n    return undefined;\n}\n\nasync function executeRekeyedTx(\n    web,\n    txnParameters,\n    authAddr,\n    selectedWalletType\n) {\n    try {\n        const txns = [];\n        const groupTxn = assignGroupID(txnParameters);\n        for (const txn of groupTxn) {\n            if (selectedWalletType === Wallet.ALGOSIGNER) {\n                txns.push({\n                    txn: Buffer.from(encodeUnsignedTransaction(txn)).toString(\n                        'base64'\n                    ),\n                    signers: [authAddr],\n                    authAddr: authAddr\n                });\n            } else {\n                txns.push({\n                    txn: txn,\n                    signers: authAddr\n                });\n            }\n        }\n\n        if (selectedWalletType === Wallet.ALGOSIGNER) {\n            const signTxns = await web.signTransaction(txns);\n            const txInfo = await web.sendGroupTransaction(signTxns);\n            const confirmedTx = await web.waitForConfirmation(txInfo.txId);\n        } else {\n            const txnsGroup = txns.map((v) => v.txn);\n            const signTxns = await web.connector.signTransaction(\n                txnsGroup.map((txn) => txn.toByte()),\n                {\n                    overrideSigner: authAddr\n                }\n            );\n\n            const Uint8ArraySignedTx = signTxns?.map((stxn) => stxn.blob);\n            const confirmedTx = await web.sendAndWait(Uint8ArraySignedTx);\n        }\n    } catch (e) {\n        console.error('Rekeyed Transaction Failed', e);\n        throw e;\n    }\n}\n\nasync function tryExecuteTx(web, txnParams) {\n    try {\n        const txnParameters = Array.isArray(txnParams)\n            ? txnParams\n            : [txnParams];\n        return await web.executeTx(txnParameters);\n    } catch (e) {\n        console.error('Transaction Failed', e);\n        throw e;\n    }\n}\n\nasync function getGovernanceNonce(adminAddr, network) {\n    const appGlobalState = await readAppGlobalState(\n        adminAddr,\n        OptAppID(network),\n        network\n    );\n\n    // during first governance period, simply return the algoAmt\n    const governanceNonce =\n        appGlobalState.get(GlobalStateKeys.GOVERNANCE_NONCE) ?? 0;\n    return governanceNonce;\n}\n\n/**\n * Returns a list of custodial wallet addresses with a particular deposit amount.\n * Each account must be whitelisted and rekeyed to the optimum app.\n * + We use the indexer to query all accounts opted in & rekeyed to app,\n * and then we filter according to local state (whitelisted == 1, amt == depositAmt, register status, vote status)\n */\nasync function getCustodialWallets(\n    optAppID,\n    config,\n    network,\n    adminAddr,\n    limit = 100,\n    getNextToken = false,\n    nextTokenFromComp\n) {\n    let nextToken = nextTokenFromComp;\n    const custodialWallets = [];\n    await (async () => {\n        while (custodialWallets.length < limit) {\n            let response = await indexerClient(network)\n                .searchAccounts()\n                .applicationID(OptAppID(network))\n                .authAddr(getApplicationAddress(OptAppID(network)))\n                .nextToken(nextToken)\n                .do();\n            let transactions = response['accounts'];\n            if (transactions.length) {\n                nextToken = response['next-token'];\n                for (const acc of transactions) {\n                    const localState = await readAppLocalState(\n                        acc.address,\n                        optAppID,\n                        network\n                    );\n                    if (localState === undefined) {\n                        continue;\n                    }\n\n                    // each wallet must be whitelistest irrespectively\n                    const whitelisted = localState.get(\n                        LocalStateKeys.WHITELISTED\n                    );\n                    let shouldPush = true;\n                    if (whitelisted !== 1) {\n                        shouldPush = false;\n                    }\n\n                    // check for all keys passed in config, if their values match\n                    // if anyone doesn't, we don't push that address\n                    if (config) {\n                        for (const key in config) {\n                            // for withdraw rewards\n                            if (key === 'extraBalance') {\n                                // note: taking into account that 0.5 ALGO must be present in the wallet\n                                // to maintain min balance requirment and pay transaction fees\n                                const bal = Math.floor(\n                                    acc.amount - (100e6 + 0.5e6)\n                                );\n\n                                if (bal <= 0) {\n                                    shouldPush = false;\n                                }\n                            } else {\n                                const v = localState.get(key);\n\n                                /*\n                                 * Logic: If boolean is passed against \"registered\" & \"voted\", then\n                                 * + if true, it means the value \"must be equal to governance nonce\", i.e registered/voted\n                                 * + if false, it means the value \"must be LESS THAN governance nonce\" , i.e NOT registered/voted\n                                 */\n                                if (\n                                    key === 'registered' ||\n                                    (key === 'voted' &&\n                                        typeof config[key] === 'boolean')\n                                ) {\n                                    const governanceNonce =\n                                        await getGovernanceNonce(\n                                            adminAddr,\n                                            network\n                                        );\n                                    if (\n                                        config[key] === true &&\n                                        v !== governanceNonce\n                                    ) {\n                                        shouldPush = false;\n                                        break;\n                                    }\n\n                                    if (\n                                        config[key] === false &&\n                                        v >= governanceNonce\n                                    ) {\n                                        shouldPush = false;\n                                        break;\n                                    }\n                                } else {\n                                    if (v !== config[key]) {\n                                        shouldPush = false;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    if (shouldPush === true) {\n                        // need all information\n                        if (!config) {\n                            custodialWallets.push(acc);\n                        } else {\n                            custodialWallets.push(acc.address);\n                        }\n                    }\n                }\n            } else {\n                nextToken = undefined;\n                break;\n            }\n        }\n    })().catch((e) => {\n        console.log(e);\n    });\n\n    if (getNextToken) {\n        return { custodialWallets, nextToken: nextToken };\n    }\n    return custodialWallets;\n}\n\n/**\n * Returns an array with arrays of the given size.\n *\n * @param myArray {Array} array to split\n * @param chunk_size {Integer} Size of every group\n */\nfunction chunkArray(myArray, chunk_size) {\n    var index = 0;\n    var arrayLength = myArray.length;\n    var tempArray = [];\n\n    for (index = 0; index < arrayLength; index += chunk_size) {\n        let myChunk = myArray.slice(index, index + chunk_size);\n        // Do something if you want with the group\n        tempArray.push(myChunk);\n    }\n\n    return tempArray;\n}\n\nfunction decodeState(state) {\n    const stateMap = new Map();\n    for (const g of state) {\n        const key = Buffer.from(g.key, 'base64').toString();\n        if (g.value.type === 1) {\n            stateMap.set(key, g.value.bytes);\n        } else {\n            stateMap.set(key, g.value.uint);\n        }\n    }\n    return stateMap;\n}\n\nasync function readAppGlobalState(creator, appID, network) {\n    const appInfoResponse = await indexerClient(network)\n        .lookupApplications(appID)\n        .do();\n\n    let globalStateMap = new Map();\n    globalStateMap = decodeState(\n        appInfoResponse.application.params['global-state']\n    );\n    return globalStateMap;\n}\n\n// retuns an object containing the addresses + local_opt_balance for all accounts (accounts who deposited and got some OPT)\n// eg. { <addr1>: <amt1> , ..}\nasync function localOPTBalances(network) {\n    const accounts = await indexerClient(network)\n        .searchAccounts()\n        .applicationID(OptAppID(network))\n        .do();\n\n    let localOptBalances = {};\n    for (const acc of accounts.accounts) {\n        const localState = await readAppLocalState(\n            acc.address,\n            OptAppID(network),\n            network\n        );\n        if (localState === undefined) {\n            continue;\n        }\n\n        // local OPT in user state\n        const localOptAmount = localState.get('local_opt_amt');\n        if (localOptAmount && localOptAmount > 0) {\n            localOptBalances[acc.address] = localOptAmount;\n        }\n    }\n\n    return localOptBalances;\n}\n\nasync function localOPTRewardAmt(network) {\n    const accounts = await indexerClient(network)\n        .searchAccounts()\n        .applicationID(OptAppID(network))\n        .do();\n\n    let localOptRewardData = [];\n    for (const acc of accounts.accounts) {\n        const localState = await readAppLocalState(\n            acc.address,\n            OptAppID(network),\n            network\n        );\n\n        if (localState === undefined) {\n            continue;\n        }\n\n        const localOptRewardAmount = localState.get('local_opt_reward_amt');\n        const localOptAmount = localState.get('local_opt_amt');\n        localOptRewardData.push({\n            address: acc.address,\n            stake:\n                localOptAmount && localOptAmount > 0\n                    ? localOptAmount / 1e6\n                    : 'Nil',\n            reward:\n                localOptRewardAmount && localOptRewardAmount > 0\n                    ? localOptRewardAmount / 1e6\n                    : 'Nil'\n        });\n    }\n\n    return localOptRewardData;\n}\n\nasync function getAssetHolding(accountAddress, assetID, network) {\n    const accountInfo = await indexerClient(network)\n        .lookupAccountByID(accountAddress)\n        .do();\n\n    console.log(\"account info***\", accountInfo)\n\n    if (accountInfo?.account?.assets) {\n        for (const asset of accountInfo.account.assets) {\n            if (asset['asset-id'] === assetID) {\n                return asset;\n            }\n        }\n    }\n    return undefined;\n}\n\nasync function getContractAlgoHolding(network) {\n    const appAccountInfo = await indexerClient(network)\n        .lookupAccountByID(getApplicationAddress(OptAppID(network)))\n        .do();\n\n    return appAccountInfo.account.amount / 1e6;\n}\n\nasync function isApplicationOpted(accountAddress, appID, network) {\n    const accountInfo = await indexerClient(network)\n        .lookupAccountAppLocalStates(accountAddress)\n        .do();\n\n    if (accountInfo?.['apps-local-states']) {\n        for (const app of accountInfo['apps-local-states']) {\n            if (app['id'] === appID) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nasync function optInApp(senderAddr, appID, web) {\n    try {\n        const execParam = {\n            type: types.TransactionType.OptInToApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAddr,\n            appID: appID,\n            payFlags: { totalFee: 1000 }\n        };\n        await tryExecuteTx(web, execParam);\n    } catch (error) {\n        throw error;\n    }\n}\n\nasync function optInASA(senderAddr, assetID, web) {\n    try {\n        const execParam = {\n            type: types.TransactionType.OptInASA,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAddr,\n            assetID: assetID,\n            payFlags: { totalFee: 1000 }\n        };\n        await tryExecuteTx(web, execParam);\n    } catch (error) {\n        throw error;\n    }\n}\n\nconst networkKey = (network) => {\n    switch (network) {\n        case NetworkArray[0]:\n            return 'mainnet';\n        case NetworkArray[1]:\n            return 'testnet';\n        case NetworkArray[3]:\n            return 'default';\n        default:\n            break;\n    }\n};\n\nconst OptAsaID = (network) => {\n    try{\n        return OptimumASA[networkKey(network)].asa.OptimumASA.assetIndex;\n    } catch {\n        return JSON.parse(OptimumASA.replace(\"module.exports = \", \"\"))[network.toLowerCase()].asa.OptimumASA.assetIndex\n    }\n\n\n\n};\nconst OptAppID = (network) => {\n\n    try {\n        return Object.values(\n            OptimumApp.default[networkKey(network)].ssc['Optimum App']\n        )[0].appID;\n        \n    } catch {\n        return Object.values(\n            JSON.parse(OptimumApp.default.replace(\"module.exports = \", \"\"))[network.toLowerCase()].ssc['Optimum App']\n        )[0].appID;\n    }\n};\n\nconst TotalOPTMinted = (network) => {\n    return JSON.parse(OptimumASA.replace(\"module.exports = \", \"\"))[network.toLowerCase()].asa.OptimumASA.JSON.parse(OptimumASA.replace(\"module.exports = \", \"\"))[network.toLowerCase()].asa.OptimumASA.assetIndex.total\n    // return OptimumASA[networkKey(network)].asa.OptimumASA.assetDef\n    //     .total;\n};\n\nconst FEE_ADDR = 'EW4VAAYXIZ7ZAODYELMY5ZD335QYRAQAP6N527DIJYBLL52UVREDC4FROI';\nconst WEEKS_IN_GOVERNANCE_PERIOD = 13;\n\n// here we will generate 10 accounts. Change this no. if you want to generate more accounts\nconst GEN_ACCOUNTS_CNT = 10;\nexport {\n    tryExecuteTx,\n    GEN_ACCOUNTS_CNT,\n    getCustodialWallets,\n    chunkArray,\n    readAppLocalState,\n    readAppGlobalState,\n    getAssetHolding,\n    getContractAlgoHolding,\n    OptAsaID,\n    OptAppID,\n    getGovernanceNonce,\n    FEE_ADDR,\n    localOPTBalances,\n    WEEKS_IN_GOVERNANCE_PERIOD,\n    localOPTRewardAmt,\n    isApplicationOpted,\n    decodeState,\n    TotalOPTMinted,\n    executeRekeyedTx,\n    optInASA,\n    optInApp\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}