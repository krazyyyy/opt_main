{"ast":null,"code":"/* global BigInt */\n\nimport { AppActions, GlobalStateKeys } from '../constants/constants.js';\nconst {\n  types\n} = require('@algo-builder/web');\nconst {\n  tryExecuteTx,\n  getCustodialWallets,\n  chunkArray,\n  OptAsaID,\n  OptAppID,\n  readAppGlobalState,\n  getAssetHolding,\n  isApplicationOpted\n} = require('./common.js');\nconst {\n  getApplicationAddress\n} = require('algosdk');\nexport async function expectedOPTAmount(algoAmt, network, adminAddr) {\n  var _appGlobalState$get, _appGlobalState$get2, _appGlobalState$get3;\n  // console.log(encodeForSigning(OptAppID(network)))\n  // console.log(getApplicationAddress())\n  // define bellow to const appOPTHolding = await getAssetHolding -- if needed\n\n  // const appAccountInfo = await indexerClient(network)\n  // .lookupAccountByID(getApplicationAddress(OptAppID(network)))\n  // .do();\n\n  // const appOPTHolding = await getAssetHolding(\n  //     getApplicationAddress(OptAppID(network)),\n  //     OptAsaID(network),\n  //     network\n  // );\n\n  const appGlobalState = await readAppGlobalState(adminAddr, OptAppID(network), network);\n\n  // during first governance period, simply return the algoAmt\n  const governanceNonce = (_appGlobalState$get = appGlobalState.get(GlobalStateKeys.GOVERNANCE_NONCE)) !== null && _appGlobalState$get !== void 0 ? _appGlobalState$get : 0;\n  if (governanceNonce <= 1) {\n    return algoAmt / 1e6;\n  }\n\n  // const globalCustodialDeposit =\n  //     appGlobalState.get(GlobalStateKeys.CUSTODIAL_DEPOSIT) ?? 0;\n\n  /*\n  Below is the dynamic exchange rate - but since we're keeping the exchange rate static\n  for each period now, we're going to use the static exchange rate (for each respective period)\n   const num =\n      BigInt(algoAmt) *\n      ((TEN_BILLION - BigInt(appOPTHolding.amount)) / 1000000n);\n  const den =\n      BigInt(appAccountInfo.account.amount) +\n      BigInt(globalCustodialDeposit) -\n      BigInt(ACCOUNT_MIN_BALANCE);\n  */\n\n  const num = BigInt(algoAmt) * BigInt((_appGlobalState$get2 = appGlobalState.get(GlobalStateKeys.GLOBAL_TOTAL_OPT_DISPERSED_AT_GOVERNANCE)) !== null && _appGlobalState$get2 !== void 0 ? _appGlobalState$get2 : 0);\n  const den = BigInt((_appGlobalState$get3 = appGlobalState.get(GlobalStateKeys.GLOBAL_APP_BALANCE_AT_GOVERNANCE)) !== null && _appGlobalState$get3 !== void 0 ? _appGlobalState$get3 : 0);\n  if (num === 0n) {\n    return 0;\n  }\n  const expectedAmt = Number(num / den) / 1e6;\n  return expectedAmt;\n}\nexport async function deposit(web, senderAcc, algoAmt, network, adminAddr) {\n  const userASAHolding = await getAssetHolding(senderAcc, OptAsaID(network), network);\n  const isAppOpted = await isApplicationOpted(senderAcc, OptAppID(network), network);\n  if (!isAppOpted) {\n    const optInAppParams = {\n      type: types.TransactionType.OptInToApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAcc,\n      appID: OptAppID(network),\n      payFlags: {\n        totalFee: 1000\n      }\n    };\n    await tryExecuteTx(web, optInAppParams);\n  }\n\n  // opt in to optimum ASA first (so that sender can receive OPT)\n  if (userASAHolding === undefined) {\n    const optInASAParams = {\n      type: types.TransactionType.OptInASA,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAcc,\n      assetID: OptAsaID(network),\n      payFlags: {\n        totalFee: 1000\n      }\n    };\n    await tryExecuteTx(web, optInASAParams);\n  }\n\n  // deposit ALGO to the contract, receive OPT\n  const depositTxGroup = [{\n    type: types.TransactionType.TransferAlgo,\n    sign: types.SignType.SecretKey,\n    fromAccountAddr: senderAcc,\n    toAccountAddr: getApplicationAddress(OptAppID(network)),\n    amountMicroAlgos: algoAmt,\n    payFlags: {\n      totalFee: 1000\n    }\n  }, {\n    type: types.TransactionType.CallApp,\n    sign: types.SignType.SecretKey,\n    fromAccountAddr: senderAcc,\n    appID: OptAppID(network),\n    payFlags: {\n      totalFee: 2000\n    },\n    appArgs: [AppActions.EXCHANGE],\n    foreignAssets: [OptAsaID(network)]\n  }];\n  await tryExecuteTx(web, depositTxGroup);\n}\n\n/**\n * Find and fund custodial wallets with 10000 ALGO increments. Returns if enough wallets\n * are not available.\n * NOTE: deposit amount is in microAlgos\n */\nexport async function fundCustodialWallets(web, senderAcc, optAppID, depositAmt, network) {\n  // extract custodial wallets from indexer, which we will fund\n  const custodialWalletsOrig = await getCustodialWallets(optAppID, {\n    deposited: 0\n  }, network);\n\n  // TODO: ask about remainder amt (atm we just leave it in the optimum app)\n  // const reqWallets = depositAmt/10000 + (depositAmt % 10000 !== 0 ? 1 : 0);\n\n  const reqWallets = Math.round(depositAmt / 10000e6);\n  if (custodialWalletsOrig.length < reqWallets) {\n    throw new Error(`Not enough wallets to fund. Required ${reqWallets} but got ${custodialWalletsOrig.length}. Please generate more accounts`);\n  }\n\n  // get only the addresses we need.\n  const custodialWallets = custodialWalletsOrig.slice(0, reqWallets);\n\n  // split whole custodial wallets array into chunks of 4\n  // as max 4 accounts can be passed in a tx group.\n  const txAccountArrays = chunkArray(custodialWallets, 4);\n\n  // after getting wallets, let's construct the transactions\n  const txArray = [];\n  for (let i = 0, j = 0; i < reqWallets; i += 4, j++) {\n    // in each iteration we're funding 4 wallets\n    txArray.push({\n      type: types.TransactionType.CallApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAcc,\n      // addr\n      appID: optAppID,\n      payFlags: {\n        totalFee: 1000 + 1000 * txAccountArrays[j].length\n      },\n      accounts: txAccountArrays[j],\n      appArgs: [AppActions.CUSTODIAL_DEPOSIT]\n    });\n  }\n\n  // finally assemble transactions into groups of 16. Submit each group to network\n  const txGroups = chunkArray(txArray, 16);\n  for (const grp of txGroups) {\n    await tryExecuteTx(web, grp);\n  }\n}","map":{"version":3,"names":["AppActions","GlobalStateKeys","types","require","tryExecuteTx","getCustodialWallets","chunkArray","OptAsaID","OptAppID","readAppGlobalState","getAssetHolding","isApplicationOpted","getApplicationAddress","expectedOPTAmount","algoAmt","network","adminAddr","appGlobalState","governanceNonce","get","GOVERNANCE_NONCE","num","BigInt","GLOBAL_TOTAL_OPT_DISPERSED_AT_GOVERNANCE","den","GLOBAL_APP_BALANCE_AT_GOVERNANCE","expectedAmt","Number","deposit","web","senderAcc","userASAHolding","isAppOpted","optInAppParams","type","TransactionType","OptInToApp","sign","SignType","SecretKey","fromAccountAddr","appID","payFlags","totalFee","undefined","optInASAParams","OptInASA","assetID","depositTxGroup","TransferAlgo","toAccountAddr","amountMicroAlgos","CallApp","appArgs","EXCHANGE","foreignAssets","fundCustodialWallets","optAppID","depositAmt","custodialWalletsOrig","deposited","reqWallets","Math","round","length","Error","custodialWallets","slice","txAccountArrays","txArray","i","j","push","accounts","CUSTODIAL_DEPOSIT","txGroups","grp"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/deposit.js"],"sourcesContent":["/* global BigInt */\n\nimport {\n    AppActions,\n    GlobalStateKeys,\n} from '../constants/constants.js';\nconst { types } = require('@algo-builder/web');\nconst {\n    tryExecuteTx,\n    getCustodialWallets,\n    chunkArray,\n    OptAsaID,\n    OptAppID,\n    readAppGlobalState,\n    getAssetHolding,\n    isApplicationOpted\n} = require('./common.js');\nconst { getApplicationAddress } = require('algosdk');\n\nexport async function expectedOPTAmount(algoAmt, network, adminAddr) {\n    // console.log(encodeForSigning(OptAppID(network)))\n    // console.log(getApplicationAddress())\n    // define bellow to const appOPTHolding = await getAssetHolding -- if needed\n\n    // const appAccountInfo = await indexerClient(network)\n    // .lookupAccountByID(getApplicationAddress(OptAppID(network)))\n    // .do();\n    \n    // const appOPTHolding = await getAssetHolding(\n    //     getApplicationAddress(OptAppID(network)),\n    //     OptAsaID(network),\n    //     network\n    // );\n\n\n    const appGlobalState = await readAppGlobalState(\n        adminAddr,\n        OptAppID(network),\n        network\n    );\n    \n\n    // during first governance period, simply return the algoAmt\n    const governanceNonce =\n        appGlobalState.get(GlobalStateKeys.GOVERNANCE_NONCE) ?? 0;\n    if (governanceNonce <= 1) {\n        return algoAmt / 1e6;\n    }\n\n    // const globalCustodialDeposit =\n    //     appGlobalState.get(GlobalStateKeys.CUSTODIAL_DEPOSIT) ?? 0;\n\n    /*\n    Below is the dynamic exchange rate - but since we're keeping the exchange rate static\n    for each period now, we're going to use the static exchange rate (for each respective period)\n\n    const num =\n        BigInt(algoAmt) *\n        ((TEN_BILLION - BigInt(appOPTHolding.amount)) / 1000000n);\n    const den =\n        BigInt(appAccountInfo.account.amount) +\n        BigInt(globalCustodialDeposit) -\n        BigInt(ACCOUNT_MIN_BALANCE);\n    */\n\n    const num =\n        BigInt(algoAmt) *\n        (BigInt(appGlobalState.get(GlobalStateKeys.GLOBAL_TOTAL_OPT_DISPERSED_AT_GOVERNANCE) ?? 0));\n    \n    const den = BigInt(appGlobalState.get(GlobalStateKeys.GLOBAL_APP_BALANCE_AT_GOVERNANCE) ?? 0);\n\n    if (num === 0n) {\n        return 0;\n    }\n\n    const expectedAmt = Number(num / den) / 1e6;\n    return expectedAmt;\n}\n\nexport async function deposit(web, senderAcc, algoAmt, network, adminAddr) {\n    const userASAHolding = await getAssetHolding(\n        senderAcc,\n        OptAsaID(network),\n        network\n    );\n\n    const isAppOpted = await isApplicationOpted(\n        senderAcc,\n        OptAppID(network),\n        network\n        );\n\n    \n\n    if (!isAppOpted) {\n        const optInAppParams = {\n            type: types.TransactionType.OptInToApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 1000 }\n        };\n        await tryExecuteTx(web, optInAppParams);\n    }\n\n    // opt in to optimum ASA first (so that sender can receive OPT)\n    if (userASAHolding === undefined) {\n        const optInASAParams = {\n            type: types.TransactionType.OptInASA,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            assetID: OptAsaID(network),\n            payFlags: { totalFee: 1000 }\n        };\n        await tryExecuteTx(web, optInASAParams);\n    }\n\n    // deposit ALGO to the contract, receive OPT\n    const depositTxGroup = [\n        {\n            type: types.TransactionType.TransferAlgo,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            toAccountAddr: getApplicationAddress(OptAppID(network)),\n            amountMicroAlgos: algoAmt,\n            payFlags: { totalFee: 1000 }\n        },\n        {\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 2000 },\n            appArgs: [AppActions.EXCHANGE],\n            foreignAssets: [OptAsaID(network)]\n        }\n    ];\n    await tryExecuteTx(web, depositTxGroup);\n}\n\n/**\n * Find and fund custodial wallets with 10000 ALGO increments. Returns if enough wallets\n * are not available.\n * NOTE: deposit amount is in microAlgos\n */\nexport async function fundCustodialWallets(\n    web,\n    senderAcc,\n    optAppID,\n    depositAmt,\n    network\n) {\n    // extract custodial wallets from indexer, which we will fund\n    const custodialWalletsOrig = await getCustodialWallets(\n        optAppID,\n        {\n            deposited: 0\n        },\n        network\n    );\n\n    // TODO: ask about remainder amt (atm we just leave it in the optimum app)\n    // const reqWallets = depositAmt/10000 + (depositAmt % 10000 !== 0 ? 1 : 0);\n\n    const reqWallets = Math.round(depositAmt / 10000e6);\n    if (custodialWalletsOrig.length < reqWallets) {\n        throw new Error(\n            `Not enough wallets to fund. Required ${reqWallets} but got ${custodialWalletsOrig.length}. Please generate more accounts`\n        );\n    }\n\n    // get only the addresses we need.\n    const custodialWallets = custodialWalletsOrig.slice(0, reqWallets);\n\n    // split whole custodial wallets array into chunks of 4\n    // as max 4 accounts can be passed in a tx group.\n    const txAccountArrays = chunkArray(custodialWallets, 4);\n\n    // after getting wallets, let's construct the transactions\n    const txArray = [];\n    for (let i = 0, j = 0; i < reqWallets; i += 4, j++) {\n        // in each iteration we're funding 4 wallets\n        txArray.push({\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc, // addr\n            appID: optAppID,\n            payFlags: { totalFee: 1000 + 1000 * txAccountArrays[j].length },\n            accounts: txAccountArrays[j],\n            appArgs: [AppActions.CUSTODIAL_DEPOSIT]\n        });\n    }\n\n    // finally assemble transactions into groups of 16. Submit each group to network\n    const txGroups = chunkArray(txArray, 16);\n    for (const grp of txGroups) {\n        await tryExecuteTx(web, grp);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}