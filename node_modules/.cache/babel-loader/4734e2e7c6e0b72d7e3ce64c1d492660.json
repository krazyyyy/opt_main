{"ast":null,"code":"import { ABITupleType, ABIUintType, ABIAddressType, ABIReferenceType, abiTypeIsTransaction, abiCheckTransactionType, abiTypeIsReference } from './abi';\nimport { Transaction, decodeSignedTransaction } from './transaction';\nimport { makeApplicationCallTxnFromObject } from './makeTxn';\nimport { assignGroupID } from './group';\nimport { waitForConfirmation } from './wait';\nimport { isTransactionWithSigner } from './signer';\nimport { OnApplicationComplete } from './types/transactions/base';\n// First 4 bytes of SHA-512/256 hash of \"return\"\nconst RETURN_PREFIX = Buffer.from([21, 31, 124, 117]);\n// The maximum number of arguments for an application call transaction\nconst MAX_APP_ARGS = 16;\nexport var AtomicTransactionComposerStatus;\n(function (AtomicTransactionComposerStatus) {\n  /** The atomic group is still under construction. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILDING\"] = 0] = \"BUILDING\";\n  /** The atomic group has been finalized, but not yet signed. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"BUILT\"] = 1] = \"BUILT\";\n  /** The atomic group has been finalized and signed, but not yet submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SIGNED\"] = 2] = \"SIGNED\";\n  /** The atomic group has been finalized, signed, and submitted to the network. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"SUBMITTED\"] = 3] = \"SUBMITTED\";\n  /** The atomic group has been finalized, signed, submitted, and successfully committed to a block. */\n  AtomicTransactionComposerStatus[AtomicTransactionComposerStatus[\"COMMITTED\"] = 4] = \"COMMITTED\";\n})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));\n/**\n * Add a value to an application call's foreign array. The addition will be as compact as possible,\n * and this function will return an index that can be used to reference `valueToAdd` in `array`.\n *\n * @param valueToAdd - The value to add to the array. If this value is already present in the array,\n *   it will not be added again. Instead, the existing index will be returned.\n * @param array - The existing foreign array. This input may be modified to append `valueToAdd`.\n * @param zeroValue - If provided, this value indicated two things: the 0 value is special for this\n *   array, so all indexes into `array` must start at 1; additionally, if `valueToAdd` equals\n *   `zeroValue`, then `valueToAdd` will not be added to the array, and instead the 0 indexes will\n *   be returned.\n * @returns An index that can be used to reference `valueToAdd` in `array`.\n */\nfunction populateForeignArray(valueToAdd, array, zeroValue) {\n  if (zeroValue != null && valueToAdd === zeroValue) {\n    return 0;\n  }\n  const offset = zeroValue == null ? 0 : 1;\n  for (let i = 0; i < array.length; i++) {\n    if (valueToAdd === array[i]) {\n      return i + offset;\n    }\n  }\n  array.push(valueToAdd);\n  return array.length - 1 + offset;\n}\n/** A class used to construct and execute atomic transaction groups */\nexport class AtomicTransactionComposer {\n  constructor() {\n    this.status = AtomicTransactionComposerStatus.BUILDING;\n    this.transactions = [];\n    this.methodCalls = new Map();\n    this.signedTxns = [];\n    this.txIDs = [];\n  }\n  /**\n   * Get the status of this composer's transaction group.\n   */\n  getStatus() {\n    return this.status;\n  }\n  /**\n   * Get the number of transactions currently in this atomic group.\n   */\n  count() {\n    return this.transactions.length;\n  }\n  /**\n   * Create a new composer with the same underlying transactions. The new composer's status will be\n   * BUILDING, so additional transactions may be added to it.\n   */\n  clone() {\n    const theClone = new AtomicTransactionComposer();\n    theClone.transactions = this.transactions.map(_ref => {\n      let {\n        txn,\n        signer\n      } = _ref;\n      return {\n        // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)\n        txn: Transaction.from_obj_for_encoding({\n          ...txn.get_obj_for_encoding(),\n          // erase the group ID\n          grp: undefined\n        }),\n        signer\n      };\n    });\n    theClone.methodCalls = new Map(this.methodCalls);\n    return theClone;\n  }\n  /**\n   * Add a transaction to this atomic group.\n   *\n   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is\n   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.\n   */\n  addTransaction(txnAndSigner) {\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length === AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some(v => v !== 0)) {\n      throw new Error('Cannot add a transaction with nonzero group ID');\n    }\n    this.transactions.push(txnAndSigner);\n  }\n  /**\n   * Add a smart contract method call to this atomic group.\n   *\n   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction\n   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid\n   * for the given method.\n   */\n  addMethodCall(_ref2) {\n    let {\n      appID,\n      method,\n      methodArgs,\n      sender,\n      suggestedParams,\n      onComplete,\n      approvalProgram,\n      clearProgram,\n      numGlobalInts,\n      numGlobalByteSlices,\n      numLocalInts,\n      numLocalByteSlices,\n      extraPages,\n      boxes,\n      note,\n      lease,\n      rekeyTo,\n      signer\n    } = _ref2;\n    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {\n      throw new Error('Cannot add transactions when composer status is not BUILDING');\n    }\n    if (this.transactions.length + method.txnCount() > AtomicTransactionComposer.MAX_GROUP_SIZE) {\n      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${AtomicTransactionComposer.MAX_GROUP_SIZE}`);\n    }\n    if (appID === 0) {\n      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {\n        throw new Error('One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices');\n      }\n    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {\n      if (approvalProgram == null || clearProgram == null) {\n        throw new Error('One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram');\n      }\n      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n        throw new Error('One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n      }\n    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {\n      throw new Error('One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages');\n    }\n    if (methodArgs == null) {\n      // eslint-disable-next-line no-param-reassign\n      methodArgs = [];\n    }\n    if (methodArgs.length !== method.args.length) {\n      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);\n    }\n    let basicArgTypes = [];\n    let basicArgValues = [];\n    const txnArgs = [];\n    const refArgTypes = [];\n    const refArgValues = [];\n    const refArgIndexToBasicArgIndex = new Map();\n    // TODO: Box encoding for ABI\n    const boxReferences = !boxes ? [] : boxes;\n    for (let i = 0; i < methodArgs.length; i++) {\n      let argType = method.args[i].type;\n      const argValue = methodArgs[i];\n      if (abiTypeIsTransaction(argType)) {\n        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {\n          throw new Error(`Expected ${argType} transaction for argument at index ${i}`);\n        }\n        if (argValue.txn.group && argValue.txn.group.some(v => v !== 0)) {\n          throw new Error('Cannot add a transaction with nonzero group ID');\n        }\n        txnArgs.push(argValue);\n        continue;\n      }\n      if (isTransactionWithSigner(argValue)) {\n        throw new Error(`Expected non-transaction value for argument at index ${i}`);\n      }\n      if (abiTypeIsReference(argType)) {\n        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);\n        refArgTypes.push(argType);\n        refArgValues.push(argValue);\n        // treat the reference as a uint8 for encoding purposes\n        argType = new ABIUintType(8);\n      }\n      if (typeof argType === 'string') {\n        throw new Error(`Unknown ABI type: ${argType}`);\n      }\n      basicArgTypes.push(argType);\n      basicArgValues.push(argValue);\n    }\n    const resolvedRefIndexes = [];\n    const foreignAccounts = [];\n    const foreignApps = [];\n    const foreignAssets = [];\n    for (let i = 0; i < refArgTypes.length; i++) {\n      const refType = refArgTypes[i];\n      const refValue = refArgValues[i];\n      let resolved = 0;\n      switch (refType) {\n        case ABIReferenceType.account:\n          {\n            const addressType = new ABIAddressType();\n            const address = addressType.decode(addressType.encode(refValue));\n            resolved = populateForeignArray(address, foreignAccounts, sender);\n            break;\n          }\n        case ABIReferenceType.application:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAppID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAppID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for application value, got ${refAppID}`);\n            }\n            resolved = populateForeignArray(Number(refAppID), foreignApps, appID);\n            break;\n          }\n        case ABIReferenceType.asset:\n          {\n            const uint64Type = new ABIUintType(64);\n            const refAssetID = uint64Type.decode(uint64Type.encode(refValue));\n            if (refAssetID > Number.MAX_SAFE_INTEGER) {\n              throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);\n            }\n            resolved = populateForeignArray(Number(refAssetID), foreignAssets);\n            break;\n          }\n        default:\n          throw new Error(`Unknown reference type: ${refType}`);\n      }\n      resolvedRefIndexes.push(resolved);\n    }\n    for (let i = 0; i < resolvedRefIndexes.length; i++) {\n      const basicArgIndex = refArgIndexToBasicArgIndex.get(i);\n      basicArgValues[basicArgIndex] = resolvedRefIndexes[i];\n    }\n    if (basicArgTypes.length > MAX_APP_ARGS - 1) {\n      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);\n      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);\n      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);\n      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);\n      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));\n      basicArgValues.push(lastArgTupleValues);\n    }\n    const appArgsEncoded = [method.getSelector()];\n    for (let i = 0; i < basicArgTypes.length; i++) {\n      appArgsEncoded.push(basicArgTypes[i].encode(basicArgValues[i]));\n    }\n    const appCall = {\n      txn: makeApplicationCallTxnFromObject({\n        from: sender,\n        appIndex: appID,\n        appArgs: appArgsEncoded,\n        accounts: foreignAccounts,\n        foreignApps,\n        foreignAssets,\n        boxes: boxReferences,\n        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,\n        approvalProgram,\n        clearProgram,\n        numGlobalInts,\n        numGlobalByteSlices,\n        numLocalInts,\n        numLocalByteSlices,\n        extraPages,\n        lease,\n        note,\n        rekeyTo,\n        suggestedParams\n      }),\n      signer\n    };\n    this.transactions.push(...txnArgs, appCall);\n    this.methodCalls.set(this.transactions.length - 1, method);\n  }\n  /**\n   * Finalize the transaction group and returned the finalized transactions.\n   *\n   * The composer's status will be at least BUILT after executing this method.\n   */\n  buildGroup() {\n    if (this.status === AtomicTransactionComposerStatus.BUILDING) {\n      if (this.transactions.length === 0) {\n        throw new Error('Cannot build a group with 0 transactions');\n      }\n      if (this.transactions.length > 1) {\n        assignGroupID(this.transactions.map(txnWithSigner => txnWithSigner.txn));\n      }\n      this.status = AtomicTransactionComposerStatus.BUILT;\n    }\n    return this.transactions;\n  }\n  /**\n   * Obtain signatures for each transaction in this group. If signatures have already been obtained,\n   * this method will return cached versions of the signatures.\n   *\n   * The composer's status will be at least SIGNED after executing this method.\n   *\n   * An error will be thrown if signing any of the transactions fails.\n   *\n   * @returns A promise that resolves to an array of signed transactions.\n   */\n  async gatherSignatures() {\n    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {\n      return this.signedTxns;\n    }\n    // retrieve built transactions and verify status is BUILT\n    const txnsWithSigners = this.buildGroup();\n    const txnGroup = txnsWithSigners.map(txnWithSigner => txnWithSigner.txn);\n    const indexesPerSigner = new Map();\n    for (let i = 0; i < txnsWithSigners.length; i++) {\n      const {\n        signer\n      } = txnsWithSigners[i];\n      if (!indexesPerSigner.has(signer)) {\n        indexesPerSigner.set(signer, []);\n      }\n      indexesPerSigner.get(signer).push(i);\n    }\n    const orderedSigners = Array.from(indexesPerSigner);\n    const batchedSigs = await Promise.all(orderedSigners.map(_ref3 => {\n      let [signer, indexes] = _ref3;\n      return signer(txnGroup, indexes);\n    }));\n    const signedTxns = txnsWithSigners.map(() => null);\n    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {\n      const indexes = orderedSigners[signerIndex][1];\n      const sigs = batchedSigs[signerIndex];\n      for (let i = 0; i < indexes.length; i++) {\n        signedTxns[indexes[i]] = sigs[i];\n      }\n    }\n    if (!signedTxns.every(sig => sig != null)) {\n      throw new Error(`Missing signatures. Got ${signedTxns}`);\n    }\n    const txIDs = signedTxns.map((stxn, index) => {\n      try {\n        return decodeSignedTransaction(stxn).txn.txID();\n      } catch (err) {\n        throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);\n      }\n    });\n    this.signedTxns = signedTxns;\n    this.txIDs = txIDs;\n    this.status = AtomicTransactionComposerStatus.SIGNED;\n    return signedTxns;\n  }\n  /**\n   * Send the transaction group to the network, but don't wait for it to be committed to a block. An\n   * error will be thrown if submission fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method. If submission is\n   * successful, this composer's status will update to SUBMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   *\n   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.\n   */\n  async submit(client) {\n    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {\n      throw new Error('Transaction group cannot be resubmitted');\n    }\n    const stxns = await this.gatherSignatures();\n    await client.sendRawTransaction(stxns).do();\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    return this.txIDs;\n  }\n  /**\n   * Send the transaction group to the network and wait until it's committed to a block. An error\n   * will be thrown if submission or execution fails.\n   *\n   * The composer's status must be SUBMITTED or lower before calling this method, since execution is\n   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.\n   * If the execution is also successful, this composer's status will update to COMMITTED.\n   *\n   * Note: a group can only be submitted again if it fails.\n   *\n   * @param client - An Algodv2 client\n   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation\n   *\n   * @returns A promise that, upon success, resolves to an object containing the confirmed round for\n   *   this transaction, the txIDs of the submitted transactions, and an array of results containing\n   *   one element for each method call transaction in this group.\n   */\n  async execute(client, waitRounds) {\n    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {\n      throw new Error('Transaction group has already been executed successfully');\n    }\n    const txIDs = await this.submit(client);\n    this.status = AtomicTransactionComposerStatus.SUBMITTED;\n    const firstMethodCallIndex = this.transactions.findIndex((_, index) => this.methodCalls.has(index));\n    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;\n    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);\n    this.status = AtomicTransactionComposerStatus.COMMITTED;\n    const confirmedRound = confirmedTxnInfo['confirmed-round'];\n    const methodResults = [];\n    for (const [txnIndex, method] of this.methodCalls) {\n      const txID = txIDs[txnIndex];\n      const methodResult = {\n        txID,\n        rawReturnValue: new Uint8Array(),\n        method\n      };\n      try {\n        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo :\n        // eslint-disable-next-line no-await-in-loop\n        await client.pendingTransactionInformation(txID).do();\n        methodResult.txInfo = pendingInfo;\n        if (method.returns.type !== 'void') {\n          const logs = pendingInfo.logs || [];\n          if (logs.length === 0) {\n            throw new Error('App call transaction did not log a return value');\n          }\n          const lastLog = Buffer.from(logs[logs.length - 1], 'base64');\n          if (lastLog.byteLength < 4 || !lastLog.slice(0, 4).equals(RETURN_PREFIX)) {\n            throw new Error('App call transaction did not log a return value');\n          }\n          methodResult.rawReturnValue = new Uint8Array(lastLog.slice(4));\n          methodResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);\n        }\n      } catch (err) {\n        methodResult.decodeError = err;\n      }\n      methodResults.push(methodResult);\n    }\n    return {\n      confirmedRound,\n      txIDs,\n      methodResults\n    };\n  }\n}\n/** The maximum size of an atomic transaction group. */\nAtomicTransactionComposer.MAX_GROUP_SIZE = 16;","map":{"version":3,"mappings":"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","names":["ABITupleType","ABIUintType","ABIAddressType","ABIReferenceType","abiTypeIsTransaction","abiCheckTransactionType","abiTypeIsReference","Transaction","decodeSignedTransaction","makeApplicationCallTxnFromObject","assignGroupID","waitForConfirmation","isTransactionWithSigner","OnApplicationComplete","RETURN_PREFIX","Buffer","from","MAX_APP_ARGS","AtomicTransactionComposerStatus","populateForeignArray","valueToAdd","array","zeroValue","offset","i","length","push","AtomicTransactionComposer","constructor","BUILDING","Map","getStatus","status","count","transactions","clone","theClone","map","txn","signer","from_obj_for_encoding","get_obj_for_encoding","grp","undefined","methodCalls","addTransaction","txnAndSigner","Error","MAX_GROUP_SIZE","group","some","v","addMethodCall","appID","method","methodArgs","sender","suggestedParams","onComplete","approvalProgram","clearProgram","numGlobalInts","numGlobalByteSlices","numLocalInts","numLocalByteSlices","extraPages","boxes","note","lease","rekeyTo","txnCount","UpdateApplicationOC","args","basicArgTypes","basicArgValues","txnArgs","refArgTypes","refArgValues","refArgIndexToBasicArgIndex","boxReferences","argType","type","argValue","set","resolvedRefIndexes","foreignAccounts","foreignApps","foreignAssets","refType","refValue","resolved","account","addressType","address","decode","encode","application","uint64Type","refAppID","Number","MAX_SAFE_INTEGER","asset","refAssetID","basicArgIndex","get","lastArgTupleTypes","slice","lastArgTupleValues","appArgsEncoded","getSelector","appCall","appIndex","appArgs","accounts","NoOpOC","buildGroup","txnWithSigner","BUILT","gatherSignatures","SIGNED","signedTxns","txnsWithSigners","txnGroup","indexesPerSigner","has","orderedSigners","Array","batchedSigs","Promise","all","indexes","signerIndex","sigs","every","sig","txIDs","stxn","index","txID","err","submit","client","SUBMITTED","stxns","sendRawTransaction","do","execute","waitRounds","COMMITTED","firstMethodCallIndex","findIndex","_","indexToWaitFor","confirmedTxnInfo","confirmedRound","methodResults","txnIndex","methodResult","rawReturnValue","Uint8Array","pendingInfo","pendingTransactionInformation","txInfo","returns","logs","lastLog","byteLength","equals","returnValue","decodeError"],"sourceRoot":"","sources":["../../src/composer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}