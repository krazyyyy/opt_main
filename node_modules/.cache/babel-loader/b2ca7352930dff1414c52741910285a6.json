{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as utils from '../utils/utils';\nimport { URLTokenBaseHTTPClient } from './urlTokenBaseHTTPClient';\n/**\n * Remove falsy values or values with a length of 0 from an object.\n */\nfunction removeFalsyOrEmpty(obj) {\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      // eslint-disable-next-line no-param-reassign\n      if (!obj[key] || obj[key].length === 0) delete obj[key];\n    }\n  }\n  return obj;\n}\n/**\n * Create a new object with lower-case keys\n * See https://codereview.stackexchange.com/a/162418\n * Used to ensure all headers are lower-case and to work more easily with them\n */\nfunction tolowerCaseKeys(o) {\n  /* eslint-disable no-param-reassign,no-return-assign,no-sequences */\n  return Object.keys(o).reduce((c, k) => (c[k.toLowerCase()] = o[k], c), {});\n  /* eslint-enable no-param-reassign,no-return-assign,no-sequences */\n}\n/**\n * getAcceptFormat returns the correct Accept header depending on the\n * requested format.\n */\nfunction getAcceptFormat(query) {\n  if (query !== undefined && Object.prototype.hasOwnProperty.call(query, 'format')) {\n    switch (query.format) {\n      case 'msgpack':\n        return 'application/msgpack';\n      case 'json':\n      default:\n        return 'application/json';\n    }\n  } else return 'application/json';\n}\n/**\n * HTTPClient is a wrapper around a BaseHTTPClient\n * It takes care of setting the proper \"Accept\" header and of\n * decoding the JSON outputs.\n */\nexport default class HTTPClient {\n  constructor(bcOrTokenHeader, baseServer, port) {\n    let defaultHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    if (baseServer !== undefined) {\n      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);\n    } else {\n      this.bc = bcOrTokenHeader;\n    }\n  }\n  /**\n   * Parse JSON using either the built-in JSON.parse or utils.parseJSON\n   * depending on whether jsonOptions are provided or not\n   *\n   * @param text - JSON data\n   * @param status - Status of the response (used in case parseJSON fails)\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   */\n  static parseJSON(text, status) {\n    let jsonOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    try {\n      if (Object.keys(jsonOptions).length === 0) {\n        return text && JSON.parse(text);\n      }\n      return text && utils.parseJSON(text, jsonOptions);\n    } catch (err_) {\n      const err = err_;\n      // return the raw response if the response parsing fails\n      err.rawResponse = text || null;\n      // return the http status code if the response parsing fails\n      err.statusCode = status;\n      throw err;\n    }\n  }\n  /**\n   * Serialize the data according to the requestHeaders\n   * Assumes that requestHeaders contain a key \"content-type\"\n   * If the content-type is \"application/json\", data is JSON serialized\n   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array\n   * or an Uint8Array\n   * @private\n   */\n  static serializeData(data, requestHeaders) {\n    if (!data) {\n      return new Uint8Array(0); // empty Uint8Array\n    }\n\n    if (requestHeaders['content-type'] === 'application/json') {\n      return new Uint8Array(Buffer.from(JSON.stringify(data)));\n    }\n    if (typeof data === 'string') {\n      return new Uint8Array(Buffer.from(data));\n    }\n    if (data instanceof Uint8Array) {\n      return data;\n    }\n    throw new Error('provided data is neither a string nor a Uint8Array and content-type is not application/json');\n  }\n  /**\n   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse\n   * Parse the body in\n   * Modifies in place res and return the result\n   */\n  static prepareResponse(res, format, parseBody) {\n    let jsonOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let {\n      body\n    } = res;\n    let text;\n    if (format !== 'application/msgpack') {\n      text = body && Buffer.from(body).toString() || '';\n    }\n    if (parseBody && format === 'application/json') {\n      body = HTTPClient.parseJSON(text, res.status, jsonOptions);\n    }\n    return {\n      ...res,\n      body,\n      text,\n      ok: Math.trunc(res.status / 100) === 2\n    };\n  }\n  /**\n   * Prepare an error with a response\n   * (the type of errors BaseHTTPClient are supposed to throw)\n   * by adding the status and preparing the internal response\n   * @private\n   */\n  static prepareResponseError(err) {\n    if (err.response) {\n      // eslint-disable-next-line no-param-reassign\n      err.response = HTTPClient.prepareResponse(err.response, 'application/json', true);\n      // eslint-disable-next-line no-param-reassign\n      err.status = err.response.status;\n    }\n    return err;\n  }\n  /**\n   * Send a GET request.\n   * @param relativePath - The path of the request.\n   * @param query - An object containing the query parameters of the request.\n   * @param requestHeaders - An object containing additional request headers to use.\n   * @param jsonOptions - Options object to use to decode JSON responses. See\n   *   utils.parseJSON for the options available.\n   * @param parseBody - An optional boolean indicating whether the response body should be parsed\n   *   or not.\n   * @returns Response object.\n   */\n  async get(relativePath, query) {\n    let requestHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let jsonOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    let parseBody = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const format = getAcceptFormat(query);\n    const fullHeaders = {\n      ...requestHeaders,\n      accept: format\n    };\n    try {\n      const res = await this.bc.get(relativePath, removeFalsyOrEmpty(query), fullHeaders);\n      return HTTPClient.prepareResponse(res, format, parseBody, jsonOptions);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\n   * Send a POST request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   */\n  async post(relativePath, data) {\n    let requestHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let query = arguments.length > 3 ? arguments[3] : undefined;\n    let parseBody = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders)\n    };\n    try {\n      const res = await this.bc.post(relativePath, HTTPClient.serializeData(data, fullHeaders), query, fullHeaders);\n      return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n    } catch (err) {\n      throw HTTPClient.prepareResponseError(err);\n    }\n  }\n  /**\n   * Send a DELETE request.\n   * If no content-type present, adds the header \"content-type: application/json\"\n   * and data is serialized in JSON (if not empty)\n   */\n  async delete(relativePath, data) {\n    let requestHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let parseBody = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    const fullHeaders = {\n      'content-type': 'application/json',\n      ...tolowerCaseKeys(requestHeaders)\n    };\n    const res = await this.bc.delete(relativePath, HTTPClient.serializeData(data, fullHeaders), undefined, fullHeaders);\n    return HTTPClient.prepareResponse(res, 'application/json', parseBody);\n  }\n}","map":{"version":3,"mappings":"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","names":["Buffer","utils","URLTokenBaseHTTPClient","removeFalsyOrEmpty","obj","key","Object","prototype","hasOwnProperty","call","length","tolowerCaseKeys","o","keys","reduce","c","k","toLowerCase","getAcceptFormat","query","undefined","format","HTTPClient","constructor","bcOrTokenHeader","baseServer","port","defaultHeaders","bc","parseJSON","text","status","jsonOptions","JSON","parse","err_","err","rawResponse","statusCode","serializeData","data","requestHeaders","Uint8Array","from","stringify","Error","prepareResponse","res","parseBody","body","toString","ok","Math","trunc","prepareResponseError","response","get","relativePath","fullHeaders","accept","post","delete"],"sourceRoot":"","sources":["../../../src/client/client.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}