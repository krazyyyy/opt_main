{"ast":null,"code":"import { types } from '@algo-builder/web';\nimport { AppActions, LocalStateKeys } from '../constants/constants.js';\nimport { indexerClient } from './algob.config.js';\nconst {\n  tryExecuteTx,\n  chunkArray,\n  readAppLocalState,\n  OptAppID,\n  getCustodialWallets\n} = require('./common.js');\nconst {\n  getApplicationAddress\n} = require('algosdk');\n\n/**\n * Returns a list of custodial wallet addresses whose balance is above 10000 ALGO.\n * Inspiration: to take back the rewards gained by wallets during governance.\n * + Each account must be whitelisted and rekeyed to the optimum app.\n * + Each account must be registered and has voted to governance.\n * + We use the indexer to query all accounts opted in & rekeyed to app\n */\nasync function getCustodialWalletsWithExtraBal(network, adminAddr) {\n  const accounts = await getCustodialWallets(OptAppID(network), {\n    extraBalance: true\n  }, network, adminAddr, 200);\n  const custodialWallets = [],\n    amtsToWithdraw = [];\n  for (const acc of accounts) {\n    // check if there is \"extra balance\" in the custodial wallet\n    // note: taking into account that 0.5 ALGO must be present in the wallet\n    // to maintain min balance requirment and pay transaction fees\n    const bal = Math.floor(acc.amount - (100e6 + 0.5e6));\n\n    // push the address in address array, \"amount we can withdraw\" into another array.\n    // so that we can split them individially into chunks of 4 later during withdraw.\n    if (bal > 0) {\n      custodialWallets.push(acc.address);\n      amtsToWithdraw.push(bal);\n    }\n  }\n  return [custodialWallets, amtsToWithdraw];\n}\n\n/**\n * Find and withdraw from each custodial wallet(s) 10000 ALGO's. Returns if enough wallets\n * are not available to withdraw from (which shouldn't happen).\n * NOTE: withdraw amount is in microAlgos\n */\nasync function withdrawRewardsFromCustodialWallets(web, custodialWallets, amtsToWithdraw, adminAddr, network) {\n  // split whole custodial wallets array & amts array into chunks of 4\n  // as max 4 accounts can be passed in a tx group.\n  const txAccountArrays = chunkArray(custodialWallets, 4); // pass in tx.accounts\n  const txAppArgArrays = chunkArray(amtsToWithdraw, 4); // pass in tx.application_args\n\n  // let's construct the transactions\n  const txArray = [];\n  for (let i = 0, j = 0; i < custodialWallets.length; i += 4, j++) {\n    // in each iteration we're withdrawing rewards from 4 wallets\n    txArray.push({\n      type: types.TransactionType.CallApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: adminAddr,\n      appID: OptAppID(network),\n      payFlags: {\n        totalFee: 1000 + 1000 * txAccountArrays[j].length\n      },\n      accounts: txAccountArrays[j],\n      appArgs: [AppActions.WITHDRAW_REWARDS, ...txAppArgArrays[j].map(arg => `int:${arg}`)]\n    });\n  }\n\n  // finally assemble transactions into groups of 16. Submit each group to network\n  // TODO: check the hit & miss of indexer, apprantley it's giving the updated result in\n  // the \"next\" query. Maybe is this only because of dev mode\n  const txGroups = chunkArray(txArray, 16);\n  for (const grp of txGroups) {\n    await tryExecuteTx(web, grp);\n  }\n}\n\n/**\n * 1. Get custodial wallets with extra bal (amount allocated as rewards by the governance)\n * 2. Trigger the smart contract to withdraw these rewards from the custodial wallets back into the contract\n */\nexport async function withdrawRewards(web, network, adminAddr) {\n  // withraw ALGO's from custodial wallets \"before\" withdraw. Can be called by anyone\n  const [custodialWallets, amtsToWithdraw] = await getCustodialWalletsWithExtraBal(network, adminAddr);\n  await withdrawRewardsFromCustodialWallets(web, custodialWallets, amtsToWithdraw, adminAddr, network);\n}","map":{"version":3,"names":["types","AppActions","LocalStateKeys","indexerClient","tryExecuteTx","chunkArray","readAppLocalState","OptAppID","getCustodialWallets","require","getApplicationAddress","getCustodialWalletsWithExtraBal","network","adminAddr","accounts","extraBalance","custodialWallets","amtsToWithdraw","acc","bal","Math","floor","amount","push","address","withdrawRewardsFromCustodialWallets","web","txAccountArrays","txAppArgArrays","txArray","i","j","length","type","TransactionType","CallApp","sign","SignType","SecretKey","fromAccountAddr","appID","payFlags","totalFee","appArgs","WITHDRAW_REWARDS","map","arg","txGroups","grp","withdrawRewards"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/withdraw_rewards.js"],"sourcesContent":["import { types } from '@algo-builder/web';\nimport { AppActions, LocalStateKeys } from '../constants/constants.js';\nimport { indexerClient } from './algob.config.js';\nconst {\n    tryExecuteTx,\n    chunkArray,\n    readAppLocalState,\n    OptAppID,\n    getCustodialWallets\n} = require('./common.js');\nconst { getApplicationAddress } = require('algosdk');\n\n/**\n * Returns a list of custodial wallet addresses whose balance is above 10000 ALGO.\n * Inspiration: to take back the rewards gained by wallets during governance.\n * + Each account must be whitelisted and rekeyed to the optimum app.\n * + Each account must be registered and has voted to governance.\n * + We use the indexer to query all accounts opted in & rekeyed to app\n */\nasync function getCustodialWalletsWithExtraBal(network, adminAddr) {\n    const accounts = await getCustodialWallets(\n        OptAppID(network),\n        { extraBalance: true },\n        network,\n        adminAddr,\n        200\n    );\n\n    const custodialWallets = [],\n        amtsToWithdraw = [];\n    for (const acc of accounts) {\n        // check if there is \"extra balance\" in the custodial wallet\n        // note: taking into account that 0.5 ALGO must be present in the wallet\n        // to maintain min balance requirment and pay transaction fees\n        const bal = Math.floor(acc.amount - (100e6 + 0.5e6));\n\n        // push the address in address array, \"amount we can withdraw\" into another array.\n        // so that we can split them individially into chunks of 4 later during withdraw.\n        if (bal > 0) {\n            custodialWallets.push(acc.address);\n            amtsToWithdraw.push(bal);\n        }\n    }\n\n    return [custodialWallets, amtsToWithdraw];\n}\n\n/**\n * Find and withdraw from each custodial wallet(s) 10000 ALGO's. Returns if enough wallets\n * are not available to withdraw from (which shouldn't happen).\n * NOTE: withdraw amount is in microAlgos\n */\nasync function withdrawRewardsFromCustodialWallets(\n    web,\n    custodialWallets,\n    amtsToWithdraw,\n    adminAddr,\n    network\n) {\n    // split whole custodial wallets array & amts array into chunks of 4\n    // as max 4 accounts can be passed in a tx group.\n    const txAccountArrays = chunkArray(custodialWallets, 4); // pass in tx.accounts\n    const txAppArgArrays = chunkArray(amtsToWithdraw, 4); // pass in tx.application_args\n\n    // let's construct the transactions\n    const txArray = [];\n    for (let i = 0, j = 0; i < custodialWallets.length; i += 4, j++) {\n        // in each iteration we're withdrawing rewards from 4 wallets\n        txArray.push({\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: adminAddr,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 1000 + 1000 * txAccountArrays[j].length },\n            accounts: txAccountArrays[j],\n            appArgs: [\n                AppActions.WITHDRAW_REWARDS,\n                ...txAppArgArrays[j].map((arg) => `int:${arg}`)\n            ]\n        });\n    }\n\n    // finally assemble transactions into groups of 16. Submit each group to network\n    // TODO: check the hit & miss of indexer, apprantley it's giving the updated result in\n    // the \"next\" query. Maybe is this only because of dev mode\n    const txGroups = chunkArray(txArray, 16);\n    for (const grp of txGroups) {\n        await tryExecuteTx(web, grp);\n    }\n}\n\n/**\n * 1. Get custodial wallets with extra bal (amount allocated as rewards by the governance)\n * 2. Trigger the smart contract to withdraw these rewards from the custodial wallets back into the contract\n */\nexport async function withdrawRewards(web, network, adminAddr) {\n    // withraw ALGO's from custodial wallets \"before\" withdraw. Can be called by anyone\n    const [custodialWallets, amtsToWithdraw] =\n        await getCustodialWalletsWithExtraBal(network, adminAddr);\n\n    await withdrawRewardsFromCustodialWallets(\n        web,\n        custodialWallets,\n        amtsToWithdraw,\n        adminAddr,\n        network\n    );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}