{"ast":null,"code":"class Messenger {\n  /**\n   * @callback onMessage\n   * @param {error} err\n   * @param {Object} result\n   */\n\n  /**\n   * @description Callback function to send response to the window source of the message\n   * @callback sendResponse\n   * @param {Object} response Message response\n   * @returns {void}\n   */\n\n  /**\n   * @description Callback function to manage message received from the channel\n      * @callback onMessageCallback\n      * @param {Object} json\n   * @param {Window} source\n      * @param {sendResponse} cb\n   * @param {Messenger} bridge\n   * @returns {void}\n      */\n\n  /**\n   * @description Send message options\n   * @typedef {Object} sendMessageOptions\n   * @property {boolean} waitForReply Wait for a reply from the recipient\n   * @property {string} origin Override Window.origin\n   * @property {number} timeout Timeout to wait for reply message, default 4000 msec\n   */\n\n  /**\n      * @param {string} channelName  Channel Name\n      * @param {onMessageCallback} [onMessageCallback] Callback function\n      */\n\n  constructor(channelName, onMessageCallback) {\n    this.channelName = channelName;\n    this.onMessage = onMessageCallback;\n    this._installListener();\n\n    /**\n     * @access private\n     * @typedef {Object.<string, onMessage>} RequestObject Request objects\n     * @type {RequestObject} _requests Mapping of request ids to callbacks\n     */\n    this._requests = new Map();\n\n    /**\n     * @access private\n     * @type {number} Next request id\n     */\n    this._nextId = 0;\n\n    /**\n     * @access private\n     * @type {number} Time to wait for the message response\n     */\n    this._defaultTimeout = 4000;\n  }\n\n  /**\n   * @access private\n   */\n\n  _installListener() {\n    const that = this;\n\n    /**\n     * @access private\n     * @param {Window} this\n     * @param {MessageEvent} event\n     */\n\n    this._listener = function (event) {\n      // Ignore invalid messages or those after the client has closed\n      if (!event.data || typeof event.data !== 'string') {\n        return;\n      }\n      let json;\n      try {\n        json = JSON.parse(event.data);\n        if (!json.channel || json.channel !== that.channelName) {\n          return;\n        }\n        if (typeof json.message !== 'object') {\n          return;\n        }\n      } catch (err) {\n        // Ignore malformed messages or not targetting us\n        return;\n      }\n\n      // Add request callback\n      if (typeof json.replyId !== 'undefined') {\n        if (typeof json.replyId !== 'number' || json.replyId % 1 !== 0) {\n          return;\n        }\n\n        // If we have a message waiting for a reply, process it, else ignore\n        const req = that._requests.get(json.replyId);\n        if (req) {\n          // Ignore if the message comes from somewhere else\n          if (event.origin !== req.targetOrigin) {\n            return;\n          }\n          clearTimeout(req.timeout);\n          that._requests.delete(json.replyId);\n          req.resolve(json.message);\n        }\n      } else {\n        if (typeof json.id !== 'number' || json.id % 1 !== 0 || !that.onMessage) {\n          return;\n        }\n\n        // We received a message\n        const channel = that.channelName;\n        const replyId = json.id;\n        const origin = event.origin;\n        const replyMessage = function (message) {\n          const request = {\n            channel,\n            replyId,\n            message: message\n          };\n          event.source.postMessage(JSON.stringify(request), origin);\n        };\n        that.onMessage(json.message, event.origin, event.source, replyMessage, that);\n      }\n    };\n    window.addEventListener(\"message\", this._listener);\n  }\n\n  /**\n   * @access public\n   * @description Send a message to another window\n   * @param {Window} targetWindow Target Window\n   * @param {Object} message Object Message\n   * @param {string} origin Target origin\n   * @param {sendMessageOptions} [options] Object Message\n   * @returns {Promise<any>} Returns\n   */\n  sendMessage(targetWindow, message, origin, options) {\n    let targetOrigin;\n    try {\n      targetOrigin = new URL(origin).origin;\n    } catch (e) {\n      throw new Error('Invalid origin URL');\n    }\n\n    // Prepare message\n    const request = {\n      channel: this.channelName,\n      id: this.getNextId(),\n      message: message\n    };\n    if (options && options.waitForReply) {\n      const that = this;\n      return new Promise(function (resolve, reject) {\n        // Set a timeout if a response is not received\n        const timeout = setTimeout(function () {\n          const req = that._requests.get(request.id);\n          if (req) {\n            that._requests.delete(request.id);\n            reject(new Error('Timeout expired for the message response'));\n          }\n        }, options && options.timeout ? options.timeout : that._defaultTimeout);\n        that._requests.set(request.id, {\n          timeout,\n          resolve,\n          targetOrigin\n        });\n        targetWindow.postMessage(JSON.stringify(request), targetOrigin);\n      });\n    }\n    targetWindow.postMessage(JSON.stringify(request), targetOrigin);\n  }\n\n  /**\n   * @access public\n   * @description Close client connection\n   */\n\n  close() {\n    window.removeEventListener('message', this._listener);\n    this._listener = null;\n    delete this._requests;\n  }\n\n  /**\n   * @access private\n   */\n\n  getNextId() {\n    this._nextId += 1;\n    return this._nextId;\n  }\n}\nmodule.exports = Messenger;","map":{"version":3,"names":["Messenger","constructor","channelName","onMessageCallback","onMessage","_installListener","_requests","Map","_nextId","_defaultTimeout","that","_listener","event","data","json","JSON","parse","channel","message","err","replyId","req","get","origin","targetOrigin","clearTimeout","timeout","delete","resolve","id","replyMessage","request","source","postMessage","stringify","window","addEventListener","sendMessage","targetWindow","options","URL","e","Error","getNextId","waitForReply","Promise","reject","setTimeout","set","close","removeEventListener","module","exports"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/node_modules/@randlabs/communication-bridge/lib/messenger.js"],"sourcesContent":["class Messenger {\n\n\t/**\n\t * @callback onMessage\n\t * @param {error} err\n\t * @param {Object} result\n\t */\n\n\t/**\n\t * @description Callback function to send response to the window source of the message\n\t * @callback sendResponse\n\t * @param {Object} response Message response\n\t * @returns {void}\n\t */\n\n\t/**\n\t * @description Callback function to manage message received from the channel\n     * @callback onMessageCallback\n     * @param {Object} json\n\t * @param {Window} source\n     * @param {sendResponse} cb\n\t * @param {Messenger} bridge\n\t * @returns {void}\n     */\n\n\t/**\n\t * @description Send message options\n\t * @typedef {Object} sendMessageOptions\n\t * @property {boolean} waitForReply Wait for a reply from the recipient\n\t * @property {string} origin Override Window.origin\n\t * @property {number} timeout Timeout to wait for reply message, default 4000 msec\n\t */\n\n\t/**\n     * @param {string} channelName  Channel Name\n     * @param {onMessageCallback} [onMessageCallback] Callback function\n     */\n\n\tconstructor(channelName, onMessageCallback) {\n\t\tthis.channelName = channelName;\n\t\tthis.onMessage = onMessageCallback;\n\n\t\tthis._installListener();\n\n\t\t/**\n\t\t * @access private\n\t\t * @typedef {Object.<string, onMessage>} RequestObject Request objects\n\t\t * @type {RequestObject} _requests Mapping of request ids to callbacks\n\t\t */\n\t\tthis._requests = new Map();\n\n\t\t/**\n\t\t * @access private\n\t\t * @type {number} Next request id\n\t\t */\n\t\tthis._nextId = 0;\n\n\t\t/**\n\t\t * @access private\n\t\t * @type {number} Time to wait for the message response\n\t\t */\n\t\tthis._defaultTimeout = 4000;\n\t}\n\n\t/**\n\t * @access private\n\t */\n\n\t_installListener() {\n\t\tconst that = this;\n\n\t\t/**\n\t\t * @access private\n\t\t * @param {Window} this\n\t\t * @param {MessageEvent} event\n\t\t */\n\n\t\tthis._listener = function (event) {\n\t\t\t// Ignore invalid messages or those after the client has closed\n\t\t\tif (!event.data || typeof event.data !== 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet json;\n\n\t\t\ttry {\n\t\t\t\tjson = JSON.parse(event.data);\n\t\t\t\tif (!json.channel || json.channel !== that.channelName) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (typeof json.message !== 'object') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (err) {\n\t\t\t\t // Ignore malformed messages or not targetting us\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Add request callback\n\t\t\tif (typeof json.replyId !== 'undefined') {\n\n\t\t\t\tif (typeof json.replyId !== 'number' || (json.replyId % 1) !== 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// If we have a message waiting for a reply, process it, else ignore\n\t\t\t\tconst req = that._requests.get(json.replyId);\n\t\t\t\tif (req) {\n\t\t\t\t\t// Ignore if the message comes from somewhere else\n\t\t\t\t\tif (event.origin !== req.targetOrigin) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tclearTimeout(req.timeout);\n\n\t\t\t\t\tthat._requests.delete(json.replyId);\n\n\t\t\t\t\treq.resolve(json.message);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (typeof json.id !== 'number' || (json.id % 1) !== 0 || !that.onMessage) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// We received a message\n\t\t\t\tconst channel = that.channelName;\n\t\t\t\tconst replyId = json.id;\n\t\t\t\tconst origin = event.origin;\n\n\t\t\t\tconst replyMessage = function (message) {\n\t\t\t\t\tconst request = {\n\t\t\t\t\t\tchannel,\n\t\t\t\t\t\treplyId,\n\t\t\t\t\t\tmessage: message,\n\t\t\t\t\t};\n\n\t\t\t\t\tevent.source.postMessage(\n\t\t\t\t\t\tJSON.stringify(request),\n\t\t\t\t\t\torigin\n\t\t\t\t\t);\n\t\t\t\t};\n\n\t\t\t\tthat.onMessage(json.message, event.origin, event.source, replyMessage, that);\n\t\t\t}\n\t\t};\n\n\t\twindow.addEventListener(\"message\", this._listener);\n\t}\n\n\t/**\n\t * @access public\n\t * @description Send a message to another window\n\t * @param {Window} targetWindow Target Window\n\t * @param {Object} message Object Message\n\t * @param {string} origin Target origin\n\t * @param {sendMessageOptions} [options] Object Message\n\t * @returns {Promise<any>} Returns\n\t */\n\tsendMessage(targetWindow, message, origin, options) {\n\t\tlet targetOrigin;\n\t\ttry {\n\t\t\ttargetOrigin = new URL(origin).origin;\n\t\t}\n\t\tcatch (e) {\n\t\t\tthrow new Error('Invalid origin URL');\n\t\t}\n\n\t\t// Prepare message\n\t\tconst request = {\n\t\t\tchannel: this.channelName,\n\t\t\tid: this.getNextId(),\n\t\t\tmessage: message,\n\t\t};\n\n\t\tif (options && options.waitForReply) {\n\t\t\tconst that = this;\n\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t// Set a timeout if a response is not received\n\t\t\t\tconst timeout = setTimeout(function() {\n\t\t\t\t\tconst req = that._requests.get(request.id);\n\t\t\t\t\tif (req) {\n\t\t\t\t\t\tthat._requests.delete(request.id);\n\n\t\t\t\t\t\treject(new Error('Timeout expired for the message response'));\n\t\t\t\t\t}\n\t\t\t\t}, options && options.timeout ? options.timeout : that._defaultTimeout);\n\n\t\t\t\tthat._requests.set(request.id, {\n\t\t\t\t\ttimeout,\n\t\t\t\t\tresolve,\n\t\t\t\t\ttargetOrigin,\n\t\t\t\t});\n\n\t\t\t\ttargetWindow.postMessage(\n\t\t\t\t\tJSON.stringify(request),\n\t\t\t\t\ttargetOrigin\n\t\t\t\t);\n\t\t\t});\n\n\t\t}\n\t\ttargetWindow.postMessage(\n\t\t\tJSON.stringify(request),\n\t\t\ttargetOrigin\n\t\t);\n\t}\n\n\t/**\n\t * @access public\n\t * @description Close client connection\n\t */\n\n\tclose() {\n\t\twindow.removeEventListener('message', this._listener);\n\t\tthis._listener = null;\n\t\tdelete this._requests;\n\t}\n\n\t/**\n\t * @access private\n\t */\n\n\tgetNextId() {\n\t\tthis._nextId += 1;\n\t\treturn this._nextId;\n\t}\n}\n\nmodule.exports = Messenger;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}