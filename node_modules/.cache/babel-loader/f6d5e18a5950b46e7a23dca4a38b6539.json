{"ast":null,"code":"import { types } from '@algo-builder/web';\nimport { AppActions, LocalStateKeys } from '../constants/constants.js';\nimport { algodClient, indexerClient } from './algob.config.js';\nconst {\n  tryExecuteTx,\n  chunkArray,\n  readAppLocalState,\n  OptAppID,\n  executeRekeyedTx,\n  getCustodialWallets\n} = require('./common.js');\nconst {\n  getApplicationAddress,\n  default: algosdk\n} = require('algosdk');\n\n/**\n * Returns a list of custodial wallet addresses whose balance is above 10000 ALGO.\n * Inspiration: to take back the rewards gained by wallets during governance.\n * + Each account must be whitelisted and rekeyed to the optimum app.\n * + Each account must be registered and has voted to governance.\n * + We use the indexer to query all accounts opted in & rekeyed to app\n */\nasync function getCustodialWalletsToClose(network, adminAddr) {\n  const accounts = await getCustodialWallets(OptAppID(network), undefined, network, adminAddr, 200);\n  const custodialWallets = [];\n  for (const acc of accounts) {\n    // check if there is \"residual balance\" in the custodial wallet (< 5 ALGO)\n    const bal = Math.floor(acc.amount);\n    if (bal < 5e6) {\n      custodialWallets.push(acc.address);\n    }\n  }\n  return custodialWallets;\n}\n\n/**\n * Find and withdraw from each custodial wallet(s) 10000 ALGO's. Returns if enough wallets\n * are not available to withdraw from (which shouldn't happen).\n * NOTE: withdraw amount is in microAlgos\n */\nasync function _closeCustodialWallets(web, custodialWallets, adminAddr, network, selectedWalletType) {\n  // split whole custodial wallets array into chunks of 4\n  // as max 4 accounts can be passed in a tx group.\n  const txAccountArrays = chunkArray(custodialWallets, 4); // pass in tx.accounts\n\n  // 1. rekey all custodial wallets from contract -> admin\n  const rekeyTxArray = [];\n  for (let i = 0, j = 0; i < custodialWallets.length; i += 4, j++) {\n    // in each iteration we're withdrawing rewards from 4 wallets\n    rekeyTxArray.push({\n      type: types.TransactionType.CallApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: adminAddr,\n      appID: OptAppID(network),\n      payFlags: {\n        totalFee: 1000 + 1000 * txAccountArrays[j].length\n      },\n      accounts: txAccountArrays[j],\n      appArgs: [AppActions.CLOSE_CUSTODIAL_WALLETS]\n    });\n  }\n\n  // finally assemble transactions into groups of 16. Submit each group to network\n  const rekeyTxGroups = chunkArray(rekeyTxArray, 16);\n  for (const grp of rekeyTxGroups) {\n    await tryExecuteTx(web, grp);\n  }\n  const client = algodClient(network);\n\n  // 2. clear wallet state (clear tx appl call)\n  const clearTxArray = [];\n  for (let i = 0; i < custodialWallets.length; i++) {\n    const suggestedParams = await client.getTransactionParams().do();\n    suggestedParams.flatFee = true;\n    suggestedParams.fee = 1000;\n\n    // in each iteration we're withdrawing rewards from 4 wallets\n    clearTxArray.push(algosdk.makeApplicationClearStateTxnFromObject({\n      from: custodialWallets[i],\n      suggestedParams: suggestedParams,\n      appIndex: OptAppID(network)\n    }));\n  }\n  const clearTxGroups = chunkArray(clearTxArray, 16);\n  for (const grp of clearTxGroups) {\n    await executeRekeyedTx(web, grp, adminAddr, selectedWalletType);\n  }\n\n  // 3. close the wallet\n  const closeTxnArray = [];\n  for (let i = 0; i < custodialWallets.length; i++) {\n    const suggestedParams = await client.getTransactionParams().do();\n    suggestedParams.flatFee = true;\n    suggestedParams.fee = 1000;\n    closeTxnArray.push(algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n      from: custodialWallets[i],\n      suggestedParams: suggestedParams,\n      closeRemainderTo: adminAddr,\n      amount: 0,\n      to: custodialWallets[i]\n    }));\n  }\n  const closeTxGroups = chunkArray(closeTxnArray, 16);\n  for (const grp of closeTxGroups) {\n    await executeRekeyedTx(web, grp, adminAddr, selectedWalletType);\n  }\n}\n\n/**\n * 1. Get custodial wallets with extra bal ( < 5 ALGO )\n * 2. Trigger the smart contract to completely withdraw these algos from the custodial wallets back into the contract\n */\nexport async function closeCustodialWallets(web, network, adminAddr, selectedWalletType) {\n  const custodialWallets = await getCustodialWalletsToClose(network, adminAddr);\n  await _closeCustodialWallets(web, custodialWallets, adminAddr, network, selectedWalletType);\n}","map":{"version":3,"names":["types","AppActions","LocalStateKeys","algodClient","indexerClient","tryExecuteTx","chunkArray","readAppLocalState","OptAppID","executeRekeyedTx","getCustodialWallets","require","getApplicationAddress","default","algosdk","getCustodialWalletsToClose","network","adminAddr","accounts","undefined","custodialWallets","acc","bal","Math","floor","amount","push","address","_closeCustodialWallets","web","selectedWalletType","txAccountArrays","rekeyTxArray","i","j","length","type","TransactionType","CallApp","sign","SignType","SecretKey","fromAccountAddr","appID","payFlags","totalFee","appArgs","CLOSE_CUSTODIAL_WALLETS","rekeyTxGroups","grp","client","clearTxArray","suggestedParams","getTransactionParams","do","flatFee","fee","makeApplicationClearStateTxnFromObject","from","appIndex","clearTxGroups","closeTxnArray","makePaymentTxnWithSuggestedParamsFromObject","closeRemainderTo","to","closeTxGroups","closeCustodialWallets"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/close_custodial_wallets.js"],"sourcesContent":["import { types } from '@algo-builder/web';\nimport { AppActions, LocalStateKeys } from '../constants/constants.js';\nimport { algodClient, indexerClient } from './algob.config.js';\nconst {\n    tryExecuteTx,\n    chunkArray,\n    readAppLocalState,\n    OptAppID,\n    executeRekeyedTx,\n    getCustodialWallets\n} = require('./common.js');\nconst { getApplicationAddress, default: algosdk } = require('algosdk');\n\n/**\n * Returns a list of custodial wallet addresses whose balance is above 10000 ALGO.\n * Inspiration: to take back the rewards gained by wallets during governance.\n * + Each account must be whitelisted and rekeyed to the optimum app.\n * + Each account must be registered and has voted to governance.\n * + We use the indexer to query all accounts opted in & rekeyed to app\n */\nasync function getCustodialWalletsToClose(network, adminAddr) {\n    const accounts = await getCustodialWallets(\n        OptAppID(network),\n        undefined,\n        network,\n        adminAddr,\n        200\n    );\n    const custodialWallets = [];\n    for (const acc of accounts) {\n        // check if there is \"residual balance\" in the custodial wallet (< 5 ALGO)\n        const bal = Math.floor(acc.amount);\n        if (bal < 5e6) {\n            custodialWallets.push(acc.address);\n        }\n    }\n\n    return custodialWallets;\n}\n\n/**\n * Find and withdraw from each custodial wallet(s) 10000 ALGO's. Returns if enough wallets\n * are not available to withdraw from (which shouldn't happen).\n * NOTE: withdraw amount is in microAlgos\n */\nasync function _closeCustodialWallets(\n    web,\n    custodialWallets,\n    adminAddr,\n    network,\n    selectedWalletType\n) {\n    // split whole custodial wallets array into chunks of 4\n    // as max 4 accounts can be passed in a tx group.\n    const txAccountArrays = chunkArray(custodialWallets, 4); // pass in tx.accounts\n\n    // 1. rekey all custodial wallets from contract -> admin\n    const rekeyTxArray = [];\n    for (let i = 0, j = 0; i < custodialWallets.length; i += 4, j++) {\n        // in each iteration we're withdrawing rewards from 4 wallets\n        rekeyTxArray.push({\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: adminAddr,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 1000 + 1000 * txAccountArrays[j].length },\n            accounts: txAccountArrays[j],\n            appArgs: [AppActions.CLOSE_CUSTODIAL_WALLETS]\n        });\n    }\n\n    // finally assemble transactions into groups of 16. Submit each group to network\n    const rekeyTxGroups = chunkArray(rekeyTxArray, 16);\n\n    for (const grp of rekeyTxGroups) {\n        await tryExecuteTx(web, grp);\n    }\n\n    const client = algodClient(network);\n\n    // 2. clear wallet state (clear tx appl call)\n    const clearTxArray = [];\n    for (let i = 0; i < custodialWallets.length; i++) {\n        const suggestedParams = await client.getTransactionParams().do();\n        suggestedParams.flatFee = true;\n        suggestedParams.fee = 1000;\n\n        // in each iteration we're withdrawing rewards from 4 wallets\n        clearTxArray.push(\n            algosdk.makeApplicationClearStateTxnFromObject({\n                from: custodialWallets[i],\n                suggestedParams: suggestedParams,\n                appIndex: OptAppID(network)\n            })\n        );\n    }\n\n    const clearTxGroups = chunkArray(clearTxArray, 16);\n    for (const grp of clearTxGroups) {\n        await executeRekeyedTx(web, grp, adminAddr, selectedWalletType);\n    }\n\n    // 3. close the wallet\n    const closeTxnArray = [];\n    for (let i = 0; i < custodialWallets.length; i++) {\n        const suggestedParams = await client.getTransactionParams().do();\n        suggestedParams.flatFee = true;\n        suggestedParams.fee = 1000;\n\n        closeTxnArray.push(\n            algosdk.makePaymentTxnWithSuggestedParamsFromObject({\n                from: custodialWallets[i],\n                suggestedParams: suggestedParams,\n                closeRemainderTo: adminAddr,\n                amount: 0,\n                to: custodialWallets[i]\n            })\n        );\n    }\n\n    const closeTxGroups = chunkArray(closeTxnArray, 16);\n    for (const grp of closeTxGroups) {\n        await executeRekeyedTx(web, grp, adminAddr, selectedWalletType);\n    }\n}\n\n/**\n * 1. Get custodial wallets with extra bal ( < 5 ALGO )\n * 2. Trigger the smart contract to completely withdraw these algos from the custodial wallets back into the contract\n */\nexport async function closeCustodialWallets(\n    web,\n    network,\n    adminAddr,\n    selectedWalletType\n) {\n    const custodialWallets = await getCustodialWalletsToClose(\n        network,\n        adminAddr\n    );\n\n    await _closeCustodialWallets(\n        web,\n        custodialWallets,\n        adminAddr,\n        network,\n        selectedWalletType\n    );\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,mBAAmB;AACzC,SAASC,UAAU,EAAEC,cAAc,QAAQ,2BAA2B;AACtE,SAASC,WAAW,EAAEC,aAAa,QAAQ,mBAAmB;AAC9D,MAAM;EACFC,YAAY;EACZC,UAAU;EACVC,iBAAiB;EACjBC,QAAQ;EACRC,gBAAgB;EAChBC;AACJ,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;AAC1B,MAAM;EAAEC,qBAAqB;EAAEC,OAAO,EAAEC;AAAQ,CAAC,GAAGH,OAAO,CAAC,SAAS,CAAC;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeI,0BAA0B,CAACC,OAAO,EAAEC,SAAS,EAAE;EAC1D,MAAMC,QAAQ,GAAG,MAAMR,mBAAmB,CACtCF,QAAQ,CAACQ,OAAO,CAAC,EACjBG,SAAS,EACTH,OAAO,EACPC,SAAS,EACT,GAAG,CACN;EACD,MAAMG,gBAAgB,GAAG,EAAE;EAC3B,KAAK,MAAMC,GAAG,IAAIH,QAAQ,EAAE;IACxB;IACA,MAAMI,GAAG,GAAGC,IAAI,CAACC,KAAK,CAACH,GAAG,CAACI,MAAM,CAAC;IAClC,IAAIH,GAAG,GAAG,GAAG,EAAE;MACXF,gBAAgB,CAACM,IAAI,CAACL,GAAG,CAACM,OAAO,CAAC;IACtC;EACJ;EAEA,OAAOP,gBAAgB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAeQ,sBAAsB,CACjCC,GAAG,EACHT,gBAAgB,EAChBH,SAAS,EACTD,OAAO,EACPc,kBAAkB,EACpB;EACE;EACA;EACA,MAAMC,eAAe,GAAGzB,UAAU,CAACc,gBAAgB,EAAE,CAAC,CAAC,CAAC,CAAC;;EAEzD;EACA,MAAMY,YAAY,GAAG,EAAE;EACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGb,gBAAgB,CAACe,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAEC,CAAC,EAAE,EAAE;IAC7D;IACAF,YAAY,CAACN,IAAI,CAAC;MACdU,IAAI,EAAEpC,KAAK,CAACqC,eAAe,CAACC,OAAO;MACnCC,IAAI,EAAEvC,KAAK,CAACwC,QAAQ,CAACC,SAAS;MAC9BC,eAAe,EAAEzB,SAAS;MAC1B0B,KAAK,EAAEnC,QAAQ,CAACQ,OAAO,CAAC;MACxB4B,QAAQ,EAAE;QAAEC,QAAQ,EAAE,IAAI,GAAG,IAAI,GAAGd,eAAe,CAACG,CAAC,CAAC,CAACC;MAAO,CAAC;MAC/DjB,QAAQ,EAAEa,eAAe,CAACG,CAAC,CAAC;MAC5BY,OAAO,EAAE,CAAC7C,UAAU,CAAC8C,uBAAuB;IAChD,CAAC,CAAC;EACN;;EAEA;EACA,MAAMC,aAAa,GAAG1C,UAAU,CAAC0B,YAAY,EAAE,EAAE,CAAC;EAElD,KAAK,MAAMiB,GAAG,IAAID,aAAa,EAAE;IAC7B,MAAM3C,YAAY,CAACwB,GAAG,EAAEoB,GAAG,CAAC;EAChC;EAEA,MAAMC,MAAM,GAAG/C,WAAW,CAACa,OAAO,CAAC;;EAEnC;EACA,MAAMmC,YAAY,GAAG,EAAE;EACvB,KAAK,IAAIlB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,gBAAgB,CAACe,MAAM,EAAEF,CAAC,EAAE,EAAE;IAC9C,MAAMmB,eAAe,GAAG,MAAMF,MAAM,CAACG,oBAAoB,EAAE,CAACC,EAAE,EAAE;IAChEF,eAAe,CAACG,OAAO,GAAG,IAAI;IAC9BH,eAAe,CAACI,GAAG,GAAG,IAAI;;IAE1B;IACAL,YAAY,CAACzB,IAAI,CACbZ,OAAO,CAAC2C,sCAAsC,CAAC;MAC3CC,IAAI,EAAEtC,gBAAgB,CAACa,CAAC,CAAC;MACzBmB,eAAe,EAAEA,eAAe;MAChCO,QAAQ,EAAEnD,QAAQ,CAACQ,OAAO;IAC9B,CAAC,CAAC,CACL;EACL;EAEA,MAAM4C,aAAa,GAAGtD,UAAU,CAAC6C,YAAY,EAAE,EAAE,CAAC;EAClD,KAAK,MAAMF,GAAG,IAAIW,aAAa,EAAE;IAC7B,MAAMnD,gBAAgB,CAACoB,GAAG,EAAEoB,GAAG,EAAEhC,SAAS,EAAEa,kBAAkB,CAAC;EACnE;;EAEA;EACA,MAAM+B,aAAa,GAAG,EAAE;EACxB,KAAK,IAAI5B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,gBAAgB,CAACe,MAAM,EAAEF,CAAC,EAAE,EAAE;IAC9C,MAAMmB,eAAe,GAAG,MAAMF,MAAM,CAACG,oBAAoB,EAAE,CAACC,EAAE,EAAE;IAChEF,eAAe,CAACG,OAAO,GAAG,IAAI;IAC9BH,eAAe,CAACI,GAAG,GAAG,IAAI;IAE1BK,aAAa,CAACnC,IAAI,CACdZ,OAAO,CAACgD,2CAA2C,CAAC;MAChDJ,IAAI,EAAEtC,gBAAgB,CAACa,CAAC,CAAC;MACzBmB,eAAe,EAAEA,eAAe;MAChCW,gBAAgB,EAAE9C,SAAS;MAC3BQ,MAAM,EAAE,CAAC;MACTuC,EAAE,EAAE5C,gBAAgB,CAACa,CAAC;IAC1B,CAAC,CAAC,CACL;EACL;EAEA,MAAMgC,aAAa,GAAG3D,UAAU,CAACuD,aAAa,EAAE,EAAE,CAAC;EACnD,KAAK,MAAMZ,GAAG,IAAIgB,aAAa,EAAE;IAC7B,MAAMxD,gBAAgB,CAACoB,GAAG,EAAEoB,GAAG,EAAEhC,SAAS,EAAEa,kBAAkB,CAAC;EACnE;AACJ;;AAEA;AACA;AACA;AACA;AACA,OAAO,eAAeoC,qBAAqB,CACvCrC,GAAG,EACHb,OAAO,EACPC,SAAS,EACTa,kBAAkB,EACpB;EACE,MAAMV,gBAAgB,GAAG,MAAML,0BAA0B,CACrDC,OAAO,EACPC,SAAS,CACZ;EAED,MAAMW,sBAAsB,CACxBC,GAAG,EACHT,gBAAgB,EAChBH,SAAS,EACTD,OAAO,EACPc,kBAAkB,CACrB;AACL"},"metadata":{},"sourceType":"module"}