{"ast":null,"code":"/**\n * encodeUint64 converts an integer to its binary representation.\n * @param num - The number to convert. This must be an unsigned integer less than\n *   2^64.\n * @returns An 8-byte typed array containing the big-endian encoding of the input\n *   integer.\n */\nexport function encodeUint64(num) {\n  const isInteger = typeof num === 'bigint' || Number.isInteger(num);\n  if (!isInteger || num < 0 || num > BigInt('0xffffffffffffffff')) {\n    throw new Error('Input is not a 64-bit unsigned integer');\n  }\n  const buf = Buffer.allocUnsafe(8);\n  buf.writeBigUInt64BE(BigInt(num));\n  return new Uint8Array(buf);\n}\nexport function decodeUint64(data) {\n  let decodingMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'safe';\n  if (decodingMode !== 'safe' && decodingMode !== 'mixed' && decodingMode !== 'bigint') {\n    throw new Error(`Unknown decodingMode option: ${decodingMode}`);\n  }\n  if (data.byteLength === 0 || data.byteLength > 8) {\n    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);\n  }\n  // insert 0s at the beginning if data is smaller than 8 bytes\n  const padding = Buffer.allocUnsafe(8 - data.byteLength);\n  padding.fill(0);\n  const buf = Buffer.concat([padding, Buffer.from(data)]);\n  const num = buf.readBigUInt64BE();\n  const isBig = num > Number.MAX_SAFE_INTEGER;\n  if (decodingMode === 'safe') {\n    if (isBig) {\n      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with \"mixed\" or \"safe\" decodingMode.`);\n    }\n    return Number(num);\n  }\n  if (decodingMode === 'mixed' && !isBig) {\n    return Number(num);\n  }\n  return num;\n}","map":{"version":3,"mappings":"AAAA;;;;;;;AAOA,OAAM,SAAUA,YAAY,CAACC,GAAoB;EAC/C,MAAMC,SAAS,GAAG,OAAOD,GAAG,KAAK,QAAQ,IAAIE,MAAM,CAACD,SAAS,CAACD,GAAG,CAAC;EAElE,IAAI,CAACC,SAAS,IAAID,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAGG,MAAM,CAAC,oBAAoB,CAAC,EAAE;IAC/D,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC;;EAG3D,MAAMC,GAAG,GAAGC,MAAM,CAACC,WAAW,CAAC,CAAC,CAAC;EAEjCF,GAAG,CAACG,gBAAgB,CAACL,MAAM,CAACH,GAAG,CAAC,CAAC;EAEjC,OAAO,IAAIS,UAAU,CAACJ,GAAG,CAAC;AAC5B;AA0BA,OAAM,SAAUK,YAAY,CAACC,IAAS,EAA4B;EAAA,IAA1BC,mFAAoB,MAAM;EAChE,IACEA,YAAY,KAAK,MAAM,IACvBA,YAAY,KAAK,OAAO,IACxBA,YAAY,KAAK,QAAQ,EACzB;IACA,MAAM,IAAIR,KAAK,CAAC,gCAAgCQ,YAAY,EAAE,CAAC;;EAGjE,IAAID,IAAI,CAACE,UAAU,KAAK,CAAC,IAAIF,IAAI,CAACE,UAAU,GAAG,CAAC,EAAE;IAChD,MAAM,IAAIT,KAAK,CACb,yEAAyEO,IAAI,CAACE,UAAU,EAAE,CAC3F;;EAGH;EACA,MAAMC,OAAO,GAAGR,MAAM,CAACC,WAAW,CAAC,CAAC,GAAGI,IAAI,CAACE,UAAU,CAAC;EACvDC,OAAO,CAACC,IAAI,CAAC,CAAC,CAAC;EAEf,MAAMV,GAAG,GAAGC,MAAM,CAACU,MAAM,CAAC,CAACF,OAAO,EAAER,MAAM,CAACW,IAAI,CAACN,IAAI,CAAC,CAAC,CAAC;EAEvD,MAAMX,GAAG,GAAGK,GAAG,CAACa,eAAe,EAAE;EACjC,MAAMC,KAAK,GAAGnB,GAAG,GAAGE,MAAM,CAACkB,gBAAgB;EAE3C,IAAIR,YAAY,KAAK,MAAM,EAAE;IAC3B,IAAIO,KAAK,EAAE;MACT,MAAM,IAAIf,KAAK,CACb,yCAAyCJ,GAAG,CAACqB,QAAQ,EAAE,qDAAqD,CAC7G;;IAEH,OAAOnB,MAAM,CAACF,GAAG,CAAC;;EAGpB,IAAIY,YAAY,KAAK,OAAO,IAAI,CAACO,KAAK,EAAE;IACtC,OAAOjB,MAAM,CAACF,GAAG,CAAC;;EAGpB,OAAOA,GAAG;AACZ","names":["encodeUint64","num","isInteger","Number","BigInt","Error","buf","Buffer","allocUnsafe","writeBigUInt64BE","Uint8Array","decodeUint64","data","decodingMode","byteLength","padding","fill","concat","from","readBigUInt64BE","isBig","MAX_SAFE_INTEGER","toString"],"sourceRoot":"","sources":["../../../src/encoding/uint64.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}