{"ast":null,"code":"import { concatArrays } from '../utils/utils';\n// NOTE: at the moment we specifically do not use Buffer.writeBigUInt64BE and\n// Buffer.readBigUInt64BE. This is because projects using webpack v4\n// automatically include an old version of the npm `buffer` package (v4.9.2 at\n// the time of writing), and this old version does not have these methods.\n/**\n * encodeUint64 converts an integer to its binary representation.\n * @param num - The number to convert. This must be an unsigned integer less than\n *   2^64.\n * @returns An 8-byte typed array containing the big-endian encoding of the input\n *   integer.\n */\nexport function encodeUint64(num) {\n  const isInteger = typeof num === 'bigint' || Number.isInteger(num);\n  if (!isInteger || num < 0 || num > BigInt('0xffffffffffffffff')) {\n    throw new Error('Input is not a 64-bit unsigned integer');\n  }\n  const encoding = new Uint8Array(8);\n  const view = new DataView(encoding.buffer);\n  view.setBigUint64(0, BigInt(num));\n  return encoding;\n}\nexport function decodeUint64(data) {\n  let decodingMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'safe';\n  if (decodingMode !== 'safe' && decodingMode !== 'mixed' && decodingMode !== 'bigint') {\n    throw new Error(`Unknown decodingMode option: ${decodingMode}`);\n  }\n  if (data.byteLength === 0 || data.byteLength > 8) {\n    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);\n  }\n  // insert 0s at the beginning if data is smaller than 8 bytes\n  const padding = new Uint8Array(8 - data.byteLength);\n  const encoding = concatArrays(padding, data);\n  const view = new DataView(encoding.buffer);\n  const num = view.getBigUint64(0);\n  const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);\n  if (decodingMode === 'safe') {\n    if (isBig) {\n      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with \"mixed\" or \"safe\" decodingMode.`);\n    }\n    return Number(num);\n  }\n  if (decodingMode === 'mixed' && !isBig) {\n    return Number(num);\n  }\n  return num;\n}","map":{"version":3,"mappings":"AAAA,SAASA,YAAY,QAAQ,gBAAgB;AAE7C;AACA;AACA;AACA;AAEA;;;;;;;AAOA,OAAM,SAAUC,YAAY,CAACC,GAAoB;EAC/C,MAAMC,SAAS,GAAG,OAAOD,GAAG,KAAK,QAAQ,IAAIE,MAAM,CAACD,SAAS,CAACD,GAAG,CAAC;EAElE,IAAI,CAACC,SAAS,IAAID,GAAG,GAAG,CAAC,IAAIA,GAAG,GAAGG,MAAM,CAAC,oBAAoB,CAAC,EAAE;IAC/D,MAAM,IAAIC,KAAK,CAAC,wCAAwC,CAAC;;EAG3D,MAAMC,QAAQ,GAAG,IAAIC,UAAU,CAAC,CAAC,CAAC;EAClC,MAAMC,IAAI,GAAG,IAAIC,QAAQ,CAACH,QAAQ,CAACI,MAAM,CAAC;EAC1CF,IAAI,CAACG,YAAY,CAAC,CAAC,EAAEP,MAAM,CAACH,GAAG,CAAC,CAAC;EAEjC,OAAOK,QAAQ;AACjB;AA0BA,OAAM,SAAUM,YAAY,CAACC,IAAS,EAA4B;EAAA,IAA1BC,mFAAoB,MAAM;EAChE,IACEA,YAAY,KAAK,MAAM,IACvBA,YAAY,KAAK,OAAO,IACxBA,YAAY,KAAK,QAAQ,EACzB;IACA,MAAM,IAAIT,KAAK,CAAC,gCAAgCS,YAAY,EAAE,CAAC;;EAGjE,IAAID,IAAI,CAACE,UAAU,KAAK,CAAC,IAAIF,IAAI,CAACE,UAAU,GAAG,CAAC,EAAE;IAChD,MAAM,IAAIV,KAAK,CACb,yEAAyEQ,IAAI,CAACE,UAAU,EAAE,CAC3F;;EAGH;EACA,MAAMC,OAAO,GAAG,IAAIT,UAAU,CAAC,CAAC,GAAGM,IAAI,CAACE,UAAU,CAAC;EACnD,MAAMT,QAAQ,GAAGP,YAAY,CAACiB,OAAO,EAAEH,IAAI,CAAC;EAC5C,MAAML,IAAI,GAAG,IAAIC,QAAQ,CAACH,QAAQ,CAACI,MAAM,CAAC;EAE1C,MAAMT,GAAG,GAAGO,IAAI,CAACS,YAAY,CAAC,CAAC,CAAC;EAChC,MAAMC,KAAK,GAAGjB,GAAG,GAAGG,MAAM,CAACD,MAAM,CAACgB,gBAAgB,CAAC;EAEnD,IAAIL,YAAY,KAAK,MAAM,EAAE;IAC3B,IAAII,KAAK,EAAE;MACT,MAAM,IAAIb,KAAK,CACb,yCAAyCJ,GAAG,CAACmB,QAAQ,EAAE,qDAAqD,CAC7G;;IAEH,OAAOjB,MAAM,CAACF,GAAG,CAAC;;EAGpB,IAAIa,YAAY,KAAK,OAAO,IAAI,CAACI,KAAK,EAAE;IACtC,OAAOf,MAAM,CAACF,GAAG,CAAC;;EAGpB,OAAOA,GAAG;AACZ","names":["concatArrays","encodeUint64","num","isInteger","Number","BigInt","Error","encoding","Uint8Array","view","DataView","buffer","setBigUint64","decodeUint64","data","decodingMode","byteLength","padding","getBigUint64","isBig","MAX_SAFE_INTEGER","toString"],"sourceRoot":"","sources":["../../../src/encoding/uint64.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}