{"ast":null,"code":"import { Buffer } from 'buffer';\nimport * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport { verifyMultisig } from './multisig';\nimport * as utils from './utils/utils';\nimport * as txnBuilder from './transaction';\nimport { isValidAddress } from './encoding/address';\n/** sanityCheckProgram performs heuristic program validation:\n * check if passed in bytes are Algorand address or is B64 encoded, rather than Teal bytes\n *\n * @param program - Program bytes to check\n */\nexport function sanityCheckProgram(program) {\n  if (!program || program.length === 0) throw new Error('empty program');\n  const lineBreakOrd = '\\n'.charCodeAt(0);\n  const blankSpaceOrd = ' '.charCodeAt(0);\n  const tildeOrd = '~'.charCodeAt(0);\n  const isPrintable = x => blankSpaceOrd <= x && x <= tildeOrd;\n  const isAsciiPrintable = program.every(x => x === lineBreakOrd || isPrintable(x));\n  if (isAsciiPrintable) {\n    const programStr = Buffer.from(program).toString();\n    if (isValidAddress(programStr)) throw new Error('requesting program bytes, get Algorand address');\n    if (Buffer.from(programStr, 'base64').toString('base64') === programStr) throw new Error('program should not be b64 encoded');\n    throw new Error('program bytes are all ASCII printable characters, not looking like Teal byte code');\n  }\n}\n/**\n LogicSig implementation\n\n LogicSig cannot sign transactions in all cases.  Instead, use LogicSigAccount as a safe, general purpose signing mechanism.  Since LogicSig does not track the provided signature's public key, LogicSig cannot sign transactions when delegated to a non-multisig account _and_ the sender is not the delegating account.\n */\nexport class LogicSig {\n  constructor(program, programArgs) {\n    this.tag = Buffer.from('Program');\n    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every(arg => arg.constructor === Uint8Array || Buffer.isBuffer(arg)))) {\n      throw new TypeError('Invalid arguments');\n    }\n    let args;\n    if (programArgs != null) args = programArgs.map(arg => new Uint8Array(arg));\n    sanityCheckProgram(program);\n    this.logic = program;\n    this.args = args;\n    this.sig = undefined;\n    this.msig = undefined;\n  }\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const obj = {\n      l: this.logic\n    };\n    if (this.args) {\n      obj.arg = this.args;\n    }\n    if (this.sig) {\n      obj.sig = this.sig;\n    } else if (this.msig) {\n      obj.msig = this.msig;\n    }\n    return obj;\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(encoded) {\n    const lsig = new LogicSig(encoded.l, encoded.arg);\n    lsig.sig = encoded.sig;\n    lsig.msig = encoded.msig;\n    return lsig;\n  }\n  /**\n   * Performs signature verification\n   * @param publicKey - Verification key (derived from sender address or escrow address)\n   */\n  verify(publicKey) {\n    if (this.sig && this.msig) {\n      return false;\n    }\n    try {\n      sanityCheckProgram(this.logic);\n    } catch (e) {\n      return false;\n    }\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    if (!this.sig && !this.msig) {\n      const hash = nacl.genericHash(toBeSigned);\n      return utils.arrayEqual(hash, publicKey);\n    }\n    if (this.sig) {\n      return nacl.verify(toBeSigned, this.sig, publicKey);\n    }\n    return verifyMultisig(toBeSigned, this.msig, publicKey);\n  }\n  /**\n   * Compute hash of the logic sig program (that is the same as escrow account address) as string address\n   * @returns String representation of the address\n   */\n  address() {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const hash = nacl.genericHash(toBeSigned);\n    return address.encodeAddress(new Uint8Array(hash));\n  }\n  /**\n   * Creates signature (if no msig provided) or multi signature otherwise\n   * @param secretKey - Secret key to sign with\n   * @param msig - Multisig account as \\{version, threshold, addrs\\}\n   */\n  sign(secretKey, msig) {\n    if (msig == null) {\n      this.sig = this.signProgram(secretKey);\n    } else {\n      const subsigs = msig.addrs.map(addr => ({\n        pk: address.decodeAddress(addr).publicKey\n      }));\n      this.msig = {\n        v: msig.version,\n        thr: msig.threshold,\n        subsig: subsigs\n      };\n      const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n      this.msig.subsig[index].s = sig;\n    }\n  }\n  /**\n   * Appends a signature to multi signature\n   * @param secretKey - Secret key to sign with\n   */\n  appendToMultisig(secretKey) {\n    if (this.msig === undefined) {\n      throw new Error('no multisig present');\n    }\n    const [sig, index] = this.singleSignMultisig(secretKey, this.msig);\n    this.msig.subsig[index].s = sig;\n  }\n  signProgram(secretKey) {\n    const toBeSigned = utils.concatArrays(this.tag, this.logic);\n    const sig = nacl.sign(toBeSigned, secretKey);\n    return sig;\n  }\n  singleSignMultisig(secretKey, msig) {\n    let index = -1;\n    const myPk = nacl.keyPairFromSecretKey(secretKey).publicKey;\n    for (let i = 0; i < msig.subsig.length; i++) {\n      const {\n        pk\n      } = msig.subsig[i];\n      if (utils.arrayEqual(pk, myPk)) {\n        index = i;\n        break;\n      }\n    }\n    if (index === -1) {\n      throw new Error('invalid secret key');\n    }\n    const sig = this.signProgram(secretKey);\n    return [sig, index];\n  }\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n  static fromByte(encoded) {\n    const decodedObj = encoding.decode(encoded);\n    return LogicSig.from_obj_for_encoding(decodedObj);\n  }\n}\n/**\n * Represents an account that can sign with a LogicSig program.\n */\nexport class LogicSigAccount {\n  /**\n   * Create a new LogicSigAccount. By default this will create an escrow\n   * LogicSig account. Call `sign` or `signMultisig` on the newly created\n   * LogicSigAccount to make it a delegated account.\n   *\n   * @param program - The compiled TEAL program which contains the logic for\n   *   this LogicSig.\n   * @param args - An optional array of arguments for the program.\n   */\n  constructor(program, args) {\n    this.lsig = new LogicSig(program, args);\n    this.sigkey = undefined;\n  }\n  // eslint-disable-next-line camelcase\n  get_obj_for_encoding() {\n    const obj = {\n      lsig: this.lsig.get_obj_for_encoding()\n    };\n    if (this.sigkey) {\n      obj.sigkey = this.sigkey;\n    }\n    return obj;\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(encoded) {\n    const lsigAccount = new LogicSigAccount(encoded.lsig.l, encoded.lsig.arg);\n    lsigAccount.lsig = LogicSig.from_obj_for_encoding(encoded.lsig);\n    lsigAccount.sigkey = encoded.sigkey;\n    return lsigAccount;\n  }\n  /**\n   * Encode this object into msgpack.\n   */\n  toByte() {\n    return encoding.encode(this.get_obj_for_encoding());\n  }\n  /**\n   * Decode a msgpack object into a LogicSigAccount.\n   * @param encoded - The encoded LogicSigAccount.\n   */\n  static fromByte(encoded) {\n    const decodedObj = encoding.decode(encoded);\n    return LogicSigAccount.from_obj_for_encoding(decodedObj);\n  }\n  /**\n   * Check if this LogicSigAccount has been delegated to another account with a\n   * signature.\n   *\n   * Note this function only checks for the presence of a delegation signature.\n   * To verify the delegation signature, use `verify`.\n   */\n  isDelegated() {\n    return !!(this.lsig.sig || this.lsig.msig);\n  }\n  /**\n   * Verifies this LogicSig's program and signatures.\n   * @returns true if and only if the LogicSig program and signatures are valid.\n   */\n  verify() {\n    const addr = this.address();\n    return this.lsig.verify(address.decodeAddress(addr).publicKey);\n  }\n  /**\n   * Get the address of this LogicSigAccount.\n   *\n   * If the LogicSig is delegated to another account, this will return the\n   * address of that account.\n   *\n   * If the LogicSig is not delegated to another account, this will return an\n   *  escrow address that is the hash of the LogicSig's program code.\n   */\n  address() {\n    if (this.lsig.sig && this.lsig.msig) {\n      throw new Error('LogicSig has too many signatures. At most one of sig or msig may be present');\n    }\n    if (this.lsig.sig) {\n      if (!this.sigkey) {\n        throw new Error('Signing key for delegated account is missing');\n      }\n      return address.encodeAddress(this.sigkey);\n    }\n    if (this.lsig.msig) {\n      const msigMetadata = {\n        version: this.lsig.msig.v,\n        threshold: this.lsig.msig.thr,\n        pks: this.lsig.msig.subsig.map(subsig => subsig.pk)\n      };\n      return address.encodeAddress(address.fromMultisigPreImg(msigMetadata));\n    }\n    return this.lsig.address();\n  }\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. Use this function if the delegating account is a\n   * multisig account.\n   *\n   * @param msig - The multisig delegating account\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account. Use `appendToMultisig` to add additional signatures\n   *   from other members.\n   */\n  signMultisig(msig, secretKey) {\n    this.lsig.sign(secretKey, msig);\n  }\n  /**\n   * Adds an additional signature from a member of the delegating multisig\n   * account.\n   *\n   * @param secretKey - The secret key of one of the members of the delegating\n   *   multisig account.\n   */\n  appendToMultisig(secretKey) {\n    this.lsig.appendToMultisig(secretKey);\n  }\n  /**\n   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig\n   * has the authority to sign transactions on behalf of another account, called\n   * the delegating account. If the delegating account is a multisig account,\n   * use `signMultisig` instead.\n   *\n   * @param secretKey - The secret key of the delegating account.\n   */\n  sign(secretKey) {\n    this.lsig.sign(secretKey);\n    this.sigkey = nacl.keyPairFromSecretKey(secretKey).publicKey;\n  }\n}\nfunction signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {\n  if (!lsig.verify(lsigAddress)) {\n    throw new Error('Logic signature verification failed. Ensure the program and signature are valid.');\n  }\n  const signedTxn = {\n    lsig: lsig.get_obj_for_encoding(),\n    txn: txn.get_obj_for_encoding()\n  };\n  if (!nacl.bytesEqual(lsigAddress, txn.from.publicKey)) {\n    signedTxn.sgnr = Buffer.from(lsigAddress);\n  }\n  return {\n    txID: txn.txID().toString(),\n    blob: encoding.encode(signedTxn)\n  };\n}\n/**\n * signLogicSigTransactionObject takes a transaction and a LogicSig object and\n * returns a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n */\nexport function signLogicSigTransactionObject(txn, lsigObject) {\n  let lsig;\n  let lsigAddress;\n  if (lsigObject instanceof LogicSigAccount) {\n    lsig = lsigObject.lsig;\n    lsigAddress = address.decodeAddress(lsigObject.address()).publicKey;\n  } else {\n    lsig = lsigObject;\n    if (lsig.sig) {\n      // For a LogicSig with a non-multisig delegating account, we cannot derive\n      // the address of that account from only its signature, so assume the\n      // delegating account is the sender. If that's not the case, the signing\n      // will fail.\n      lsigAddress = txn.from.publicKey;\n    } else if (lsig.msig) {\n      const msigMetadata = {\n        version: lsig.msig.v,\n        threshold: lsig.msig.thr,\n        pks: lsig.msig.subsig.map(subsig => subsig.pk)\n      };\n      lsigAddress = address.fromMultisigPreImg(msigMetadata);\n    } else {\n      lsigAddress = address.decodeAddress(lsig.address()).publicKey;\n    }\n  }\n  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);\n}\n/**\n * signLogicSigTransaction takes a transaction and a LogicSig object and returns\n * a signed transaction.\n *\n * @param txn - The transaction to sign.\n * @param lsigObject - The LogicSig object that will sign the transaction.\n *\n * @returns Object containing txID and blob representing signed transaction.\n * @throws error on failure\n */\nexport function signLogicSigTransaction(txn, lsigObject) {\n  const algoTxn = txnBuilder.instantiateTxnIfNeeded(txn);\n  return signLogicSigTransactionObject(algoTxn, lsigObject);\n}\n/**\n * logicSigFromByte accepts encoded logic sig bytes and attempts to call logicsig.fromByte on it,\n * returning the result\n */\nexport function logicSigFromByte(encoded) {\n  return LogicSig.fromByte(encoded);\n}\nconst SIGN_PROGRAM_DATA_PREFIX = Buffer.from('ProgData');\n/**\n * tealSign creates a signature compatible with ed25519verify opcode from program hash\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n */\nexport function tealSign(sk, data, programHash) {\n  const parts = utils.concatArrays(address.decodeAddress(programHash).publicKey, data);\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.sign(toBeSigned, sk);\n}\n/**\n * verifyTealSign verifies a signature as would the ed25519verify opcode\n * @param data - buffer with original signed data\n * @param programHash - string representation of teal program hash (= contract address for LogicSigs)\n * @param sig - uint8array with the signature to verify (produced by tealSign/tealSignFromProgram)\n * @param pk - uint8array with public key to verify against\n */\nexport function verifyTealSign(data, programHash, sig, pk) {\n  const parts = utils.concatArrays(address.decodeAddress(programHash).publicKey, data);\n  const toBeSigned = Buffer.from(utils.concatArrays(SIGN_PROGRAM_DATA_PREFIX, parts));\n  return nacl.verify(toBeSigned, sig, pk);\n}\n/**\n * tealSignFromProgram creates a signature compatible with ed25519verify opcode from raw program bytes\n * @param sk - uint8array with secret key\n * @param data - buffer with data to sign\n * @param program - buffer with teal program\n */\nexport function tealSignFromProgram(sk, data, program) {\n  const lsig = new LogicSig(program);\n  const contractAddress = lsig.address();\n  return tealSign(sk, data, contractAddress);\n}","map":{"version":3,"mappings":"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","names":["Buffer","nacl","address","encoding","verifyMultisig","utils","txnBuilder","isValidAddress","sanityCheckProgram","program","length","Error","lineBreakOrd","charCodeAt","blankSpaceOrd","tildeOrd","isPrintable","x","isAsciiPrintable","every","programStr","from","toString","LogicSig","constructor","programArgs","Array","isArray","arg","Uint8Array","isBuffer","TypeError","args","map","logic","sig","undefined","msig","get_obj_for_encoding","obj","l","from_obj_for_encoding","encoded","lsig","verify","publicKey","e","toBeSigned","concatArrays","tag","hash","genericHash","arrayEqual","encodeAddress","sign","secretKey","signProgram","subsigs","addrs","addr","pk","decodeAddress","v","version","thr","threshold","subsig","index","singleSignMultisig","s","appendToMultisig","myPk","keyPairFromSecretKey","i","toByte","encode","fromByte","decodedObj","decode","LogicSigAccount","sigkey","lsigAccount","isDelegated","msigMetadata","pks","fromMultisigPreImg","signMultisig","signLogicSigTransactionWithAddress","txn","lsigAddress","signedTxn","bytesEqual","sgnr","txID","blob","signLogicSigTransactionObject","lsigObject","signLogicSigTransaction","algoTxn","instantiateTxnIfNeeded","logicSigFromByte","SIGN_PROGRAM_DATA_PREFIX","tealSign","sk","data","programHash","parts","verifyTealSign","tealSignFromProgram","contractAddress"],"sourceRoot":"","sources":["../../src/logicsig.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}