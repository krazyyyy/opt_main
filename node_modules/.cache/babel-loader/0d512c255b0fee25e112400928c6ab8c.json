{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebMode = void 0;\nconst algosdk_1 = __importDefault(require(\"algosdk\"));\nconst errors_1 = require(\"../errors/errors\");\nconst types_1 = require(\"../types\");\nconst constants_1 = require(\"./constants\");\nconst logger_1 = require(\"./logger\");\nconst txn_1 = require(\"./txn\");\nconst CONFIRMED_ROUND = \"confirmed-round\";\nconst LAST_ROUND = \"last-round\";\nclass WebMode {\n  constructor(algoSigner, chainName) {\n    this.algoSigner = algoSigner;\n    this.chainName = chainName;\n  }\n  /**\n   * wait for confirmation for transaction using transaction id\n   * @param txId Transaction id\n   * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10\n   * @returns TxnReceipt which includes confirmed txn response along with txID\n   */\n  async waitForConfirmation(txId) {\n    let waitRounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.WAIT_ROUNDS;\n    try {\n      const response = await this.algoSigner.algod({\n        ledger: this.chainName,\n        path: \"/v2/status\"\n      });\n      (0, logger_1.log)(response);\n      const startRound = response[LAST_ROUND];\n      let currentRound = startRound;\n      // eslint-disable-next-line no-constant-condition\n      while (currentRound < startRound + waitRounds) {\n        const pendingInfo = await this.algoSigner.algod({\n          ledger: this.chainName,\n          path: `/v2/transactions/pending/${txId}`\n        });\n        if (pendingInfo[CONFIRMED_ROUND] !== null && pendingInfo[CONFIRMED_ROUND] > 0) {\n          const txnReceipt = {\n            txID: txId,\n            ...pendingInfo\n          };\n          return txnReceipt;\n        }\n        // TODO: maybe we should use \"sleep\" instead of pinging a node again?\n        currentRound += 1;\n        await this.algoSigner.algod({\n          ledger: this.chainName,\n          path: `/v2/status/wait-for-block-after/${currentRound}` // eslint-disable-line @typescript-eslint/restrict-template-expressions\n        });\n      }\n\n      throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Send signed transaction to network and wait for confirmation\n   * @param signedTxn Signed Transaction blob encoded in base64\n   * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10\n   * @returns TxnReceipt which includes confirmed txn response along with txID\n   */\n  async sendAndWait(signedTxn) {\n    let waitRounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.WAIT_ROUNDS;\n    try {\n      const txInfo = await this.algoSigner.send({\n        ledger: this.chainName,\n        tx: signedTxn\n      });\n      if (txInfo && typeof txInfo.txId === \"string\") {\n        return await this.waitForConfirmation(txInfo.txId, waitRounds);\n      }\n      throw new Error(\"Transaction Error\");\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Send group transaction to network\n   * @param signedTxs signed transaction group\n   */\n  async sendGroupTransaction(signedTxs) {\n    try {\n      // The AlgoSigner.signTxn() response would look like '[{ txID, blob }, null]'\n      // Convert first transaction to binary from the response\n      const signedTxBinary = signedTxs.map(txn => {\n        return this.algoSigner.encoding.base64ToMsgpack(txn.blob);\n      });\n      // Merge transaction binaries into a single Uint8Array\n      const flatNumberArray = signedTxBinary.reduce((acc, curr) => {\n        acc.push(...curr);\n        return acc;\n      }, []);\n      const combinedBinaryTxns = new Uint8Array(flatNumberArray);\n      // Convert the combined array values back to base64\n      const combinedBase64Txns = this.algoSigner.encoding.msgpackToBase64(combinedBinaryTxns);\n      return await this.algoSigner.send({\n        ledger: this.chainName,\n        tx: combinedBase64Txns\n      });\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Sign transaction using algosigner\n   * @param txns Array of transactions in base64\n   */\n  async signTransaction(txns) {\n    try {\n      return await this.algoSigner.signTxn(txns);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Returns suggested transaction parameters using algosigner\n   * @param userParams Transaction parameters\n   */\n  async getSuggestedParams(userParams) {\n    try {\n      const txParams = await this.algoSigner.algod({\n        ledger: this.chainName,\n        path: \"/v2/transactions/params\"\n      });\n      const s = {\n        fee: txParams.fee,\n        genesisHash: txParams[\"genesis-hash\"],\n        genesisID: txParams[\"genesis-id\"],\n        firstRound: txParams[LAST_ROUND],\n        lastRound: Number(txParams[LAST_ROUND]) + 1000,\n        flatFee: false\n      };\n      s.flatFee = userParams.totalFee !== undefined;\n      s.fee = userParams.totalFee || userParams.feePerByte || txParams[\"min-fee\"]; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing\n      if (s.flatFee) s.fee = Math.max(Number(s.fee), Number(txParams[\"min-fee\"]));\n      s.firstRound = userParams.firstValid || s.firstRound; // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing\n      s.lastRound = userParams.firstValid === undefined || userParams.validRounds === undefined // eslint-disable-line @typescript-eslint/prefer-nullish-coalescing\n      ? s.lastRound : Number(userParams.firstValid) + Number(userParams.validRounds);\n      return s;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Appends signature to a multisig transaction using algosigner\n   * @param txns array of multisignature transaction with at least one signature\n   * @param signers a subset of addresses to sign the transaction\n   * return an object containing a blob attribute encoded in base64\n   */\n  async appendSignMultisigTransaction(txns, signers) {\n    try {\n      const result = {};\n      for (let i = 0; i < txns.length; ++i) {\n        const txn = txns[i];\n        const partialTxn = algosdk_1.default.decodeObj(this.algoSigner.encoding.base64ToMsgpack(txn.txn));\n        if (partialTxn.txn === undefined || partialTxn.msig === undefined) {\n          throw new Error(\"Input transaction must be multisigature transaction signed with at least 1 signature\");\n        }\n        const txnToBeSign = algosdk_1.default.Transaction.from_obj_for_encoding(partialTxn.txn);\n        const txnToBeSign_Uint8Array = algosdk_1.default.encodeObj(txnToBeSign.get_obj_for_encoding());\n        const txnToBeSign_Base64 = this.algoSigner.encoding.msgpackToBase64(txnToBeSign_Uint8Array);\n        const mparams = partialTxn.msig;\n        const addrs = mparams.subsig.map(signData => {\n          return algosdk_1.default.encodeAddress(signData.pk);\n        });\n        const multisigParams = {\n          version: mparams.v,\n          threshold: mparams.thr,\n          addrs: addrs\n        };\n        const signedTxn = await this.signTransaction([{\n          txn: txnToBeSign_Base64,\n          msig: multisigParams,\n          signers: signers\n        }]);\n        const signedTxnJson = signedTxn[0];\n        const blob = signedTxnJson.blob;\n        const blob1 = this.algoSigner.encoding.base64ToMsgpack(txn.txn);\n        const blob2 = this.algoSigner.encoding.base64ToMsgpack(blob);\n        const combineBlob = algosdk_1.default.mergeMultisigTransactions([blob1, blob2]);\n        const outputBase64 = this.algoSigner.encoding.msgpackToBase64(combineBlob);\n        result[i] = {\n          blob: outputBase64\n        };\n      }\n      return result;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Execute single transaction or group of transactions (atomic transaction)\n   * Check out {@link https://algobuilder.dev/guide/execute-transaction.html#execute-transaction|execute-transaction}\n   * for more info.\n   * @param transactions transaction parameters, atomic transaction parameters\n   * or TransactionAndSign object(SDK transaction object and signer parameters).\n   * When list of ExecParams is used, the function will request wallet to sign transactions.\n   */\n  /* eslint-disable sonarjs/cognitive-complexity */\n  async executeTx(transactions) {\n    try {\n      var _signedTxn;\n      let signedTxn;\n      let txns = [];\n      if (transactions.length > 16 || transactions.length == 0) {\n        throw new errors_1.BuilderError(errors_1.ERRORS.GENERAL.TRANSACTION_LENGTH_ERROR, {\n          length: transactions.length\n        });\n      }\n      if ((0, types_1.isSDKTransactionAndSign)(transactions[0])) throw new Error(\"We don't support this case now\");\n      const execParams = transactions;\n      for (const [_, txn] of execParams.entries()) {\n        txns.push((0, txn_1.mkTransaction)(txn, await this.getSuggestedParams(txn.payFlags)));\n      }\n      txns = algosdk_1.default.assignGroupID(txns);\n      const binaryTxs = txns.map(txn => {\n        return txn.toByte();\n      });\n      const base64Txs = binaryTxs.map(txn => {\n        return this.algoSigner.encoding.msgpackToBase64(txn);\n      });\n      // with logic signature we don't need signers.\n      const toBeSignedTxns = base64Txs.map((txn, txnId) => {\n        var _execParams$txnId$fro;\n        switch (execParams[txnId].sign) {\n          case types_1.SignType.LogicSignature:\n            return {\n              txn: txn,\n              signers: []\n            };\n          // logic signature\n          case types_1.SignType.MultiSignature:\n            {\n              const msig = execParams[txnId];\n              return {\n                txn: txn,\n                msig: msig.mparams\n              }; // multi singature\n            }\n\n          default:\n            return {\n              txn: txn,\n              authAddr: ((_execParams$txnId$fro = execParams[txnId].fromAccount) === null || _execParams$txnId$fro === void 0 ? void 0 : _execParams$txnId$fro.addr) || execParams[txnId].fromAccountAddr\n            };\n          // set signer\n        }\n      });\n      // checks if any sign txn exists else it throws error of empty signers array\n      if (toBeSignedTxns.find(txn => txn.authAddr)) {\n        signedTxn = await this.signTransaction(toBeSignedTxns);\n      }\n      // sign smart signature transaction\n      for (const [index, txn] of txns.entries()) {\n        const signer = execParams[index];\n        if (signer.sign === types_1.SignType.LogicSignature) {\n          signer.lsig.lsig.args = signer.args ? signer.args : [];\n          const lsigTxn = algosdk_1.default.signLogicSigTransaction(txn, signer.lsig);\n          if (!Array.isArray(signedTxn)) signedTxn = []; // only logic signature txn are provided\n          signedTxn.splice(index, 0, {\n            blob: this.algoSigner.encoding.msgpackToBase64(lsigTxn.blob),\n            txID: lsigTxn.txID\n          });\n        }\n      }\n      signedTxn = (_signedTxn = signedTxn) === null || _signedTxn === void 0 ? void 0 : _signedTxn.filter(stxn => stxn);\n      const txInfo = await this.sendGroupTransaction(signedTxn);\n      if (txInfo && typeof txInfo.txId === \"string\") {\n        return await this.waitForConfirmation(txInfo.txId);\n      }\n      throw new Error(\"Transaction Error\");\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Creates an algosdk.Transaction object based on execParams and suggestedParams\n   * @param execParams execParams containing all txn info\n   * @param txParams suggestedParams object\n   * @returns array of algosdk.Transaction objects\n   */\n  makeTx(execParams, txParams) {\n    try {\n      const txns = [];\n      for (const [_, txn] of execParams.entries()) {\n        txns.push((0, txn_1.mkTransaction)(txn, txParams));\n      }\n      return txns;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Signs a Transaction object\n   * @param transaction transaction object.\n   * @returns SignedTransaction\n   */\n  async signTx(transaction) {\n    try {\n      const binaryTx = transaction.toByte();\n      const base64Tx = this.algoSigner.encoding.msgpackToBase64(binaryTx);\n      const signedTx = await this.signTransaction([{\n        txn: base64Tx\n      }]);\n      const blob = signedTx.blob;\n      const blobArray = this.algoSigner.encoding.base64ToMsgpack(blob);\n      return algosdk_1.default.decodeSignedTransaction(blobArray);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Creates an algosdk.Transaction object based on execParams and suggestedParams\n   * and signs it\n   * @param execParams execParams containing all txn info\n   * @param txParams suggestedParams object\n   * @returns array of algosdk.SignedTransaction objects\n   */\n  async makeAndSignTx(execParams, txParams) {\n    try {\n      const signedTxns = [];\n      const txns = this.makeTx(execParams, txParams);\n      for (const transaction of txns) {\n        const signedTransaction = await this.signTx(transaction);\n        signedTxns.push(signedTransaction);\n      }\n      return signedTxns;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Sends signedTransaction and waits for the response\n   * @param transactions array of signedTransaction objects.\n   * @param rounds number of rounds to wait for response\n   * @returns TxnReceipt which includes confirmed txn response along with txID\n   */\n  async sendTxAndWait(transactions, rounds) {\n    try {\n      if (transactions.length < 1) {\n        throw new Error(\"No transactions to process\");\n      } else {\n        const txInfo = await this.sendGroupTransaction(transactions);\n        if (txInfo && typeof txInfo.txId === \"string\") {\n          return await this.waitForConfirmation(txInfo.txId, rounds);\n        }\n        throw new Error(\"Transaction Incorrect\");\n      }\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n}\nexports.WebMode = WebMode;","map":{"version":3,"mappings":"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","names":["CONFIRMED_ROUND","LAST_ROUND","WebMode","constructor","algoSigner","chainName","waitForConfirmation","txId","waitRounds","constants_1","response","algod","ledger","path","startRound","currentRound","pendingInfo","txnReceipt","txID","Error","err","sendAndWait","signedTxn","txInfo","send","tx","sendGroupTransaction","signedTxs","signedTxBinary","map","txn","encoding","base64ToMsgpack","blob","flatNumberArray","reduce","acc","curr","push","combinedBinaryTxns","Uint8Array","combinedBase64Txns","msgpackToBase64","signTransaction","txns","signTxn","getSuggestedParams","userParams","txParams","s","fee","genesisHash","genesisID","firstRound","lastRound","Number","flatFee","totalFee","undefined","feePerByte","Math","max","firstValid","validRounds","appendSignMultisigTransaction","signers","result","i","length","partialTxn","algosdk_1","decodeObj","msig","txnToBeSign","Transaction","from_obj_for_encoding","txnToBeSign_Uint8Array","encodeObj","get_obj_for_encoding","txnToBeSign_Base64","mparams","addrs","subsig","signData","encodeAddress","pk","multisigParams","version","v","threshold","thr","signedTxnJson","blob1","blob2","combineBlob","mergeMultisigTransactions","outputBase64","executeTx","transactions","errors_1","GENERAL","TRANSACTION_LENGTH_ERROR","execParams","_","entries","payFlags","assignGroupID","binaryTxs","toByte","base64Txs","toBeSignedTxns","txnId","sign","types_1","LogicSignature","MultiSignature","authAddr","fromAccount","addr","fromAccountAddr","find","index","signer","lsig","args","lsigTxn","signLogicSigTransaction","Array","isArray","splice","filter","stxn","makeTx","signTx","transaction","binaryTx","base64Tx","signedTx","blobArray","decodeSignedTransaction","makeAndSignTx","signedTxns","signedTransaction","sendTxAndWait","rounds","exports"],"sourceRoot":"","sources":["../../src/lib/web-mode.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}