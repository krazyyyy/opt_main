{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MyAlgoWalletSession = void 0;\nconst algosdk_1 = __importDefault(require(\"algosdk\"));\nconst __1 = require(\"..\");\nconst types_1 = require(\"../types\");\nconst api_1 = require(\"./api\");\nconst constants_1 = require(\"./constants\");\nconst logger_1 = require(\"./logger\");\nconst txn_1 = require(\"./txn\");\nclass MyAlgoWalletSession {\n  constructor(walletURL, connector) {\n    this.accounts = [];\n    this.addresses = [];\n    this.algodClient = (0, api_1.algoexplorerAlgod)(walletURL);\n    try {\n      const MyAlgoConnect = require(\"@randlabs/myalgo-connect\"); // eslint-disable-line @typescript-eslint/no-var-requires\n      if (connector) {\n        this.connector = connector;\n      } else {\n        this.connector = new MyAlgoConnect();\n      }\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  // https://connect.myalgo.com/docs/interactive-examples/Connect\n  async connectToMyAlgo() {\n    try {\n      this.accounts = await this.connector.connect({\n        shouldSelectOneAccount: false,\n        openManager: true\n      });\n      this.addresses = this.accounts.map(account => account.address);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw new Error(\"Error while connecting to MyAlgo Wallet\" + err);\n    }\n  }\n  /**\n   * https://connect.myalgo.com/docs/interactive-examples/PaymentTransaction\n   * Sign a single transaction from a my algo wallet session\n   * @param txn { SDK transaction object, shouldSign, signers, msig } object\n   * @returns raw signed txn\n   */\n  async signTransaction(txn, signOptions) {\n    try {\n      return await this.connector.signTransaction(txn.toByte(), signOptions);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * https://connect.myalgo.com/docs/interactive-examples/GroupedTransaction\n   * Sign a group of transaction(s) from a my algo wallet session\n   * @param txns { SDK transaction object, shouldSign, signers, msig } object\n   * @returns array of raw signed txns | null. null representes that the txn in array is NOT signed\n   * by wallet user (i.e signable by someone else).\n   */\n  async signTransactionGroup(txns, signOptions) {\n    try {\n      const txnsGroup = txns.map(v => v.txn);\n      const groupID = algosdk_1.default.computeGroupID(txnsGroup);\n      for (let i = 0; i < txns.length; i++) {\n        // called from executeTx where groupID is already assigned\n        if (!txnsGroup[i].group) {\n          txnsGroup[i].group = groupID;\n        }\n      }\n      return await this.connector.signTransaction(txnsGroup.map(txn => txn.toByte()), signOptions);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Send signed transaction to network and wait for confirmation\n   * @param rawTxns Signed Transaction(s)\n   * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10\n   * @returns TxnReceipt which includes confirmed txn response along with txID\n   */\n  async sendAndWait(rawTxns) {\n    let waitRounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.WAIT_ROUNDS;\n    try {\n      const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();\n      return await this.waitForConfirmation(txInfo.txId, waitRounds);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n  * Function used to wait for a tx confirmation\n  * @param txId txn ID for which confirmation is required\n  * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10\n  * @returns TxnReceipt which includes confirmed txn response along with txID\n  */\n  async waitForConfirmation(txId) {\n    let waitRounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.WAIT_ROUNDS;\n    try {\n      const pendingInfo = await algosdk_1.default.waitForConfirmation(this.algodClient, txId, waitRounds);\n      if (pendingInfo[\"pool-error\"]) {\n        throw new Error(`Transaction Pool Error: ${pendingInfo[\"pool-error\"]}`);\n      }\n      const txnReceipt = {\n        txID: txId,\n        ...pendingInfo\n      };\n      return txnReceipt;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Execute single transaction or group of transactions (atomic transaction)\n   * @param execParams transaction parameters or atomic transaction parameters\n   */\n  async executeTx(execParams) {\n    try {\n      var _signedTxn, _signedTxn2;\n      let signedTxn;\n      let txns = [];\n      if (execParams.length > 16) {\n        throw new Error(\"Maximum size of an atomic transfer group is 16\");\n      }\n      if ((0, types_1.isSDKTransactionAndSign)(execParams[0])) throw new Error(\"We don't support this case now\");\n      for (const [_, txn] of execParams.entries()) {\n        txns.push((0, txn_1.mkTransaction)(txn, await (0, __1.mkTxParams)(this.algodClient, txn.payFlags)));\n      }\n      txns = algosdk_1.default.assignGroupID(txns);\n      // with logic signature we set shouldSign to false\n      const toBeSignedTxns = execParams.map((txn, index) => {\n        return txn.sign === types_1.SignType.LogicSignature ? {\n          txn: txns[index],\n          shouldSign: false\n        } // logic signature\n        : {\n          txn: txns[index],\n          shouldSign: true\n        }; // to be signed\n      });\n      // only shouldSign txn are to be signed, algowallet doesn't accept lsig ones\n      const nonLsigTxn = toBeSignedTxns.filter(txn => txn.shouldSign);\n      if (nonLsigTxn.length) {\n        signedTxn = await this.signTransactionGroup(nonLsigTxn);\n      }\n      // sign smart signature transaction\n      for (const [index, txn] of txns.entries()) {\n        const signer = execParams[index];\n        if (signer.sign === types_1.SignType.LogicSignature) {\n          signer.lsig.lsig.args = signer.args ? signer.args : [];\n          if (!Array.isArray(signedTxn)) signedTxn = [];\n          signedTxn.splice(index, 0, algosdk_1.default.signLogicSigTransaction(txn, signer.lsig));\n        }\n      }\n      signedTxn = (_signedTxn = signedTxn) === null || _signedTxn === void 0 ? void 0 : _signedTxn.filter(stxn => stxn);\n      const Uint8ArraySignedTx = (_signedTxn2 = signedTxn) === null || _signedTxn2 === void 0 ? void 0 : _signedTxn2.map(stxn => stxn.blob);\n      const confirmedTx = await this.sendAndWait(Uint8ArraySignedTx);\n      (0, logger_1.log)(\"confirmedTx: \", confirmedTx);\n      return confirmedTx;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Creates an algosdk.Transaction object based on execParams and suggestedParams\n   * @param execParams execParams containing all txn info\n   * @param txParams suggestedParams object\n   * @returns array of algosdk.Transaction objects\n   */\n  makeTx(execParams, txParams) {\n    try {\n      const txns = [];\n      for (const [_, txn] of execParams.entries()) {\n        txns.push((0, txn_1.mkTransaction)(txn, txParams));\n      }\n      return txns;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Signs a Transaction object with with myAlgoWallet\n   * @param transaction transaction object.\n   * @returns SignedTransaction\n   */\n  async signTx(transaction) {\n    try {\n      const signedTx = await this.connector.signTransaction(transaction.toByte());\n      const blob = signedTx.blob;\n      return algosdk_1.default.decodeSignedTransaction(blob);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Creates an algosdk.Transaction object based on execParams and suggestedParams\n   * and signs with myAlgoWallet\n   * @param execParams execParams containing all txn info\n   * @param txParams suggestedParams object\n   * @returns array of algosdk.SignedTransaction objects\n   */\n  async makeAndSignTx(execParams, txParams) {\n    try {\n      const signedTxns = [];\n      const txns = this.makeTx(execParams, txParams);\n      for (const transaction of txns) {\n        const signedTransaction = await this.signTx(transaction);\n        signedTxns.push(signedTransaction);\n      }\n      return signedTxns;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Sends signedTransaction and waits for the response\n   * @param transactions array of signedTransaction objects.\n   * @param rounds number of rounds to wait for response\n   * @returns TxnReceipt which includes confirmed txn response along with txID\n   */\n  async sendTxAndWait(transactions, rounds) {\n    try {\n      if (transactions.length < 1) {\n        throw new Error(\"No transactions to process\");\n      } else {\n        const Uint8ArraySignedTx = transactions.map(txn => algosdk_1.default.encodeObj(txn));\n        return await this.sendAndWait(Uint8ArraySignedTx, rounds);\n      }\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n}\nexports.MyAlgoWalletSession = MyAlgoWalletSession;","map":{"version":3,"mappings":"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","names":["MyAlgoWalletSession","constructor","walletURL","connector","algodClient","MyAlgoConnect","require","err","connectToMyAlgo","accounts","connect","shouldSelectOneAccount","openManager","addresses","map","account","address","Error","signTransaction","txn","signOptions","toByte","signTransactionGroup","txns","txnsGroup","v","groupID","algosdk_1","computeGroupID","i","length","group","sendAndWait","rawTxns","waitRounds","constants_1","txInfo","sendRawTransaction","do","waitForConfirmation","txId","pendingInfo","txnReceipt","txID","executeTx","execParams","signedTxn","_","entries","push","payFlags","assignGroupID","toBeSignedTxns","index","sign","types_1","LogicSignature","shouldSign","nonLsigTxn","filter","signer","lsig","args","Array","isArray","splice","signLogicSigTransaction","stxn","Uint8ArraySignedTx","blob","confirmedTx","makeTx","txParams","signTx","transaction","signedTx","decodeSignedTransaction","makeAndSignTx","signedTxns","signedTransaction","sendTxAndWait","transactions","rounds","encodeObj","exports"],"sourceRoot":"","sources":["../../src/lib/myalgowallet-mode.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}