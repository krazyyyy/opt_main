{"ast":null,"code":"/* global BigInt */\nimport { AppActions, GlobalStateKeys } from '../constants/constants.js';\nimport { indexerClient } from './algob.config.js';\nconst {\n  types\n} = require('@algo-builder/web');\nconst {\n  getApplicationAddress\n} = require('algosdk');\nconst {\n  readAppGlobalState,\n  tryExecuteTx,\n  getCustodialWallets,\n  chunkArray,\n  OptAsaID,\n  OptAppID,\n  getAssetHolding\n} = require('./common.js');\nconst TEN_BILLION = 10000000000000000n;\nexport async function withdraw(web, senderAcc, feeAddress, optAmt, network, adminAddr) {\n  const algoWithdrawAmount = await computeAlgoWithdrawAmtFromOPT(adminAddr, OptAppID(network), OptAsaID(network), optAmt, network); // algoWithdrawAmount will be in microAlgo's\n\n  // withraw ALGO's from custodial wallets \"before\" withdraw. Can be called by anyone\n  await withdrawFromCustodialWallets(web, senderAcc, OptAppID(network), algoWithdrawAmount, network);\n\n  // withdraw ALGO from the contract, submit OPT\n  const withdrawTxGroup = [{\n    type: types.TransactionType.TransferAsset,\n    sign: types.SignType.SecretKey,\n    fromAccountAddr: senderAcc,\n    toAccountAddr: getApplicationAddress(OptAppID(network)),\n    amount: optAmt * 1e6,\n    assetID: OptAsaID(network),\n    payFlags: {\n      totalFee: 1000\n    }\n  }, {\n    type: types.TransactionType.CallApp,\n    sign: types.SignType.SecretKey,\n    fromAccountAddr: senderAcc,\n    appID: OptAppID(network),\n    payFlags: {\n      totalFee: 3000\n    },\n    appArgs: [AppActions.EXCHANGE],\n    foreignAssets: [OptAsaID(network)],\n    accounts: [feeAddress]\n  }];\n  await tryExecuteTx(web, withdrawTxGroup);\n}\n\n/**\n * Computes ALGO amount to withdraw from the custodial wallets, depending on the OPT we\n * will submit, using the current exchange rate.\n */\nexport async function computeAlgoWithdrawAmtFromOPT(adminaddr, optAppID, optASAID, optAmt, network) {\n  var _appGlobalState$get;\n  const appAccAddr = getApplicationAddress(optAppID);\n  const optHoldingOfApp = await getAssetHolding(appAccAddr, optASAID, network);\n  const optAccInfo = await indexerClient(network).lookupAccountByID(appAccAddr).do();\n  const appGlobalState = await readAppGlobalState(adminaddr, optAppID, network);\n  // acc balance + custodial deposit - minBalance\n  const optAppAlgoBalance = optAccInfo.account.amount + ((_appGlobalState$get = appGlobalState.get(GlobalStateKeys.CUSTODIAL_DEPOSIT)) !== null && _appGlobalState$get !== void 0 ? _appGlobalState$get : 0) - 1e6;\n  if (optHoldingOfApp.amount === TEN_BILLION) {\n    return optAmt * 1e6; // 1:1 exchange rate\n  } else {\n    if (TEN_BILLION - BigInt(optHoldingOfApp.amount) === 0) {\n      throw new Error('Please deposit Algos to get OPT.');\n    }\n    // i think instead of * 1e6 we should directly fix at source\n    const amt = BigInt(optAmt * 1e6) * BigInt(optAppAlgoBalance) / (TEN_BILLION - BigInt(optHoldingOfApp.amount));\n    return Math.round(Number(amt));\n  }\n}\n\n/**\n * Find and withdraw from each custodial wallet(s) 10000 ALGO's. Returns if enough wallets\n * are not available to withdraw from (which shouldn't happen).\n * NOTE: withdraw amount is in microAlgos\n */\nasync function withdrawFromCustodialWallets(web, senderAcc, optAppID, withdrawAmt, network) {\n  const appAccAddr = getApplicationAddress(optAppID);\n  const optAccInfo = await indexerClient(network).lookupAccountByID(appAccAddr).do();\n  if (optAccInfo.account.amount > withdrawAmt) {\n    return;\n  }\n  const reqWallets = Math.ceil((withdrawAmt - optAccInfo.account.amount) / 10000e6);\n\n  // extract custodial wallets from indexer, from which we will withdraw 10000 ALGO's\n  const custodialWalletsOrig = await getCustodialWallets(optAppID, {\n    deposited: 10000\n  }, network);\n  if (reqWallets !== 0 && custodialWalletsOrig.length < reqWallets) {\n    throw new Error(`Not enough wallets to withdraw from. Required ${reqWallets} but got ${custodialWalletsOrig.length}. Please generate more accounts`);\n  }\n\n  // get only the addresses we need.\n  const custodialWallets = custodialWalletsOrig.slice(0, reqWallets);\n\n  // split whole custodial wallets array into chunks of 4\n  // as max 4 accounts can be passed in a tx group.\n  const txAccountArrays = chunkArray(custodialWallets, 4);\n\n  // after getting wallets, let's construct the transactions\n  const txArray = [];\n  for (let i = 0, j = 0; i < reqWallets; i += 4, j++) {\n    // in each iteration we're funding 4 wallets\n    txArray.push({\n      type: types.TransactionType.CallApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAcc,\n      appID: optAppID,\n      payFlags: {\n        totalFee: 1000 + 1000 * txAccountArrays[j].length\n      },\n      accounts: txAccountArrays[j],\n      appArgs: [AppActions.CUSTODIAL_WITHDRAW]\n    });\n  }\n\n  // finally assemble transactions into groups of 16. Submit each group to network\n  const txGroups = chunkArray(txArray, 16);\n  for (const grp of txGroups) {\n    await tryExecuteTx(web, grp);\n  }\n}","map":{"version":3,"names":["AppActions","GlobalStateKeys","indexerClient","types","require","getApplicationAddress","readAppGlobalState","tryExecuteTx","getCustodialWallets","chunkArray","OptAsaID","OptAppID","getAssetHolding","TEN_BILLION","withdraw","web","senderAcc","feeAddress","optAmt","network","adminAddr","algoWithdrawAmount","computeAlgoWithdrawAmtFromOPT","withdrawFromCustodialWallets","withdrawTxGroup","type","TransactionType","TransferAsset","sign","SignType","SecretKey","fromAccountAddr","toAccountAddr","amount","assetID","payFlags","totalFee","CallApp","appID","appArgs","EXCHANGE","foreignAssets","accounts","adminaddr","optAppID","optASAID","appAccAddr","optHoldingOfApp","optAccInfo","lookupAccountByID","do","appGlobalState","optAppAlgoBalance","account","get","CUSTODIAL_DEPOSIT","BigInt","Error","amt","Math","round","Number","withdrawAmt","reqWallets","ceil","custodialWalletsOrig","deposited","length","custodialWallets","slice","txAccountArrays","txArray","i","j","push","CUSTODIAL_WITHDRAW","txGroups","grp"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/withdraw.js"],"sourcesContent":["/* global BigInt */\nimport {\n    AppActions,\n    GlobalStateKeys\n} from '../constants/constants.js';\nimport { indexerClient } from './algob.config.js';\nconst { types } = require('@algo-builder/web');\nconst { getApplicationAddress } = require('algosdk');\nconst {\n    readAppGlobalState,\n    tryExecuteTx,\n    getCustodialWallets,\n    chunkArray,\n    OptAsaID,\n    OptAppID,\n    getAssetHolding\n} = require('./common.js');\n\nconst TEN_BILLION = 10000000000000000n;\n\nexport async function withdraw(\n    web,\n    senderAcc,\n    feeAddress,\n    optAmt,\n    network,\n    adminAddr\n) {\n    const algoWithdrawAmount = await computeAlgoWithdrawAmtFromOPT(\n        adminAddr,\n        OptAppID(network),\n        OptAsaID(network),\n        optAmt,\n        network\n    ); // algoWithdrawAmount will be in microAlgo's\n\n    // withraw ALGO's from custodial wallets \"before\" withdraw. Can be called by anyone\n    await withdrawFromCustodialWallets(\n        web,\n        senderAcc,\n        OptAppID(network),\n        algoWithdrawAmount,\n        network\n    );\n\n    // withdraw ALGO from the contract, submit OPT\n    const withdrawTxGroup = [\n        {\n            type: types.TransactionType.TransferAsset,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            toAccountAddr: getApplicationAddress(OptAppID(network)),\n            amount: optAmt * 1e6,\n            assetID: OptAsaID(network),\n            payFlags: { totalFee: 1000 }\n        },\n        {\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 3000 },\n            appArgs: [AppActions.EXCHANGE],\n            foreignAssets: [OptAsaID(network)],\n            accounts: [feeAddress]\n        }\n    ];\n    await tryExecuteTx(web, withdrawTxGroup);\n}\n\n/**\n * Computes ALGO amount to withdraw from the custodial wallets, depending on the OPT we\n * will submit, using the current exchange rate.\n */\nexport async function computeAlgoWithdrawAmtFromOPT(\n    adminaddr,\n    optAppID,\n    optASAID,\n    optAmt,\n    network\n) {\n    const appAccAddr = getApplicationAddress(optAppID);\n    const optHoldingOfApp = await getAssetHolding(\n        appAccAddr,\n        optASAID,\n        network\n    );\n\n    const optAccInfo = await indexerClient(network)\n        .lookupAccountByID(appAccAddr)\n        .do();\n\n    const appGlobalState = await readAppGlobalState(\n        adminaddr,\n        optAppID,\n        network\n    );\n    // acc balance + custodial deposit - minBalance\n    const optAppAlgoBalance =\n        optAccInfo.account.amount +\n        (appGlobalState.get(GlobalStateKeys.CUSTODIAL_DEPOSIT) ?? 0) -\n        1e6;\n    if (optHoldingOfApp.amount === TEN_BILLION) {\n        return optAmt * 1e6; // 1:1 exchange rate\n    } else {\n        if (TEN_BILLION - BigInt(optHoldingOfApp.amount) === 0) {\n            throw new Error('Please deposit Algos to get OPT.');\n        }\n        // i think instead of * 1e6 we should directly fix at source\n        const amt =\n            (BigInt(optAmt * 1e6) * (BigInt(optAppAlgoBalance))) /\n            (TEN_BILLION - BigInt(optHoldingOfApp.amount));\n        return Math.round(Number(amt));\n    }\n}\n\n/**\n * Find and withdraw from each custodial wallet(s) 10000 ALGO's. Returns if enough wallets\n * are not available to withdraw from (which shouldn't happen).\n * NOTE: withdraw amount is in microAlgos\n */\nasync function withdrawFromCustodialWallets(\n    web,\n    senderAcc,\n    optAppID,\n    withdrawAmt,\n    network\n) {\n    const appAccAddr = getApplicationAddress(optAppID);\n    const optAccInfo = await indexerClient(network)\n        .lookupAccountByID(appAccAddr)\n        .do();\n    if (optAccInfo.account.amount > withdrawAmt) {\n        return;\n    }\n\n    const reqWallets = Math.ceil(\n        (withdrawAmt - optAccInfo.account.amount) / 10000e6\n    );\n\n    // extract custodial wallets from indexer, from which we will withdraw 10000 ALGO's\n    const custodialWalletsOrig = await getCustodialWallets(\n        optAppID,\n        {\n            deposited: 10000\n        },\n        network\n    );\n\n    if (reqWallets !== 0 && custodialWalletsOrig.length < reqWallets) {\n        throw new Error(\n            `Not enough wallets to withdraw from. Required ${reqWallets} but got ${custodialWalletsOrig.length}. Please generate more accounts`\n        );\n    }\n\n    // get only the addresses we need.\n    const custodialWallets = custodialWalletsOrig.slice(0, reqWallets);\n\n    // split whole custodial wallets array into chunks of 4\n    // as max 4 accounts can be passed in a tx group.\n    const txAccountArrays = chunkArray(custodialWallets, 4);\n\n    // after getting wallets, let's construct the transactions\n    const txArray = [];\n    for (let i = 0, j = 0; i < reqWallets; i += 4, j++) {\n        // in each iteration we're funding 4 wallets\n        txArray.push({\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            appID: optAppID,\n            payFlags: { totalFee: 1000 + (1000 * txAccountArrays[j].length) },\n            accounts: txAccountArrays[j],\n            appArgs: [AppActions.CUSTODIAL_WITHDRAW]\n        });\n    }\n\n    // finally assemble transactions into groups of 16. Submit each group to network\n    const txGroups = chunkArray(txArray, 16);\n    for (const grp of txGroups) {\n        await tryExecuteTx(web, grp);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}