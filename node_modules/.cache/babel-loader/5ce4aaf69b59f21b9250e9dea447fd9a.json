{"ast":null,"code":"import { types } from '@algo-builder/web';\nimport { AppActions } from '../constants/constants.js';\nconst {\n  tryExecuteTx,\n  getCustodialWallets,\n  chunkArray,\n  OptAppID\n} = require('./common.js');\n\n/**\n * Find and registers each custodial wallets (which weren't registered before) for algorand governance.\n */\n// `af/gov1:j{\"com\":5}`;\nexport async function registerByCustodialWallets(web, memo, network, adminAddr, governanceAddr) {\n  // extract custodial wallets from indexer, which we will fund\n  const custodialWallets = await getCustodialWallets(OptAppID(network), {\n    registered: false\n  }, network, adminAddr, 200);\n\n  // split whole custodial wallets array into chunks of 3\n  // as max 4 accounts can be passed in a tx group and we need\n  // the last one as the governance address\n  const txAccountArrays = chunkArray(custodialWallets, 3);\n\n  // after getting wallets, let's construct the transactions\n  const txArray = [];\n  for (let i = 0, j = 0; i < custodialWallets.length; i += 3, j++) {\n    // in each iteration we're funding 4 wallets\n    txArray.push({\n      type: types.TransactionType.CallApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: adminAddr,\n      appID: OptAppID(network),\n      payFlags: {\n        totalFee: 1000 + 1000 * txAccountArrays[j].length\n      },\n      accounts: [...txAccountArrays[j], governanceAddr],\n      // append gov address\n      appArgs: [AppActions.REGISTER_CUSTODIAL_WALLETS, `addr:${governanceAddr}`, `str:${memo}`]\n    });\n  }\n\n  // finally assemble transactions into groups of 16. Submit each group to network\n  const txGroups = chunkArray(txArray, 16);\n  for (const grp of txGroups) {\n    await tryExecuteTx(web, grp);\n  }\n}","map":{"version":3,"names":["types","AppActions","tryExecuteTx","getCustodialWallets","chunkArray","OptAppID","require","registerByCustodialWallets","web","memo","network","adminAddr","governanceAddr","custodialWallets","registered","txAccountArrays","txArray","i","j","length","push","type","TransactionType","CallApp","sign","SignType","SecretKey","fromAccountAddr","appID","payFlags","totalFee","accounts","appArgs","REGISTER_CUSTODIAL_WALLETS","txGroups","grp"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/register.js"],"sourcesContent":["import { types } from '@algo-builder/web';\nimport { AppActions } from '../constants/constants.js';\nconst {\n    tryExecuteTx,\n    getCustodialWallets,\n    chunkArray,\n    OptAppID\n} = require('./common.js');\n\n/**\n * Find and registers each custodial wallets (which weren't registered before) for algorand governance.\n */\n// `af/gov1:j{\"com\":5}`;\nexport async function registerByCustodialWallets(\n    web,\n    memo,\n    network,\n    adminAddr,\n    governanceAddr\n) {\n    // extract custodial wallets from indexer, which we will fund\n    const custodialWallets = await getCustodialWallets(\n        OptAppID(network),\n        {\n            registered: false\n        },\n        network,\n        adminAddr,\n        200\n    );\n\n    // split whole custodial wallets array into chunks of 3\n    // as max 4 accounts can be passed in a tx group and we need\n    // the last one as the governance address\n    const txAccountArrays = chunkArray(custodialWallets, 3);\n\n    // after getting wallets, let's construct the transactions\n    const txArray = [];\n    for (let i = 0, j = 0; i < custodialWallets.length; i += 3, j++) {\n        // in each iteration we're funding 4 wallets\n        txArray.push({\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: adminAddr,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 1000 + 1000 * txAccountArrays[j].length },\n            accounts: [...txAccountArrays[j], governanceAddr], // append gov address\n            appArgs: [\n                AppActions.REGISTER_CUSTODIAL_WALLETS,\n                `addr:${governanceAddr}`,\n                `str:${memo}`\n            ]\n        });\n    }\n\n    // finally assemble transactions into groups of 16. Submit each group to network\n    const txGroups = chunkArray(txArray, 16);\n    for (const grp of txGroups) {\n        await tryExecuteTx(web, grp);\n    }\n}\n"],"mappings":"AAAA,SAASA,KAAK,QAAQ,mBAAmB;AACzC,SAASC,UAAU,QAAQ,2BAA2B;AACtD,MAAM;EACFC,YAAY;EACZC,mBAAmB;EACnBC,UAAU;EACVC;AACJ,CAAC,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAE1B;AACA;AACA;AACA;AACA,OAAO,eAAeC,0BAA0B,CAC5CC,GAAG,EACHC,IAAI,EACJC,OAAO,EACPC,SAAS,EACTC,cAAc,EAChB;EACE;EACA,MAAMC,gBAAgB,GAAG,MAAMV,mBAAmB,CAC9CE,QAAQ,CAACK,OAAO,CAAC,EACjB;IACII,UAAU,EAAE;EAChB,CAAC,EACDJ,OAAO,EACPC,SAAS,EACT,GAAG,CACN;;EAED;EACA;EACA;EACA,MAAMI,eAAe,GAAGX,UAAU,CAACS,gBAAgB,EAAE,CAAC,CAAC;;EAEvD;EACA,MAAMG,OAAO,GAAG,EAAE;EAClB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAG,CAAC,EAAED,CAAC,GAAGJ,gBAAgB,CAACM,MAAM,EAAEF,CAAC,IAAI,CAAC,EAAEC,CAAC,EAAE,EAAE;IAC7D;IACAF,OAAO,CAACI,IAAI,CAAC;MACTC,IAAI,EAAErB,KAAK,CAACsB,eAAe,CAACC,OAAO;MACnCC,IAAI,EAAExB,KAAK,CAACyB,QAAQ,CAACC,SAAS;MAC9BC,eAAe,EAAEhB,SAAS;MAC1BiB,KAAK,EAAEvB,QAAQ,CAACK,OAAO,CAAC;MACxBmB,QAAQ,EAAE;QAAEC,QAAQ,EAAE,IAAI,GAAG,IAAI,GAAGf,eAAe,CAACG,CAAC,CAAC,CAACC;MAAO,CAAC;MAC/DY,QAAQ,EAAE,CAAC,GAAGhB,eAAe,CAACG,CAAC,CAAC,EAAEN,cAAc,CAAC;MAAE;MACnDoB,OAAO,EAAE,CACL/B,UAAU,CAACgC,0BAA0B,EACpC,QAAOrB,cAAe,EAAC,EACvB,OAAMH,IAAK,EAAC;IAErB,CAAC,CAAC;EACN;;EAEA;EACA,MAAMyB,QAAQ,GAAG9B,UAAU,CAACY,OAAO,EAAE,EAAE,CAAC;EACxC,KAAK,MAAMmB,GAAG,IAAID,QAAQ,EAAE;IACxB,MAAMhC,YAAY,CAACM,GAAG,EAAE2B,GAAG,CAAC;EAChC;AACJ"},"metadata":{},"sourceType":"module"}