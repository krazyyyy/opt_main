{"ast":null,"code":"/* global BigInt */\n\nimport { ACCOUNT_MIN_BALANCE, AppActions, GlobalStateKeys, TEN_BILLION } from '../constants/constants.js';\nimport { indexerClient } from './algob.config.js';\nconst {\n  types\n} = require('@algo-builder/web');\nconst {\n  tryExecuteTx,\n  getCustodialWallets,\n  chunkArray,\n  OptAsaID,\n  OptAppID,\n  readAppGlobalState,\n  getAssetHolding,\n  isApplicationOpted\n} = require('./common.js');\nconst {\n  getApplicationAddress\n} = require('algosdk');\nexport async function expectedOPTAmount(algoAmt, network, adminAddr) {\n  var _appGlobalState$get, _appGlobalState$get2, _appGlobalState$get3, _appGlobalState$get4;\n  // console.log(encodeForSigning(OptAppID(network)))\n  // console.log(getApplicationAddress())\n  const appAccountInfo = await indexerClient(network).lookupAccountByID(getApplicationAddress(OptAppID(network))).do();\n  console.log(\"here1\");\n  const appOPTHolding = await getAssetHolding(getApplicationAddress(OptAppID(network)), OptAsaID(network), network);\n  const appGlobalState = await readAppGlobalState(adminAddr, OptAppID(network), network);\n\n  // during first governance period, simply return the algoAmt\n  const governanceNonce = (_appGlobalState$get = appGlobalState.get(GlobalStateKeys.GOVERNANCE_NONCE)) !== null && _appGlobalState$get !== void 0 ? _appGlobalState$get : 0;\n  if (governanceNonce <= 1) {\n    return algoAmt / 1e6;\n  }\n  const globalCustodialDeposit = (_appGlobalState$get2 = appGlobalState.get(GlobalStateKeys.CUSTODIAL_DEPOSIT)) !== null && _appGlobalState$get2 !== void 0 ? _appGlobalState$get2 : 0;\n\n  /*\n  Below is the dynamic exchange rate - but since we're keeping the exchange rate static\n  for each period now, we're going to use the static exchange rate (for each respective period)\n   const num =\n      BigInt(algoAmt) *\n      ((TEN_BILLION - BigInt(appOPTHolding.amount)) / 1000000n);\n  const den =\n      BigInt(appAccountInfo.account.amount) +\n      BigInt(globalCustodialDeposit) -\n      BigInt(ACCOUNT_MIN_BALANCE);\n  */\n\n  const num = BigInt(algoAmt) * BigInt((_appGlobalState$get3 = appGlobalState.get(GlobalStateKeys.GLOBAL_TOTAL_OPT_DISPERSED_AT_GOVERNANCE)) !== null && _appGlobalState$get3 !== void 0 ? _appGlobalState$get3 : 0);\n  const den = BigInt((_appGlobalState$get4 = appGlobalState.get(GlobalStateKeys.GLOBAL_APP_BALANCE_AT_GOVERNANCE)) !== null && _appGlobalState$get4 !== void 0 ? _appGlobalState$get4 : 0);\n  if (num === 0n) {\n    return 0;\n  }\n  const expectedAmt = Number(num / den) / 1e6;\n  return expectedAmt;\n}\nexport async function deposit(web, senderAcc, algoAmt, network, adminAddr) {\n  console.log(network);\n  let n = OptAsaID(network);\n  console.log(n);\n  const userASAHolding = await getAssetHolding(senderAcc, OptAsaID(network), network);\n  const isAppOpted = await isApplicationOpted(senderAcc, OptAppID(network), network);\n  if (!isAppOpted) {\n    const optInAppParams = {\n      type: types.TransactionType.OptInToApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAcc,\n      appID: OptAppID(network),\n      payFlags: {\n        totalFee: 1000\n      }\n    };\n    await tryExecuteTx(web, optInAppParams);\n  }\n\n  // opt in to optimum ASA first (so that sender can receive OPT)\n  if (userASAHolding === undefined) {\n    const optInASAParams = {\n      type: types.TransactionType.OptInASA,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAcc,\n      assetID: OptAsaID(network),\n      payFlags: {\n        totalFee: 1000\n      }\n    };\n    await tryExecuteTx(web, optInASAParams);\n  }\n\n  // deposit ALGO to the contract, receive OPT\n  const depositTxGroup = [{\n    type: types.TransactionType.TransferAlgo,\n    sign: types.SignType.SecretKey,\n    fromAccountAddr: senderAcc,\n    toAccountAddr: getApplicationAddress(OptAppID(network)),\n    amountMicroAlgos: algoAmt,\n    payFlags: {\n      totalFee: 1000\n    }\n  }, {\n    type: types.TransactionType.CallApp,\n    sign: types.SignType.SecretKey,\n    fromAccountAddr: senderAcc,\n    appID: OptAppID(network),\n    payFlags: {\n      totalFee: 2000\n    },\n    appArgs: [AppActions.EXCHANGE],\n    foreignAssets: [OptAsaID(network)]\n  }];\n  await tryExecuteTx(web, depositTxGroup);\n}\n\n/**\n * Find and fund custodial wallets with 10000 ALGO increments. Returns if enough wallets\n * are not available.\n * NOTE: deposit amount is in microAlgos\n */\nexport async function fundCustodialWallets(web, senderAcc, optAppID, depositAmt, network) {\n  // extract custodial wallets from indexer, which we will fund\n  const custodialWalletsOrig = await getCustodialWallets(optAppID, {\n    deposited: 0\n  }, network);\n\n  // TODO: ask about remainder amt (atm we just leave it in the optimum app)\n  // const reqWallets = depositAmt/10000 + (depositAmt % 10000 !== 0 ? 1 : 0);\n\n  const reqWallets = Math.round(depositAmt / 10000e6);\n  if (custodialWalletsOrig.length < reqWallets) {\n    throw new Error(`Not enough wallets to fund. Required ${reqWallets} but got ${custodialWalletsOrig.length}. Please generate more accounts`);\n  }\n\n  // get only the addresses we need.\n  const custodialWallets = custodialWalletsOrig.slice(0, reqWallets);\n\n  // split whole custodial wallets array into chunks of 4\n  // as max 4 accounts can be passed in a tx group.\n  const txAccountArrays = chunkArray(custodialWallets, 4);\n\n  // after getting wallets, let's construct the transactions\n  const txArray = [];\n  for (let i = 0, j = 0; i < reqWallets; i += 4, j++) {\n    // in each iteration we're funding 4 wallets\n    txArray.push({\n      type: types.TransactionType.CallApp,\n      sign: types.SignType.SecretKey,\n      fromAccountAddr: senderAcc,\n      // addr\n      appID: optAppID,\n      payFlags: {\n        totalFee: 1000 + 1000 * txAccountArrays[j].length\n      },\n      accounts: txAccountArrays[j],\n      appArgs: [AppActions.CUSTODIAL_DEPOSIT]\n    });\n  }\n\n  // finally assemble transactions into groups of 16. Submit each group to network\n  const txGroups = chunkArray(txArray, 16);\n  for (const grp of txGroups) {\n    await tryExecuteTx(web, grp);\n  }\n}","map":{"version":3,"names":["ACCOUNT_MIN_BALANCE","AppActions","GlobalStateKeys","TEN_BILLION","indexerClient","types","require","tryExecuteTx","getCustodialWallets","chunkArray","OptAsaID","OptAppID","readAppGlobalState","getAssetHolding","isApplicationOpted","getApplicationAddress","expectedOPTAmount","algoAmt","network","adminAddr","appAccountInfo","lookupAccountByID","do","console","log","appOPTHolding","appGlobalState","governanceNonce","get","GOVERNANCE_NONCE","globalCustodialDeposit","CUSTODIAL_DEPOSIT","num","BigInt","GLOBAL_TOTAL_OPT_DISPERSED_AT_GOVERNANCE","den","GLOBAL_APP_BALANCE_AT_GOVERNANCE","expectedAmt","Number","deposit","web","senderAcc","n","userASAHolding","isAppOpted","optInAppParams","type","TransactionType","OptInToApp","sign","SignType","SecretKey","fromAccountAddr","appID","payFlags","totalFee","undefined","optInASAParams","OptInASA","assetID","depositTxGroup","TransferAlgo","toAccountAddr","amountMicroAlgos","CallApp","appArgs","EXCHANGE","foreignAssets","fundCustodialWallets","optAppID","depositAmt","custodialWalletsOrig","deposited","reqWallets","Math","round","length","Error","custodialWallets","slice","txAccountArrays","txArray","i","j","push","accounts","txGroups","grp"],"sources":["C:/Users/user/Desktop/Optimum-Staking-main/Optimum-Staking-main/frontend/src/utils/deposit.js"],"sourcesContent":["/* global BigInt */\n\nimport {\n    ACCOUNT_MIN_BALANCE,\n    AppActions,\n    GlobalStateKeys,\n    TEN_BILLION\n} from '../constants/constants.js';\nimport { indexerClient } from './algob.config.js';\nconst { types } = require('@algo-builder/web');\nconst {\n    tryExecuteTx,\n    getCustodialWallets,\n    chunkArray,\n    OptAsaID,\n    OptAppID,\n    readAppGlobalState,\n    getAssetHolding,\n    isApplicationOpted\n} = require('./common.js');\nconst { getApplicationAddress } = require('algosdk');\n\nexport async function expectedOPTAmount(algoAmt, network, adminAddr) {\n    // console.log(encodeForSigning(OptAppID(network)))\n    // console.log(getApplicationAddress())\n    const appAccountInfo = await indexerClient(network)\n    .lookupAccountByID(getApplicationAddress(OptAppID(network)))\n    .do();\n    \n    console.log(\"here1\")\n    const appOPTHolding = await getAssetHolding(\n        getApplicationAddress(OptAppID(network)),\n        OptAsaID(network),\n        network\n    );\n\n    const appGlobalState = await readAppGlobalState(\n        adminAddr,\n        OptAppID(network),\n        network\n    );\n\n    // during first governance period, simply return the algoAmt\n    const governanceNonce =\n        appGlobalState.get(GlobalStateKeys.GOVERNANCE_NONCE) ?? 0;\n    if (governanceNonce <= 1) {\n        return algoAmt / 1e6;\n    }\n\n    const globalCustodialDeposit =\n        appGlobalState.get(GlobalStateKeys.CUSTODIAL_DEPOSIT) ?? 0;\n\n    /*\n    Below is the dynamic exchange rate - but since we're keeping the exchange rate static\n    for each period now, we're going to use the static exchange rate (for each respective period)\n\n    const num =\n        BigInt(algoAmt) *\n        ((TEN_BILLION - BigInt(appOPTHolding.amount)) / 1000000n);\n    const den =\n        BigInt(appAccountInfo.account.amount) +\n        BigInt(globalCustodialDeposit) -\n        BigInt(ACCOUNT_MIN_BALANCE);\n    */\n\n    const num =\n        BigInt(algoAmt) *\n        (BigInt(appGlobalState.get(GlobalStateKeys.GLOBAL_TOTAL_OPT_DISPERSED_AT_GOVERNANCE) ?? 0));\n    \n    const den = BigInt(appGlobalState.get(GlobalStateKeys.GLOBAL_APP_BALANCE_AT_GOVERNANCE) ?? 0);\n\n    if (num === 0n) {\n        return 0;\n    }\n\n    const expectedAmt = Number(num / den) / 1e6;\n    return expectedAmt;\n}\n\nexport async function deposit(web, senderAcc, algoAmt, network, adminAddr) {\n    console.log(network)\n    let n = OptAsaID(network) \n    console.log(n)\n    const userASAHolding = await getAssetHolding(\n        senderAcc,\n        OptAsaID(network),\n        network\n    );\n\n    const isAppOpted = await isApplicationOpted(\n        senderAcc,\n        OptAppID(network),\n        network\n    );\n\n    if (!isAppOpted) {\n        const optInAppParams = {\n            type: types.TransactionType.OptInToApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 1000 }\n        };\n        await tryExecuteTx(web, optInAppParams);\n    }\n\n    // opt in to optimum ASA first (so that sender can receive OPT)\n    if (userASAHolding === undefined) {\n        const optInASAParams = {\n            type: types.TransactionType.OptInASA,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            assetID: OptAsaID(network),\n            payFlags: { totalFee: 1000 }\n        };\n        await tryExecuteTx(web, optInASAParams);\n    }\n\n    // deposit ALGO to the contract, receive OPT\n    const depositTxGroup = [\n        {\n            type: types.TransactionType.TransferAlgo,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            toAccountAddr: getApplicationAddress(OptAppID(network)),\n            amountMicroAlgos: algoAmt,\n            payFlags: { totalFee: 1000 }\n        },\n        {\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc,\n            appID: OptAppID(network),\n            payFlags: { totalFee: 2000 },\n            appArgs: [AppActions.EXCHANGE],\n            foreignAssets: [OptAsaID(network)]\n        }\n    ];\n    await tryExecuteTx(web, depositTxGroup);\n}\n\n/**\n * Find and fund custodial wallets with 10000 ALGO increments. Returns if enough wallets\n * are not available.\n * NOTE: deposit amount is in microAlgos\n */\nexport async function fundCustodialWallets(\n    web,\n    senderAcc,\n    optAppID,\n    depositAmt,\n    network\n) {\n    // extract custodial wallets from indexer, which we will fund\n    const custodialWalletsOrig = await getCustodialWallets(\n        optAppID,\n        {\n            deposited: 0\n        },\n        network\n    );\n\n    // TODO: ask about remainder amt (atm we just leave it in the optimum app)\n    // const reqWallets = depositAmt/10000 + (depositAmt % 10000 !== 0 ? 1 : 0);\n\n    const reqWallets = Math.round(depositAmt / 10000e6);\n    if (custodialWalletsOrig.length < reqWallets) {\n        throw new Error(\n            `Not enough wallets to fund. Required ${reqWallets} but got ${custodialWalletsOrig.length}. Please generate more accounts`\n        );\n    }\n\n    // get only the addresses we need.\n    const custodialWallets = custodialWalletsOrig.slice(0, reqWallets);\n\n    // split whole custodial wallets array into chunks of 4\n    // as max 4 accounts can be passed in a tx group.\n    const txAccountArrays = chunkArray(custodialWallets, 4);\n\n    // after getting wallets, let's construct the transactions\n    const txArray = [];\n    for (let i = 0, j = 0; i < reqWallets; i += 4, j++) {\n        // in each iteration we're funding 4 wallets\n        txArray.push({\n            type: types.TransactionType.CallApp,\n            sign: types.SignType.SecretKey,\n            fromAccountAddr: senderAcc, // addr\n            appID: optAppID,\n            payFlags: { totalFee: 1000 + 1000 * txAccountArrays[j].length },\n            accounts: txAccountArrays[j],\n            appArgs: [AppActions.CUSTODIAL_DEPOSIT]\n        });\n    }\n\n    // finally assemble transactions into groups of 16. Submit each group to network\n    const txGroups = chunkArray(txArray, 16);\n    for (const grp of txGroups) {\n        await tryExecuteTx(web, grp);\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}