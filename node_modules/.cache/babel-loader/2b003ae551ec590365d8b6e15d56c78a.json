{"ast":null,"code":"import base32 from 'hi-base32';\nimport * as nacl from '../nacl/naclWrappers';\nimport * as utils from '../utils/utils';\nimport { encodeUint64 } from './uint64';\nconst ALGORAND_ADDRESS_BYTE_LENGTH = 36;\nconst ALGORAND_CHECKSUM_BYTE_LENGTH = 4;\nconst ALGORAND_ADDRESS_LENGTH = 58;\nexport const ALGORAND_ZERO_ADDRESS_STRING = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ';\n// Convert \"MultisigAddr\" UTF-8 to byte array\nconst MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([77, 117, 108, 116, 105, 115, 105, 103, 65, 100, 100, 114]);\nconst APP_ID_PREFIX = Buffer.from('appID');\nexport const MALFORMED_ADDRESS_ERROR_MSG = 'address seems to be malformed';\nexport const CHECKSUM_ADDRESS_ERROR_MSG = 'wrong checksum for address';\nexport const INVALID_MSIG_VERSION_ERROR_MSG = 'invalid multisig version';\nexport const INVALID_MSIG_THRESHOLD_ERROR_MSG = 'bad multisig threshold';\nexport const INVALID_MSIG_PK_ERROR_MSG = 'bad multisig public key - wrong length';\nexport const UNEXPECTED_PK_LEN_ERROR_MSG = 'nacl public key length is not 32 bytes';\n/**\n * decodeAddress takes an Algorand address in string form and decodes it into a Uint8Array.\n * @param address - an Algorand address with checksum.\n * @returns the decoded form of the address's public key and checksum\n */\nexport function decodeAddress(address) {\n  if (typeof address !== 'string' || address.length !== ALGORAND_ADDRESS_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n  // try to decode\n  const decoded = base32.decode.asBytes(address.toString());\n  // Sanity check\n  if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH) throw new Error(MALFORMED_ADDRESS_ERROR_MSG);\n  // Find publickey and checksum\n  const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));\n  const cs = new Uint8Array(decoded.slice(nacl.PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));\n  // Compute checksum\n  const checksum = nacl.genericHash(pk).slice(nacl.HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.HASH_BYTES_LENGTH);\n  // Check if the checksum and the address are equal\n  if (!utils.arrayEqual(checksum, cs)) throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);\n  return {\n    publicKey: pk,\n    checksum: cs\n  };\n}\n/**\n * isValidAddress checks if a string is a valid Algorand address.\n * @param address - an Algorand address with checksum.\n * @returns true if valid, false otherwise\n */\nexport function isValidAddress(address) {\n  // Try to decode\n  try {\n    decodeAddress(address);\n  } catch (e) {\n    return false;\n  }\n  return true;\n}\n/**\n * encodeAddress takes an Algorand address as a Uint8Array and encodes it into a string with checksum.\n * @param address - a raw Algorand address\n * @returns the address and checksum encoded as a string.\n */\nexport function encodeAddress(address) {\n  // compute checksum\n  const checksum = nacl.genericHash(address).slice(nacl.PUBLIC_KEY_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, nacl.PUBLIC_KEY_LENGTH);\n  const addr = base32.encode(utils.concatArrays(address, checksum));\n  return addr.toString().slice(0, ALGORAND_ADDRESS_LENGTH); // removing the extra '===='\n}\n/**\n * fromMultisigPreImg takes multisig parameters and returns a 32 byte typed array public key,\n * representing an address that identifies the \"exact group, version, and public keys\" that are required for signing.\n * Hash(\"MultisigAddr\" || version uint8 || threshold uint8 || PK1 || PK2 || ...)\n * Encoding this output yields a human readable address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - array of typed array public keys\n */\nexport function fromMultisigPreImg(_ref) {\n  let {\n    version,\n    threshold,\n    pks\n  } = _ref;\n  if (version !== 1 || version > 255 || version < 0) {\n    // ^ a tad redundant, but in case in the future version != 1, still check for uint8\n    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);\n  }\n  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {\n    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);\n  }\n  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;\n  if (pkLen !== nacl.PUBLIC_KEY_LENGTH) {\n    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);\n  }\n  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);\n  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);\n  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);\n  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);\n  for (let i = 0; i < pks.length; i++) {\n    if (pks[i].length !== pkLen) {\n      throw new Error(INVALID_MSIG_PK_ERROR_MSG);\n    }\n    merged.set(pks[i], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i * pkLen);\n  }\n  return new Uint8Array(nacl.genericHash(merged));\n}\n/**\n * fromMultisigPreImgAddrs takes multisig parameters and returns a human readable Algorand address.\n * This is equivalent to fromMultisigPreImg, but interfaces with encoded addresses.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - array of encoded addresses\n */\nexport function fromMultisigPreImgAddrs(_ref2) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref2;\n  const pks = addrs.map(addr => decodeAddress(addr).publicKey);\n  return encodeAddress(fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  }));\n}\n/**\n * Get the escrow address of an application.\n * @param appID - The ID of the application.\n * @returns The address corresponding to that application's escrow account.\n */\nexport function getApplicationAddress(appID) {\n  const toBeSigned = utils.concatArrays(APP_ID_PREFIX, encodeUint64(appID));\n  const hash = nacl.genericHash(toBeSigned);\n  return encodeAddress(new Uint8Array(hash));\n}","map":{"version":3,"mappings":"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","names":["base32","nacl","utils","encodeUint64","ALGORAND_ADDRESS_BYTE_LENGTH","ALGORAND_CHECKSUM_BYTE_LENGTH","ALGORAND_ADDRESS_LENGTH","ALGORAND_ZERO_ADDRESS_STRING","MULTISIG_PREIMG2ADDR_PREFIX","Uint8Array","APP_ID_PREFIX","Buffer","from","MALFORMED_ADDRESS_ERROR_MSG","CHECKSUM_ADDRESS_ERROR_MSG","INVALID_MSIG_VERSION_ERROR_MSG","INVALID_MSIG_THRESHOLD_ERROR_MSG","INVALID_MSIG_PK_ERROR_MSG","UNEXPECTED_PK_LEN_ERROR_MSG","decodeAddress","address","length","Error","decoded","decode","asBytes","toString","pk","slice","cs","PUBLIC_KEY_LENGTH","checksum","genericHash","HASH_BYTES_LENGTH","arrayEqual","publicKey","isValidAddress","e","encodeAddress","addr","encode","concatArrays","fromMultisigPreImg","version","threshold","pks","pkLen","merged","set","i","fromMultisigPreImgAddrs","addrs","map","getApplicationAddress","appID","toBeSigned","hash"],"sourceRoot":"","sources":["../../../src/encoding/address.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}