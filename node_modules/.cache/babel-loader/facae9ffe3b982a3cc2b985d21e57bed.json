{"ast":null,"code":"const address = require('../encoding/address');\nconst makeTxn = require('../makeTxn');\nconst group = require('../group');\nconst logic = require('../logic/logic');\nconst logicSig = require('../logicsig');\nconst nacl = require('../nacl/naclWrappers');\nconst templates = require('./templates');\nconst utils = require('../utils/utils');\nclass LimitOrder {\n  /**\n   * MakeLimitOrder allows a user to exchange some number of assets for some number of algos.\n   * Fund the contract with some number of Algos to limit the maximum number of\n   * Algos you're willing to trade for some other asset.\n   *\n   * Works on two cases:\n   * * trading Algos for some other asset\n   * * closing out Algos back to the originator after a timeout\n   *\n   * trade case, a 2 transaction group:\n   * gtxn[0] (this txn) Algos from Me to Other\n   * gtxn[1] asset from Other to Me\n   *\n   * We want to get _at least_ some amount of the other asset per our Algos\n   * gtxn[1].AssetAmount / gtxn[0].Amount >= N / D\n   * ===\n   * gtxn[1].AssetAmount * D >= gtxn[0].Amount * N\n   *\n   * close-out case:\n   * txn alone, close out value after timeout\n   *\n   * @deprecated This class will be removed in v2.\n   *\n   * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {int} assetid: the ID of the transferred asset\n   * @param {int} ratn: exchange rate (N asset per D Algos, or better)\n   * @param {int} ratd: exchange rate (N asset per D Algos, or better)\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minTrade: the minimum amount (of Algos) to be traded away\n   * @param {int} maxFee: maximum fee used by the limit order transaction\n   * @returns {LimitOrder}\n   */\n  constructor(owner, assetid, ratn, ratd, expiryRound, minTrade, maxFee) {\n    // don't need to validate owner - it will be validated by template.insert\n    if (!Number.isSafeInteger(assetid) || assetid < 0) throw Error('assetid must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(ratn) || ratn < 0) throw Error('ratn must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(ratd) || ratd < 0) throw Error('ratd must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error('expiryRound must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(minTrade) || minTrade < 0) throw Error('minTrade must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error('maxFee must be a positive number and smaller than 2^53-1');\n    const referenceProgramB64 = 'ASAKAAEFAgYEBwgJCiYBIP68oLsUSlpOp7Q4pGgayA5soQW8tgf8VlMlyVaV9qITMRYiEjEQIxIQMQEkDhAyBCMSQABVMgQlEjEIIQQNEDEJMgMSEDMBECEFEhAzAREhBhIQMwEUKBIQMwETMgMSEDMBEiEHHTUCNQExCCEIHTUENQM0ATQDDUAAJDQBNAMSNAI0BA8QQAAWADEJKBIxAiEJDRAxBzIDEhAxCCISEBA=';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [5 /* minTrade */, 7 /* assetID */, 9 /* ratd */, 10 /* ratn */, 11 /* expiryRound */, 12 /* owner */, 16];\n    const injectionVector = [maxFee, minTrade, assetid, ratd, ratn, expiryRound, owner];\n    const injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS];\n    const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    const lsig = new logicSig.LogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n    this.owner = owner;\n    this.assetid = assetid;\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n  getAddress() {\n    return this.address;\n  }\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n *\n * @deprecated This feature will be removed in v2.\n *\n * @param {Uint8Array} contract: byteform of the contract from the payer\n * @param {int} assetAmount: the amount of assets to be sent\n * @param {int} microAlgoAmount: number of microAlgos to transfer\n * @param {Uint8Array} secretKey: secret key for signing transaction\n * @param {int} fee: the fee per byte to pay in microAlgos\n * @param {int} firstRound: the first round on which these txns will be valid\n * @param {int} lastRound: the last round on which these txns will be valid\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n * the first payment sends money (Algos) from contract to the recipient (we'll call him Buyer), closing the rest of the account to Owner\n * the second payment sends money (the asset) from Buyer to the Owner\n * these transactions will be rejected if they do not meet the restrictions set by the contract\n * @throws error if arguments fail contract validation\n */\nfunction getSwapAssetsTransaction(contract, assetAmount, microAlgoAmount, secretKey, fee, firstRound, lastRound, genesisHash) {\n  const buyerKeyPair = nacl.keyPairFromSecretKey(secretKey);\n  const buyerAddr = address.encodeAddress(buyerKeyPair.publicKey);\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n  let noCloseRemainder;\n  let noAssetRevocationTarget;\n  const contractAssetID = ints[6];\n  const contractOwner = address.encodeAddress(byteArrays[0]);\n  const lsig = logicSig.makeLogicSig(contract, undefined);\n  const contractAddress = lsig.address();\n  const algosForAssets = makeTxn.makePaymentTxn(contractAddress, buyerAddr, fee, microAlgoAmount, noCloseRemainder, firstRound, lastRound, undefined, genesisHash, undefined);\n  const assetsForAlgos = makeTxn.makeAssetTransferTxn(buyerAddr, contractOwner, noCloseRemainder, noAssetRevocationTarget, fee, assetAmount, firstRound, lastRound, undefined, genesisHash, undefined, contractAssetID);\n  const txns = [algosForAssets, assetsForAlgos];\n  const txGroup = group.assignGroupID(txns);\n  const ratd = ints[7];\n  const ratn = ints[8];\n  if (assetAmount * ratd < microAlgoAmount * ratn) {\n    throw new Error(`bad payment ratio, ${assetAmount.toString()}*${ratd.toString()} !>= ${microAlgoAmount.toString()}*${ratn.toString()}`);\n  }\n  const minTrade = ints[4];\n  if (microAlgoAmount < minTrade) {\n    throw new Error(`payment amount ${microAlgoAmount.toString()} less than minimum trade ${minTrade.toString()}`);\n  }\n  const maxFee = ints[2];\n  if (txGroup[0].fee > maxFee) {\n    throw new Error(`final fee of payment transaction ${txGroup[0].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);\n  }\n  if (txGroup[1].fee > maxFee) {\n    throw new Error(`final fee of asset transaction ${txGroup[1].fee.toString()} greater than transaction max fee ${maxFee.toString()}`);\n  }\n  const algosForAssetsSigned = logicSig.signLogicSigTransactionObject(txGroup[0], lsig);\n  const assetsForAlgosSigned = txGroup[1].signTxn(secretKey);\n  return utils.concatArrays(algosForAssetsSigned.blob, assetsForAlgosSigned);\n}\nmodule.exports = {\n  LimitOrder,\n  getSwapAssetsTransaction\n};","map":{"version":3,"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAC9C,MAAMC,OAAO,GAAGD,OAAO,CAAC,YAAY,CAAC;AACrC,MAAME,KAAK,GAAGF,OAAO,CAAC,UAAU,CAAC;AACjC,MAAMG,KAAK,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AACvC,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,aAAa,CAAC;AACvC,MAAMK,IAAI,GAAGL,OAAO,CAAC,sBAAsB,CAAC;AAC5C,MAAMM,SAAS,GAAGN,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMO,KAAK,GAAGP,OAAO,CAAC,gBAAgB,CAAC;AAEvC,MAAMQ,UAAU;EACd;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiCAC,YAAYC,KAAK,EAAEC,OAAO,EAAEC,IAAI,EAAEC,IAAI,EAAEC,WAAW,EAAEC,QAAQ,EAAEC,MAAM;IACnE;IACA,IAAI,CAACC,MAAM,CAACC,aAAa,CAACP,OAAO,CAAC,IAAIA,OAAO,GAAG,CAAC,EAC/C,MAAMQ,KAAK,CAAC,2DAA2D,CAAC;IAC1E,IAAI,CAACF,MAAM,CAACC,aAAa,CAACN,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,EACzC,MAAMO,KAAK,CAAC,wDAAwD,CAAC;IACvE,IAAI,CAACF,MAAM,CAACC,aAAa,CAACL,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,EACzC,MAAMM,KAAK,CAAC,wDAAwD,CAAC;IACvE,IAAI,CAACF,MAAM,CAACC,aAAa,CAACJ,WAAW,CAAC,IAAIA,WAAW,GAAG,CAAC,EACvD,MAAMK,KAAK,CACT,+DAA+D,CAChE;IACH,IAAI,CAACF,MAAM,CAACC,aAAa,CAACH,QAAQ,CAAC,IAAIA,QAAQ,GAAG,CAAC,EACjD,MAAMI,KAAK,CAAC,4DAA4D,CAAC;IAC3E,IAAI,CAACF,MAAM,CAACC,aAAa,CAACF,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,EAC7C,MAAMG,KAAK,CAAC,0DAA0D,CAAC;IAEzE,MAAMC,mBAAmB,GACvB,8OAA8O;IAChP,MAAMC,qBAAqB,GAAGC,MAAM,CAACC,IAAI,CAACH,mBAAmB,EAAE,QAAQ,CAAC;IACxE,MAAMI,gBAAgB,GAAG,CACvB,CAAC,CAAC,gBACF,CAAC,CAAC,eACF,CAAC,CAAC,YACF,EAAE,CAAC,YACH,EAAE,CAAC,mBACH,EAAE,CAAC,aACH,EAAE,CACH;IACD,MAAMC,eAAe,GAAG,CACtBT,MAAM,EACND,QAAQ,EACRJ,OAAO,EACPE,IAAI,EACJD,IAAI,EACJE,WAAW,EACXJ,KAAK,CACN;IACD,MAAMgB,cAAc,GAAG,CACrBpB,SAAS,CAACqB,QAAQ,CAACC,GAAG,EACtBtB,SAAS,CAACqB,QAAQ,CAACC,GAAG,EACtBtB,SAAS,CAACqB,QAAQ,CAACC,GAAG,EACtBtB,SAAS,CAACqB,QAAQ,CAACC,GAAG,EACtBtB,SAAS,CAACqB,QAAQ,CAACC,GAAG,EACtBtB,SAAS,CAACqB,QAAQ,CAACC,GAAG,EACtBtB,SAAS,CAACqB,QAAQ,CAACE,OAAO,CAC3B;IACD,MAAMC,aAAa,GAAGxB,SAAS,CAACyB,MAAM,CACpCV,qBAAqB,EACrBG,gBAAgB,EAChBC,eAAe,EACfC,cAAc,CACf;IACD,IAAI,CAACM,YAAY,GAAGF,aAAa;IACjC,MAAMG,IAAI,GAAG,IAAI7B,QAAQ,CAAC8B,QAAQ,CAACJ,aAAa,EAAEK,SAAS,CAAC;IAC5D,IAAI,CAACpC,OAAO,GAAGkC,IAAI,CAAClC,OAAO,EAAE;IAC7B,IAAI,CAACW,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,OAAO,GAAGA,OAAO;EACxB;EAEA;;;;EAIAyB,UAAU;IACR,OAAO,IAAI,CAACJ,YAAY;EAC1B;EAEA;;;;EAIAK,UAAU;IACR,OAAO,IAAI,CAACtC,OAAO;EACrB;;AAGF;;;;;;;;;;;;;;;;;;;AAmBA,SAASuC,wBAAwB,CAC/BC,QAAQ,EACRC,WAAW,EACXC,eAAe,EACfC,SAAS,EACTC,GAAG,EACHC,UAAU,EACVC,SAAS,EACTC,WAAW;EAEX,MAAMC,YAAY,GAAG1C,IAAI,CAAC2C,oBAAoB,CAACN,SAAS,CAAC;EACzD,MAAMO,SAAS,GAAGlD,OAAO,CAACmD,aAAa,CAACH,YAAY,CAACI,SAAS,CAAC;EAC/D,MAAMC,cAAc,GAAGjD,KAAK,CAACkD,WAAW,CAACd,QAAQ,EAAEJ,SAAS,CAAC;EAC7D,MAAMmB,IAAI,GAAGF,cAAc,CAAC,CAAC,CAAC;EAC9B,MAAMG,UAAU,GAAGH,cAAc,CAAC,CAAC,CAAC;EAEpC,IAAII,gBAAgB;EACpB,IAAIC,uBAAuB;EAC3B,MAAMC,eAAe,GAAGJ,IAAI,CAAC,CAAC,CAAC;EAC/B,MAAMK,aAAa,GAAG5D,OAAO,CAACmD,aAAa,CAACK,UAAU,CAAC,CAAC,CAAC,CAAC;EAC1D,MAAMtB,IAAI,GAAG7B,QAAQ,CAACwD,YAAY,CAACrB,QAAQ,EAAEJ,SAAS,CAAC;EACvD,MAAM0B,eAAe,GAAG5B,IAAI,CAAClC,OAAO,EAAE;EACtC,MAAM+D,cAAc,GAAG7D,OAAO,CAAC8D,cAAc,CAC3CF,eAAe,EACfZ,SAAS,EACTN,GAAG,EACHF,eAAe,EACfe,gBAAgB,EAChBZ,UAAU,EACVC,SAAS,EACTV,SAAS,EACTW,WAAW,EACXX,SAAS,CACV;EACD,MAAM6B,cAAc,GAAG/D,OAAO,CAACgE,oBAAoB,CACjDhB,SAAS,EACTU,aAAa,EACbH,gBAAgB,EAChBC,uBAAuB,EACvBd,GAAG,EACHH,WAAW,EACXI,UAAU,EACVC,SAAS,EACTV,SAAS,EACTW,WAAW,EACXX,SAAS,EACTuB,eAAe,CAChB;EACD,MAAMQ,IAAI,GAAG,CAACJ,cAAc,EAAEE,cAAc,CAAC;EAC7C,MAAMG,OAAO,GAAGjE,KAAK,CAACkE,aAAa,CAACF,IAAI,CAAC;EAEzC,MAAMrD,IAAI,GAAGyC,IAAI,CAAC,CAAC,CAAC;EACpB,MAAM1C,IAAI,GAAG0C,IAAI,CAAC,CAAC,CAAC;EACpB,IAAId,WAAW,GAAG3B,IAAI,GAAG4B,eAAe,GAAG7B,IAAI,EAAE;IAC/C,MAAM,IAAIO,KAAK,CACb,sBAAsBqB,WAAW,CAAC6B,QAAQ,EAAE,IAAIxD,IAAI,CAACwD,QAAQ,EAAE,QAAQ5B,eAAe,CAAC4B,QAAQ,EAAE,IAAIzD,IAAI,CAACyD,QAAQ,EAAE,EAAE,CACvH;;EAEH,MAAMtD,QAAQ,GAAGuC,IAAI,CAAC,CAAC,CAAC;EACxB,IAAIb,eAAe,GAAG1B,QAAQ,EAAE;IAC9B,MAAM,IAAII,KAAK,CACb,kBAAkBsB,eAAe,CAAC4B,QAAQ,EAAE,4BAA4BtD,QAAQ,CAACsD,QAAQ,EAAE,EAAE,CAC9F;;EAEH,MAAMrD,MAAM,GAAGsC,IAAI,CAAC,CAAC,CAAC;EACtB,IAAIa,OAAO,CAAC,CAAC,CAAC,CAACxB,GAAG,GAAG3B,MAAM,EAAE;IAC3B,MAAM,IAAIG,KAAK,CACb,oCAAoCgD,OAAO,CAAC,CAAC,CAAC,CAACxB,GAAG,CAAC0B,QAAQ,EAAE,qCAAqCrD,MAAM,CAACqD,QAAQ,EAAE,EAAE,CACtH;;EAEH,IAAIF,OAAO,CAAC,CAAC,CAAC,CAACxB,GAAG,GAAG3B,MAAM,EAAE;IAC3B,MAAM,IAAIG,KAAK,CACb,kCAAkCgD,OAAO,CAAC,CAAC,CAAC,CAACxB,GAAG,CAAC0B,QAAQ,EAAE,qCAAqCrD,MAAM,CAACqD,QAAQ,EAAE,EAAE,CACpH;;EAGH,MAAMC,oBAAoB,GAAGlE,QAAQ,CAACmE,6BAA6B,CACjEJ,OAAO,CAAC,CAAC,CAAC,EACVlC,IAAI,CACL;EACD,MAAMuC,oBAAoB,GAAGL,OAAO,CAAC,CAAC,CAAC,CAACM,OAAO,CAAC/B,SAAS,CAAC;EAC1D,OAAOnC,KAAK,CAACmE,YAAY,CAACJ,oBAAoB,CAACK,IAAI,EAAEH,oBAAoB,CAAC;AAC5E;AAEAI,MAAM,CAACC,OAAO,GAAG;EACfrE,UAAU;EACV8B;CACD","names":["address","require","makeTxn","group","logic","logicSig","nacl","templates","utils","LimitOrder","constructor","owner","assetid","ratn","ratd","expiryRound","minTrade","maxFee","Number","isSafeInteger","Error","referenceProgramB64","referenceProgramBytes","Buffer","from","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","injectedBytes","inject","programBytes","lsig","LogicSig","undefined","getProgram","getAddress","getSwapAssetsTransaction","contract","assetAmount","microAlgoAmount","secretKey","fee","firstRound","lastRound","genesisHash","buyerKeyPair","keyPairFromSecretKey","buyerAddr","encodeAddress","publicKey","programOutputs","readProgram","ints","byteArrays","noCloseRemainder","noAssetRevocationTarget","contractAssetID","contractOwner","makeLogicSig","contractAddress","algosForAssets","makePaymentTxn","assetsForAlgos","makeAssetTransferTxn","txns","txGroup","assignGroupID","toString","algosForAssetsSigned","signLogicSigTransactionObject","assetsForAlgosSigned","signTxn","concatArrays","blob","module","exports"],"sourceRoot":"","sources":["../../../src/logicTemplates/limitorder.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}