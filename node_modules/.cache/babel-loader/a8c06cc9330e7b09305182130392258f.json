{"ast":null,"code":"/* eslint-disable no-bitwise */\n/* eslint-disable no-use-before-define */\n/* eslint-disable class-methods-use-this */\n/**\n    //ABI-Types: uint<N>: An N-bit unsigned integer (8 <= N <= 512 and N % 8 = 0).\n    // | byte (alias for uint8)\n    // | ufixed <N> x <M> (8 <= N <= 512, N % 8 = 0, and 0 < M <= 160)\n    // | bool\n    // | address (alias for byte[32])\n    // | <type> [<N>]\n    // | <type> []\n    // | string\n    // | (T1, ..., Tn)\n*/\nimport { encodeAddress, decodeAddress } from '../encoding/address';\nimport { bigIntToBytes, bytesToBigInt } from '../encoding/bigint';\nimport { concatArrays } from '../utils/utils';\nexport const MAX_LEN = 2 ** 16 - 1;\nexport const ADDR_BYTE_SIZE = 32;\nexport const SINGLE_BYTE_SIZE = 1;\nexport const SINGLE_BOOL_SIZE = 1;\nexport const LENGTH_ENCODE_BYTE_SIZE = 2;\nconst staticArrayRegexp = /^([a-z\\d[\\](),]+)\\[(0|[1-9][\\d]*)]$/;\nconst ufixedRegexp = /^ufixed([1-9][\\d]*)x([1-9][\\d]*)$/;\nexport class ABIType {\n  // De-serializes the ABI type from a string using the ABI specs\n  static from(str) {\n    if (str.endsWith('[]')) {\n      const arrayArgType = ABIType.from(str.slice(0, str.length - 2));\n      return new ABIArrayDynamicType(arrayArgType);\n    }\n    if (str.endsWith(']')) {\n      const stringMatches = str.match(staticArrayRegexp);\n      // Match the string itself, array element type, then array length\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed static array string: ${str}`);\n      }\n      // Parse static array using regex\n      const arrayLengthStr = stringMatches[2];\n      const arrayLength = parseInt(arrayLengthStr, 10);\n      if (arrayLength > MAX_LEN) {\n        throw new Error(`array length exceeds limit ${MAX_LEN}`);\n      }\n      // Parse the array element type\n      const arrayType = ABIType.from(stringMatches[1]);\n      return new ABIArrayStaticType(arrayType, arrayLength);\n    }\n    if (str.startsWith('uint')) {\n      // Checks if the parsed number contains only digits, no whitespaces\n      const digitsOnly = string => [...string].every(c => '0123456789'.includes(c));\n      const typeSizeStr = str.slice(4, str.length);\n      if (!digitsOnly(typeSizeStr)) {\n        throw new Error(`malformed uint string: ${typeSizeStr}`);\n      }\n      const typeSize = parseInt(typeSizeStr, 10);\n      if (typeSize > MAX_LEN) {\n        throw new Error(`malformed uint string: ${typeSize}`);\n      }\n      return new ABIUintType(typeSize);\n    }\n    if (str === 'byte') {\n      return new ABIByteType();\n    }\n    if (str.startsWith('ufixed')) {\n      const stringMatches = str.match(ufixedRegexp);\n      if (stringMatches.length !== 3) {\n        throw new Error(`malformed ufixed type: ${str}`);\n      }\n      const ufixedSize = parseInt(stringMatches[1], 10);\n      const ufixedPrecision = parseInt(stringMatches[2], 10);\n      return new ABIUfixedType(ufixedSize, ufixedPrecision);\n    }\n    if (str === 'bool') {\n      return new ABIBoolType();\n    }\n    if (str === 'address') {\n      return new ABIAddressType();\n    }\n    if (str === 'string') {\n      return new ABIStringType();\n    }\n    if (str.length >= 2 && str[0] === '(' && str[str.length - 1] === ')') {\n      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));\n      const tupleTypes = [];\n      for (let i = 0; i < tupleContent.length; i++) {\n        const ti = ABIType.from(tupleContent[i]);\n        tupleTypes.push(ti);\n      }\n      return new ABITupleType(tupleTypes);\n    }\n    throw new Error(`cannot convert a string ${str} to an ABI type`);\n  }\n}\nexport class ABIUintType extends ABIType {\n  constructor(size) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported uint type bitSize: ${size}`);\n    }\n    this.bitSize = size;\n  }\n  toString() {\n    return `uint${this.bitSize}`;\n  }\n  equals(other) {\n    return other instanceof ABIUintType && this.bitSize === other.bitSize;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return this.bitSize / 8;\n  }\n  encode(value) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(`${value} should be converted into a BigInt before it is encoded`);\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n  decode(byteString) {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a uint${this.bitSize}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\nexport class ABIUfixedType extends ABIType {\n  constructor(size, denominator) {\n    super();\n    if (size % 8 !== 0 || size < 8 || size > 512) {\n      throw new Error(`unsupported ufixed type bitSize: ${size}`);\n    }\n    if (denominator > 160 || denominator < 1) {\n      throw new Error(`unsupported ufixed type precision: ${denominator}`);\n    }\n    this.bitSize = size;\n    this.precision = denominator;\n  }\n  toString() {\n    return `ufixed${this.bitSize}x${this.precision}`;\n  }\n  equals(other) {\n    return other instanceof ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return this.bitSize / 8;\n  }\n  encode(value) {\n    if (typeof value !== 'bigint' && typeof value !== 'number') {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {\n      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);\n    }\n    if (typeof value === 'number' && !Number.isSafeInteger(value)) {\n      throw new Error(`${value} should be converted into a BigInt before it is encoded`);\n    }\n    return bigIntToBytes(value, this.bitSize / 8);\n  }\n  decode(byteString) {\n    if (byteString.length !== this.bitSize / 8) {\n      throw new Error(`byte string must correspond to a ${this.toString()}`);\n    }\n    return bytesToBigInt(byteString);\n  }\n}\nexport class ABIAddressType extends ABIType {\n  toString() {\n    return 'address';\n  }\n  equals(other) {\n    return other instanceof ABIAddressType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return ADDR_BYTE_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (typeof value === 'string') {\n      const decodedAddress = decodeAddress(value);\n      return decodedAddress.publicKey;\n    }\n    // Return the address if it is already in bytes\n    if (value.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return value;\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 32) {\n      throw new Error(`byte string must be 32 bytes long for an address`);\n    }\n    return encodeAddress(byteString);\n  }\n}\nexport class ABIBoolType extends ABIType {\n  toString() {\n    return 'bool';\n  }\n  equals(other) {\n    return other instanceof ABIBoolType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return SINGLE_BOOL_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'boolean') {\n      throw new Error(`Cannot encode value as bool: ${value}`);\n    }\n    if (value) {\n      return new Uint8Array([128]);\n    }\n    return new Uint8Array([0]);\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`bool string must be 1 byte long`);\n    }\n    const value = byteString[0];\n    if (value === 128) {\n      return true;\n    }\n    if (value === 0) {\n      return false;\n    }\n    throw new Error(`boolean could not be decoded from the byte string`);\n  }\n}\nexport class ABIByteType extends ABIType {\n  toString() {\n    return 'byte';\n  }\n  equals(other) {\n    return other instanceof ABIByteType;\n  }\n  isDynamic() {\n    return false;\n  }\n  byteLen() {\n    return SINGLE_BYTE_SIZE;\n  }\n  encode(value) {\n    if (typeof value !== 'number' && typeof value !== 'bigint') {\n      throw new Error(`Cannot encode value as byte: ${value}`);\n    }\n    if (typeof value === 'bigint') {\n      // eslint-disable-next-line no-param-reassign\n      value = Number(value);\n    }\n    if (value < 0 || value > 255) {\n      throw new Error(`${value} cannot be encoded into a byte`);\n    }\n    return new Uint8Array([value]);\n  }\n  decode(byteString) {\n    if (byteString.byteLength !== 1) {\n      throw new Error(`byte string must be 1 byte long`);\n    }\n    return byteString[0];\n  }\n}\nexport class ABIStringType extends ABIType {\n  toString() {\n    return 'string';\n  }\n  equals(other) {\n    return other instanceof ABIStringType;\n  }\n  isDynamic() {\n    return true;\n  }\n  byteLen() {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n  encode(value) {\n    if (typeof value !== 'string' && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as string: ${value}`);\n    }\n    const encodedBytes = Buffer.from(value);\n    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);\n    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);\n    mergedBytes.set(encodedLength);\n    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);\n    return mergedBytes;\n  }\n  decode(byteString) {\n    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {\n      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);\n    }\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);\n    if (byteLength !== byteValue.length) {\n      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);\n    }\n    return Buffer.from(byteValue).toString('utf-8');\n  }\n}\nexport class ABIArrayStaticType extends ABIType {\n  constructor(argType, arrayLength) {\n    super();\n    if (arrayLength < 0) {\n      throw new Error(`static array must have a non negative length: ${arrayLength}`);\n    }\n    this.childType = argType;\n    this.staticLength = arrayLength;\n  }\n  toString() {\n    return `${this.childType.toString()}[${this.staticLength}]`;\n  }\n  equals(other) {\n    return other instanceof ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);\n  }\n  isDynamic() {\n    return this.childType.isDynamic();\n  }\n  byteLen() {\n    if (this.childType.constructor === ABIBoolType) {\n      return Math.ceil(this.staticLength / 8);\n    }\n    return this.staticLength * this.childType.byteLen();\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    if (value.length !== this.staticLength) {\n      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);\n    }\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.encode(value);\n  }\n  decode(byteString) {\n    const convertedTuple = this.toABITupleType();\n    return convertedTuple.decode(byteString);\n  }\n  toABITupleType() {\n    return new ABITupleType(Array(this.staticLength).fill(this.childType));\n  }\n}\nexport class ABIArrayDynamicType extends ABIType {\n  constructor(argType) {\n    super();\n    this.childType = argType;\n  }\n  toString() {\n    return `${this.childType.toString()}[]`;\n  }\n  equals(other) {\n    return other instanceof ABIArrayDynamicType && this.childType.equals(other.childType);\n  }\n  isDynamic() {\n    return true;\n  }\n  byteLen() {\n    throw new Error(`${this.toString()} is a dynamic type`);\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const convertedTuple = this.toABITupleType(value.length);\n    const encodedTuple = convertedTuple.encode(value);\n    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);\n    const mergedBytes = concatArrays(encodedLength, encodedTuple);\n    return mergedBytes;\n  }\n  decode(byteString) {\n    const buf = Buffer.from(byteString);\n    const byteLength = buf.readUIntBE(0, LENGTH_ENCODE_BYTE_SIZE);\n    const convertedTuple = this.toABITupleType(byteLength);\n    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));\n  }\n  toABITupleType(length) {\n    return new ABITupleType(Array(length).fill(this.childType));\n  }\n}\nexport class ABITupleType extends ABIType {\n  constructor(argTypes) {\n    super();\n    if (argTypes.length >= MAX_LEN) {\n      throw new Error('tuple type child type number larger than maximum uint16 error');\n    }\n    this.childTypes = argTypes;\n  }\n  toString() {\n    const typeStrings = [];\n    for (let i = 0; i < this.childTypes.length; i++) {\n      typeStrings[i] = this.childTypes[i].toString();\n    }\n    return `(${typeStrings.join(',')})`;\n  }\n  equals(other) {\n    return other instanceof ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));\n  }\n  isDynamic() {\n    const isDynamic = child => child.isDynamic();\n    return this.childTypes.some(isDynamic);\n  }\n  byteLen() {\n    let size = 0;\n    for (let i = 0; i < this.childTypes.length; i++) {\n      if (this.childTypes[i].constructor === ABIBoolType) {\n        const after = findBoolLR(this.childTypes, i, 1);\n        const boolNum = after + 1;\n        i += after;\n        size += Math.trunc((boolNum + 7) / 8);\n      } else {\n        const childByteSize = this.childTypes[i].byteLen();\n        size += childByteSize;\n      }\n    }\n    return size;\n  }\n  encode(value) {\n    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {\n      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);\n    }\n    const values = Array.from(value);\n    if (value.length > MAX_LEN) {\n      throw new Error('length of tuple array should not exceed a uint16');\n    }\n    const tupleTypes = this.childTypes;\n    const heads = [];\n    const tails = [];\n    const isDynamicIndex = new Map();\n    let i = 0;\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        // Head is not pre-determined for dynamic types; store a placeholder for now\n        isDynamicIndex.set(heads.length, true);\n        heads.push(new Uint8Array([0, 0]));\n        tails.push(tupleType.encode(values[i]));\n      } else {\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(tupleTypes, i, -1);\n          let after = findBoolLR(tupleTypes, i, 1);\n          // Pack bytes to heads and tails\n          if (before % 8 !== 0) {\n            throw new Error('expected before index should have number of bool mod 8 equal 0');\n          }\n          after = Math.min(7, after);\n          const compressedInt = compressMultipleBool(values.slice(i, i + after + 1));\n          heads.push(bigIntToBytes(compressedInt, 1));\n          i += after;\n        } else {\n          const encodedTupleValue = tupleType.encode(values[i]);\n          heads.push(encodedTupleValue);\n        }\n        isDynamicIndex.set(i, false);\n        tails.push(new Uint8Array());\n      }\n      i += 1;\n    }\n    // Adjust head lengths for dynamic types\n    let headLength = 0;\n    for (const headElement of heads) {\n      headLength += headElement.length;\n    }\n    // encode any placeholders for dynamic types\n    let tailLength = 0;\n    for (let j = 0; j < heads.length; j++) {\n      if (isDynamicIndex.get(j)) {\n        const headValue = headLength + tailLength;\n        if (headValue > MAX_LEN) {\n          throw new Error(`byte length of ${headValue} should not exceed a uint16`);\n        }\n        heads[j] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);\n      }\n      tailLength += tails[j].length;\n    }\n    return concatArrays(...heads, ...tails);\n  }\n  decode(byteString) {\n    const tupleTypes = this.childTypes;\n    const dynamicSegments = [];\n    const valuePartition = [];\n    let i = 0;\n    let iterIndex = 0;\n    const buf = Buffer.from(byteString);\n    while (i < tupleTypes.length) {\n      const tupleType = tupleTypes[i];\n      if (tupleType.isDynamic()) {\n        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {\n          throw new Error('dynamic type in tuple is too short to be decoded');\n        }\n        const dynamicIndex = buf.readUIntBE(iterIndex, LENGTH_ENCODE_BYTE_SIZE);\n        if (dynamicSegments.length > 0) {\n          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;\n          // Check that right side of segment is greater than the left side\n          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {\n            throw new Error('dynamic index segment miscalculation: left is greater than right index');\n          }\n        }\n        // Since we do not know where the current dynamic element ends, put a placeholder and update later\n        const seg = {\n          left: dynamicIndex,\n          right: -1\n        };\n        dynamicSegments.push(seg);\n        valuePartition.push(null);\n        iterIndex += LENGTH_ENCODE_BYTE_SIZE;\n      } else {\n        // eslint-disable-next-line no-lonely-if\n        if (tupleType.constructor === ABIBoolType) {\n          const before = findBoolLR(this.childTypes, i, -1);\n          let after = findBoolLR(this.childTypes, i, 1);\n          if (before % 8 !== 0) {\n            throw new Error('expected before bool number mod 8 === 0');\n          }\n          after = Math.min(7, after);\n          // Parse bool in a byte to multiple byte strings\n          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {\n            const boolMask = 0x80 >> boolIndex;\n            if ((byteString[iterIndex] & boolMask) > 0) {\n              valuePartition.push(new Uint8Array([128]));\n            } else {\n              valuePartition.push(new Uint8Array([0]));\n            }\n          }\n          i += after;\n          iterIndex += 1;\n        } else {\n          const currLen = tupleType.byteLen();\n          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));\n          iterIndex += currLen;\n        }\n      }\n      if (i !== tupleTypes.length - 1 && iterIndex >= byteString.length) {\n        throw new Error('input byte not enough to decode');\n      }\n      i += 1;\n    }\n    if (dynamicSegments.length > 0) {\n      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;\n      iterIndex = byteString.length;\n    }\n    if (iterIndex < byteString.length) {\n      throw new Error('input byte not fully consumed');\n    }\n    // Check segment indices are valid\n    // If the dynamic segment are not consecutive and well-ordered, we return error\n    for (let j = 0; j < dynamicSegments.length; j++) {\n      const seg = dynamicSegments[j];\n      if (seg.left > seg.right) {\n        throw new Error('dynamic segment should display a [l, r] space with l <= r');\n      }\n      if (j !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j + 1].left) {\n        throw new Error('dynamic segment should be consecutive');\n      }\n    }\n    // Check dynamic element partitions\n    let segIndex = 0;\n    for (let j = 0; j < tupleTypes.length; j++) {\n      if (tupleTypes[j].isDynamic()) {\n        valuePartition[j] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);\n        segIndex += 1;\n      }\n    }\n    // Decode each tuple element\n    const returnValues = [];\n    for (let j = 0; j < tupleTypes.length; j++) {\n      const valueTi = tupleTypes[j].decode(valuePartition[j]);\n      returnValues.push(valueTi);\n    }\n    return returnValues;\n  }\n  static parseTupleContent(str) {\n    if (str.length === 0) {\n      return [];\n    }\n    if (str.endsWith(',') || str.startsWith(',')) {\n      throw new Error('tuple string should not start with comma');\n    }\n    if (str.includes(',,')) {\n      throw new Error('tuple string should not have consecutive commas');\n    }\n    const tupleStrings = [];\n    let depth = 0;\n    let word = '';\n    for (const char of str) {\n      word += char;\n      if (char === '(') {\n        depth += 1;\n      } else if (char === ')') {\n        depth -= 1;\n      } else if (char === ',') {\n        // If the comma is at depth 0, then append the word as token.\n        if (depth === 0) {\n          tupleStrings.push(word.slice(0, word.length - 1));\n          word = '';\n        }\n      }\n    }\n    if (word.length !== 0) {\n      tupleStrings.push(word);\n    }\n    if (depth !== 0) {\n      throw new Error('tuple string has mismatched parentheses');\n    }\n    return tupleStrings;\n  }\n}\n// compressMultipleBool compresses consecutive bool values into a byte in ABI tuple / array value.\nfunction compressMultipleBool(valueList) {\n  let res = 0;\n  if (valueList.length > 8) {\n    throw new Error('value list passed in should be no greater than length 8');\n  }\n  for (let i = 0; i < valueList.length; i++) {\n    const boolVal = valueList[i];\n    if (typeof boolVal !== 'boolean') {\n      throw new Error('non-boolean values cannot be compressed into a byte');\n    }\n    if (boolVal) {\n      res |= 1 << 7 - i;\n    }\n  }\n  return res;\n}\n// Assume that the current index on the list of type is an ABI bool type.\n// It returns the difference between the current index and the index of the furthest consecutive Bool type.\nfunction findBoolLR(typeList, index, delta) {\n  let until = 0;\n  while (true) {\n    const curr = index + delta * until;\n    if (typeList[curr].constructor === ABIBoolType) {\n      if (curr !== typeList.length - 1 && delta === 1) {\n        until += 1;\n      } else if (curr > 0 && delta === -1) {\n        until += 1;\n      } else {\n        break;\n      }\n    } else {\n      until -= 1;\n      break;\n    }\n  }\n  return until;\n}","map":{"version":3,"mappings":"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","names":["encodeAddress","decodeAddress","bigIntToBytes","bytesToBigInt","concatArrays","MAX_LEN","ADDR_BYTE_SIZE","SINGLE_BYTE_SIZE","SINGLE_BOOL_SIZE","LENGTH_ENCODE_BYTE_SIZE","staticArrayRegexp","ufixedRegexp","ABIType","from","str","endsWith","arrayArgType","slice","length","ABIArrayDynamicType","stringMatches","match","Error","arrayLengthStr","arrayLength","parseInt","arrayType","ABIArrayStaticType","startsWith","digitsOnly","string","every","c","includes","typeSizeStr","typeSize","ABIUintType","ABIByteType","ufixedSize","ufixedPrecision","ABIUfixedType","ABIBoolType","ABIAddressType","ABIStringType","tupleContent","ABITupleType","parseTupleContent","tupleTypes","i","ti","push","constructor","size","bitSize","toString","equals","other","isDynamic","byteLen","encode","value","BigInt","Number","isSafeInteger","decode","byteString","denominator","precision","Uint8Array","decodedAddress","publicKey","byteLength","encodedBytes","Buffer","encodedLength","mergedBytes","set","buf","readUIntBE","byteValue","argType","childType","staticLength","Math","ceil","Array","isArray","convertedTuple","toABITupleType","fill","encodedTuple","childTypes","argTypes","typeStrings","join","child","index","some","after","findBoolLR","boolNum","trunc","childByteSize","values","heads","tails","isDynamicIndex","Map","tupleType","before","min","compressedInt","compressMultipleBool","encodedTupleValue","headLength","headElement","tailLength","j","get","headValue","dynamicSegments","valuePartition","iterIndex","dynamicIndex","right","left","seg","boolIndex","boolMask","currLen","segIndex","returnValues","valueTi","tupleStrings","depth","word","char","valueList","res","boolVal","typeList","delta","until","curr"],"sourceRoot":"","sources":["../../../src/abi/abi_type.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}