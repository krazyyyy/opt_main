{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WallectConnectSession = void 0;\nconst utils_1 = require(\"@json-rpc-tools/utils\");\nconst client_1 = __importDefault(require(\"@walletconnect/client\"));\nconst algorand_walletconnect_qrcode_modal_1 = __importDefault(require(\"algorand-walletconnect-qrcode-modal\"));\nconst algosdk_1 = __importDefault(require(\"algosdk\"));\nconst types_1 = require(\"../types\");\nconst api_1 = require(\"./api\");\nconst constants_1 = require(\"./constants\");\nconst logger_1 = require(\"./logger\");\nconst txn_1 = require(\"./txn\");\nclass WallectConnectSession {\n  constructor(walletURL, connector) {\n    this.algodClient = (0, api_1.algoexplorerAlgod)(walletURL);\n    if (connector) {\n      this.connector = connector;\n    } else {\n      // create new session\n      this.connector = new client_1.default({\n        bridge: \"https://bridge.walletconnect.org\",\n        qrcodeModal: algorand_walletconnect_qrcode_modal_1.default\n      });\n    }\n    // if connection not already established, log message to create one\n    if (!this.connector.connected) {\n      (0, logger_1.warn)(`Connection not established, please use \"this.create()\" to create new session`);\n    }\n    this.wcAccounts = this.connector.accounts;\n  }\n  /**\n   * Create new session\n   * @param force if true, kills an existing session and creates new one.\n   * By default force is false\n   */\n  async create() {\n    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.connector.connected) {\n      if (force) {\n        try {\n          await this.close();\n        } catch (e) {\n          (0, logger_1.error)(\"Can't close walletconnect connection\", e);\n          throw e;\n        }\n      } else {\n        (0, logger_1.warn)(`A session is already active`);\n        return;\n      }\n    }\n    await this.connector.createSession();\n  }\n  /**\n   * Close Connection\n   */\n  async close() {\n    try {\n      await this.connector.killSession();\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * On connect subscription event\n   * @param handler handler callback\n   */\n  onConnect(handler) {\n    try {\n      this.connector.on(\"connect\", (err, payload) => {\n        const {\n          peerId,\n          peerMeta,\n          accounts\n        } = payload.params[0];\n        this.wcAccounts = accounts;\n        handler(err, {\n          peerId,\n          peerMeta,\n          accounts\n        });\n      });\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * onUpdate subscription event\n   * @param handler handler callback\n   */\n  onUpdate(handler) {\n    try {\n      this.connector.on(\"session_update\", (err, payload) => {\n        const {\n          accounts\n        } = payload.params[0];\n        this.wcAccounts = accounts;\n        handler(err, {\n          accounts\n        });\n      });\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * onDisconnect subscription event\n   * @param handler handler callback\n   */\n  onDisconnect(handler) {\n    try {\n      this.connector.on(\"disconnect\", (err, payload) => {\n        const {\n          message\n        } = payload.params[0];\n        handler(err, {\n          message\n        });\n      });\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Sign a single transaction from a wallect connect session\n   * @param txn { SDK transaction object, shouldSign, signers, msig } object\n   * @param message optional message with txn\n   * @returns raw signed txn\n   */\n  async signTransaction(txn, message) {\n    try {\n      const txnInGroup = {\n        txn,\n        shouldSign: true,\n        signers: txn.from\n      };\n      const response = await this.signTransactionGroup([txnInGroup], message);\n      if (response[0] == null) {\n        throw new Error(\"Transaction was returned unsigned\");\n      }\n      return response[0];\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Sign a group of transaction(s) from a wallect connect session\n   * @param txns Array of [{  SDK transaction object, shouldSign, signers, msig }] object\n   * @param message optional message with txn\n   * @returns array of raw signed txns | null. null representes that the txn in array is NOT signed\n   * by wallet user (i.e signable by someone else).\n   * TODO: handle case of multiple signers in group transaction\n   */\n  async signTransactionGroup(txns, message) {\n    try {\n      const walletTxns = txns.map(txn => {\n        const encodedTxn = Buffer.from(algosdk_1.default.encodeUnsignedTransaction(txn.txn)).toString(\"base64\");\n        let signers;\n        if (txn.shouldSign) {\n          if (Array.isArray(txn.signers)) {\n            signers = txn.signers;\n          } else if (txn.signers) {\n            signers = [txn.signers];\n          } else {\n            signers = undefined;\n          }\n        } else {\n          signers = undefined;\n        }\n        return {\n          signers,\n          txn: encodedTxn,\n          message: txn.message,\n          msig: txn.msig\n        };\n      });\n      const requestParams = [walletTxns];\n      (0, logger_1.log)(\"requestParams \", requestParams);\n      if (message) {\n        requestParams.push({\n          message\n        });\n      }\n      const request = (0, utils_1.formatJsonRpcRequest)(constants_1.ALGORAND_SIGN_TRANSACTION_REQUEST, requestParams);\n      const result = await this.connector.sendCustomRequest(request);\n      return result.map(element => {\n        return element ? new Uint8Array(Buffer.from(element, \"base64\")) : null;\n      });\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Send signed transaction to network and wait for confirmation\n   * @param rawTxns Signed Transaction(s)\n   * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10\n   * @returns TxnReceipt which includes confirmed txn response along with txID\n   */\n  async sendAndWait(rawTxns) {\n    let waitRounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.WAIT_ROUNDS;\n    try {\n      const txInfo = await this.algodClient.sendRawTransaction(rawTxns).do();\n      return await this.waitForConfirmation(txInfo.txId, waitRounds);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n  * Function used to wait for a tx confirmation\n  * @param txId txn ID for which confirmation is required\n  * @param waitRounds number of rounds to wait for transaction to be confirmed - default is 10\n  * @returns TxnReceipt which includes confirmed txn response along with txID\n  */\n  async waitForConfirmation(txId) {\n    let waitRounds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : constants_1.WAIT_ROUNDS;\n    try {\n      const pendingInfo = await algosdk_1.default.waitForConfirmation(this.algodClient, txId, waitRounds);\n      if (pendingInfo[\"pool-error\"]) {\n        throw new Error(`Transaction Pool Error: ${pendingInfo[\"pool-error\"]}`);\n      }\n      const txnReceipt = {\n        txID: txId,\n        ...pendingInfo\n      };\n      return txnReceipt;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Execute single transaction or group of transactions (atomic transaction)\n   * @param transactions transaction parameters,  atomic transaction parameters\n   *  or TransactionAndSign object(SDK transaction object and signer parameters)\n   */\n  /* eslint-disable sonarjs/cognitive-complexity */\n  async executeTx(transactions) {\n    try {\n      var _signedTxn;\n      let signedTxn;\n      let txns = [];\n      if (transactions.length > 16) {\n        throw new Error(\"Maximum size of an atomic transfer group is 16\");\n      }\n      if ((0, types_1.isSDKTransactionAndSign)(transactions[0])) {\n        throw new Error(\"We don't support this case now\");\n      }\n      const execParams = transactions;\n      for (const [_, txn] of execParams.entries()) {\n        txns.push((0, txn_1.mkTransaction)(txn, await (0, api_1.mkTxParams)(this.algodClient, txn.payFlags)));\n      }\n      txns = algosdk_1.default.assignGroupID(txns);\n      // with logic signature we set shouldSign to false\n      const toBeSignedTxns = execParams.map((txn, index) => {\n        var _execParams$index$fro;\n        return txn.sign === types_1.SignType.LogicSignature ? {\n          txn: txns[index],\n          shouldSign: false\n        } // logic signature\n        : {\n          txn: txns[index],\n          shouldSign: true,\n          signers: ((_execParams$index$fro = execParams[index].fromAccount) === null || _execParams$index$fro === void 0 ? void 0 : _execParams$index$fro.addr) || execParams[index].fromAccountAddr\n        }; // to be signed\n      });\n      // only shouldSign txn are to be signed\n      const nonLsigTxn = toBeSignedTxns.filter(txn => txn.shouldSign);\n      if (nonLsigTxn.length > 0) {\n        signedTxn = await this.signTransactionGroup(toBeSignedTxns);\n      }\n      // sign smart signature transaction\n      for (const [index, txn] of txns.entries()) {\n        const signer = execParams[index];\n        if (signer.sign === types_1.SignType.LogicSignature) {\n          signer.lsig.lsig.args = signer.args ? signer.args : [];\n          if (!Array.isArray(signedTxn)) signedTxn = [];\n          signedTxn.splice(index, 0, algosdk_1.default.signLogicSigTransaction(txn, signer.lsig).blob);\n        }\n      }\n      // remove null values from signed txns array\n      // TODO: replace null values with \"externally\" signed txns, otherwise\n      // signedtxns with nulls will always fail!\n      signedTxn = (_signedTxn = signedTxn) === null || _signedTxn === void 0 ? void 0 : _signedTxn.filter(stxn => stxn);\n      const confirmedTx = await this.sendAndWait(signedTxn);\n      (0, logger_1.log)(\"confirmedTx: \", confirmedTx);\n      return confirmedTx;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Creates an algosdk.Transaction object based on execParams and suggestedParams\n   * @param execParams execParams containing all txn info\n   * @param txParams suggestedParams object\n   * @returns array of algosdk.Transaction objects\n   */\n  makeTx(execParams, txParams) {\n    try {\n      const txns = [];\n      for (const [_, txn] of execParams.entries()) {\n        txns.push((0, txn_1.mkTransaction)(txn, txParams));\n      }\n      return txns;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Signes a Transaction object using walletconnect\n   * @param transaction transaction object.\n   * @returns SignedTransaction\n   */\n  async signTx(transaction) {\n    try {\n      const txns = [transaction];\n      const txnsToSign = txns.map(txn => {\n        const encodedTxn = Buffer.from(algosdk_1.default.encodeUnsignedTransaction(txn)).toString(\"base64\");\n        return {\n          txn: encodedTxn\n        };\n      });\n      const requestParams = [txnsToSign];\n      const request = (0, utils_1.formatJsonRpcRequest)(constants_1.ALGORAND_SIGN_TRANSACTION_REQUEST, requestParams);\n      const result = await this.connector.sendCustomRequest(request);\n      const decodedResult = result.map(element => {\n        return element ? new Uint8Array(Buffer.from(element, \"base64\")) : null;\n      });\n      if (decodedResult[0] === null) {\n        throw new Error(\"Transaction was returned unsigned\");\n      }\n      return algosdk_1.default.decodeSignedTransaction(decodedResult[0]);\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Creates an algosdk.Transaction object based on execParams and suggestedParams\n   * and signs it using walletconnect\n   * @param execParams execParams containing all txn info\n   * @param txParams suggestedParams object\n   * @returns array of algosdk.SignedTransaction objects\n   */\n  async makeAndSignTx(execParams, txParams) {\n    try {\n      const signedTxns = [];\n      const txns = this.makeTx(execParams, txParams);\n      for (const transaction of txns) {\n        const signedTransaction = await this.signTx(transaction);\n        signedTxns.push(signedTransaction);\n      }\n      return signedTxns;\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n  /**\n   * Sends signedTransaction and waits for the response\n   * @param transactions array of signedTransaction objects.\n   * @param rounds number of rounds to wait for response\n   * @returns TxnReceipt which includes confirmed txn response along with txID\n   */\n  async sendTxAndWait(transactions, rounds) {\n    try {\n      if (transactions.length < 1) {\n        throw Error(\"No transactions to process\");\n      } else {\n        const Uint8ArraySignedTx = transactions.map(txn => algosdk_1.default.encodeObj(txn));\n        return await this.sendAndWait(Uint8ArraySignedTx, rounds);\n      }\n    } catch (err) {\n      (0, logger_1.error)(err);\n      throw err;\n    }\n  }\n}\nexports.WallectConnectSession = WallectConnectSession;","map":{"version":3,"mappings":"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","names":["WallectConnectSession","constructor","walletURL","connector","algodClient","client_1","bridge","qrcodeModal","algorand_walletconnect_qrcode_modal_1","connected","wcAccounts","accounts","create","force","close","e","createSession","killSession","err","onConnect","handler","on","payload","peerId","peerMeta","params","onUpdate","onDisconnect","message","signTransaction","txn","txnInGroup","shouldSign","signers","from","response","signTransactionGroup","Error","txns","walletTxns","map","encodedTxn","Buffer","algosdk_1","encodeUnsignedTransaction","toString","Array","isArray","undefined","msig","requestParams","push","request","constants_1","result","sendCustomRequest","element","Uint8Array","sendAndWait","rawTxns","waitRounds","txInfo","sendRawTransaction","do","waitForConfirmation","txId","pendingInfo","txnReceipt","txID","executeTx","transactions","signedTxn","length","execParams","_","entries","payFlags","assignGroupID","toBeSignedTxns","index","sign","types_1","LogicSignature","fromAccount","addr","fromAccountAddr","nonLsigTxn","filter","signer","lsig","args","splice","signLogicSigTransaction","blob","stxn","confirmedTx","makeTx","txParams","signTx","transaction","txnsToSign","decodedResult","decodeSignedTransaction","makeAndSignTx","signedTxns","signedTransaction","sendTxAndWait","rounds","Uint8ArraySignedTx","encodeObj","exports"],"sourceRoot":"","sources":["../../src/lib/wallectconnect-mode.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}