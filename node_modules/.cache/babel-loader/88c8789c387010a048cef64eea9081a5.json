{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define([], e) : \"object\" == typeof exports ? exports.MessagePack = e() : t.MessagePack = e();\n}(this, function () {\n  return function (t) {\n    var e = {};\n    function r(n) {\n      if (e[n]) return e[n].exports;\n      var i = e[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return t[n].call(i.exports, i, i.exports, r), i.l = !0, i.exports;\n    }\n    return r.m = t, r.c = e, r.d = function (t, e, n) {\n      r.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: n\n      });\n    }, r.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, r.t = function (t, e) {\n      if (1 & e && (t = r(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var n = Object.create(null);\n      if (r.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var i in t) r.d(n, i, function (e) {\n        return t[e];\n      }.bind(null, i));\n      return n;\n    }, r.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return r.d(e, \"a\", e), e;\n    }, r.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, r.p = \"\", r(r.s = 0);\n  }([function (t, e, r) {\n    \"use strict\";\n\n    r.r(e), r.d(e, \"encode\", function () {\n      return T;\n    }), r.d(e, \"decode\", function () {\n      return V;\n    }), r.d(e, \"decodeAsync\", function () {\n      return Y;\n    }), r.d(e, \"decodeArrayStream\", function () {\n      return Z;\n    }), r.d(e, \"decodeStream\", function () {\n      return $;\n    }), r.d(e, \"Decoder\", function () {\n      return O;\n    }), r.d(e, \"Encoder\", function () {\n      return I;\n    }), r.d(e, \"ExtensionCodec\", function () {\n      return S;\n    }), r.d(e, \"ExtData\", function () {\n      return p;\n    }), r.d(e, \"EXT_TIMESTAMP\", function () {\n      return w;\n    }), r.d(e, \"encodeDateToTimeSpec\", function () {\n      return g;\n    }), r.d(e, \"encodeTimeSpecToTimestamp\", function () {\n      return v;\n    }), r.d(e, \"decodeTimestampToTimeSpec\", function () {\n      return U;\n    }), r.d(e, \"encodeTimestampExtension\", function () {\n      return b;\n    }), r.d(e, \"decodeTimestampExtension\", function () {\n      return m;\n    });\n    var n = function (t, e) {\n        var r = \"function\" == typeof Symbol && t[Symbol.iterator];\n        if (!r) return t;\n        var n,\n          i,\n          o = r.call(t),\n          s = [];\n        try {\n          for (; (void 0 === e || e-- > 0) && !(n = o.next()).done;) s.push(n.value);\n        } catch (t) {\n          i = {\n            error: t\n          };\n        } finally {\n          try {\n            n && !n.done && (r = o.return) && r.call(o);\n          } finally {\n            if (i) throw i.error;\n          }\n        }\n        return s;\n      },\n      i = function () {\n        for (var t = [], e = 0; e < arguments.length; e++) t = t.concat(n(arguments[e]));\n        return t;\n      },\n      o = \"undefined\" != typeof process && \"undefined\" != typeof TextEncoder && \"undefined\" != typeof TextDecoder;\n    function s(t) {\n      for (var e = t.length, r = 0, n = 0; n < e;) {\n        var i = t.charCodeAt(n++);\n        if (0 != (4294967168 & i)) {\n          if (0 == (4294965248 & i)) r += 2;else {\n            if (i >= 55296 && i <= 56319 && n < e) {\n              var o = t.charCodeAt(n);\n              56320 == (64512 & o) && (++n, i = ((1023 & i) << 10) + (1023 & o) + 65536);\n            }\n            r += 0 == (4294901760 & i) ? 3 : 4;\n          }\n        } else r++;\n      }\n      return r;\n    }\n    var a = o ? new TextEncoder() : void 0,\n      h = \"undefined\" != typeof process ? 200 : 0;\n    var u = (null == a ? void 0 : a.encodeInto) ? function (t, e, r) {\n      a.encodeInto(t, e.subarray(r));\n    } : function (t, e, r) {\n      e.set(a.encode(t), r);\n    };\n    function c(t, e, r) {\n      for (var n = e, o = n + r, s = [], a = \"\"; n < o;) {\n        var h = t[n++];\n        if (0 == (128 & h)) s.push(h);else if (192 == (224 & h)) {\n          var u = 63 & t[n++];\n          s.push((31 & h) << 6 | u);\n        } else if (224 == (240 & h)) {\n          u = 63 & t[n++];\n          var c = 63 & t[n++];\n          s.push((31 & h) << 12 | u << 6 | c);\n        } else if (240 == (248 & h)) {\n          var f = (7 & h) << 18 | (u = 63 & t[n++]) << 12 | (c = 63 & t[n++]) << 6 | 63 & t[n++];\n          f > 65535 && (f -= 65536, s.push(f >>> 10 & 1023 | 55296), f = 56320 | 1023 & f), s.push(f);\n        } else s.push(h);\n        s.length >= 4096 && (a += String.fromCharCode.apply(String, i(s)), s.length = 0);\n      }\n      return s.length > 0 && (a += String.fromCharCode.apply(String, i(s))), a;\n    }\n    var f = o ? new TextDecoder() : null,\n      l = \"undefined\" != typeof process ? 200 : 0;\n    var p = function (t, e) {\n      this.type = t, this.data = e;\n    };\n    function d(t, e, r) {\n      var n = Math.floor(r / 4294967296),\n        i = r;\n      t.setUint32(e, n), t.setUint32(e + 4, i);\n    }\n    function y(t, e) {\n      var r = t.getInt32(e),\n        n = t.getUint32(e + 4),\n        i = r < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || r === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && 0 === n,\n        o = r > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296);\n      return i || o ? BigInt(r) * BigInt(4294967296) + BigInt(n) : 4294967296 * r + n;\n    }\n    var w = -1;\n    function v(t) {\n      var e = t.sec,\n        r = t.nsec;\n      if (e >= 0 && r >= 0 && e <= 17179869183) {\n        if (0 === r && e <= 4294967295) {\n          var n = new Uint8Array(4);\n          return (s = new DataView(n.buffer)).setUint32(0, e), n;\n        }\n        var i = e / 4294967296,\n          o = 4294967295 & e;\n        n = new Uint8Array(8);\n        return (s = new DataView(n.buffer)).setUint32(0, r << 2 | 3 & i), s.setUint32(4, o), n;\n      }\n      var s;\n      n = new Uint8Array(12);\n      return (s = new DataView(n.buffer)).setUint32(0, r), d(s, 4, e), n;\n    }\n    function g(t) {\n      var e = t.getTime(),\n        r = Math.floor(e / 1e3),\n        n = 1e6 * (e - 1e3 * r),\n        i = Math.floor(n / 1e9);\n      return {\n        sec: r + i,\n        nsec: n - 1e9 * i\n      };\n    }\n    function b(t) {\n      return t instanceof Date ? v(g(t)) : null;\n    }\n    function U(t) {\n      var e = new DataView(t.buffer, t.byteOffset, t.byteLength);\n      switch (t.byteLength) {\n        case 4:\n          return {\n            sec: e.getUint32(0),\n            nsec: 0\n          };\n        case 8:\n          var r = e.getUint32(0);\n          return {\n            sec: 4294967296 * (3 & r) + e.getUint32(4),\n            nsec: r >>> 2\n          };\n        case 12:\n          return {\n            sec: y(e, 4),\n            nsec: e.getUint32(0)\n          };\n        default:\n          throw new Error(\"Unrecognized data size for timestamp: \" + t.length);\n      }\n    }\n    function m(t) {\n      var e = U(t);\n      return new Date(1e3 * e.sec + e.nsec / 1e6);\n    }\n    var x = {\n        type: w,\n        encode: b,\n        decode: m\n      },\n      S = function () {\n        function t() {\n          this.builtInEncoders = [], this.builtInDecoders = [], this.encoders = [], this.decoders = [], this.register(x);\n        }\n        return t.prototype.register = function (t) {\n          var e = t.type,\n            r = t.encode,\n            n = t.decode;\n          if (e >= 0) this.encoders[e] = r, this.decoders[e] = n;else {\n            var i = 1 + e;\n            this.builtInEncoders[i] = r, this.builtInDecoders[i] = n;\n          }\n        }, t.prototype.tryToEncode = function (t, e) {\n          for (var r = 0; r < this.builtInEncoders.length; r++) {\n            if (null != (n = this.builtInEncoders[r])) if (null != (i = n(t, e))) return new p(-1 - r, i);\n          }\n          for (r = 0; r < this.encoders.length; r++) {\n            var n, i;\n            if (null != (n = this.encoders[r])) if (null != (i = n(t, e))) return new p(r, i);\n          }\n          return t instanceof p ? t : null;\n        }, t.prototype.decode = function (t, e, r) {\n          var n = e < 0 ? this.builtInDecoders[-1 - e] : this.decoders[e];\n          return n ? n(t, e, r) : new p(e, t);\n        }, t.defaultCodec = new t(), t;\n      }();\n    function B(t) {\n      return t instanceof Uint8Array ? t : ArrayBuffer.isView(t) ? new Uint8Array(t.buffer, t.byteOffset, t.byteLength) : t instanceof ArrayBuffer ? new Uint8Array(t) : Uint8Array.from(t);\n    }\n    var E = function (t) {\n        var e = \"function\" == typeof Symbol && Symbol.iterator,\n          r = e && t[e],\n          n = 0;\n        if (r) return r.call(t);\n        if (t && \"number\" == typeof t.length) return {\n          next: function () {\n            return t && n >= t.length && (t = void 0), {\n              value: t && t[n++],\n              done: !t\n            };\n          }\n        };\n        throw new TypeError(e ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n      },\n      I = function () {\n        function t(t, e, r, n, i, o, s, a) {\n          void 0 === t && (t = S.defaultCodec), void 0 === e && (e = void 0), void 0 === r && (r = 100), void 0 === n && (n = 2048), void 0 === i && (i = !1), void 0 === o && (o = !1), void 0 === s && (s = !1), void 0 === a && (a = !1), this.extensionCodec = t, this.context = e, this.maxDepth = r, this.initialBufferSize = n, this.sortKeys = i, this.forceFloat32 = o, this.ignoreUndefined = s, this.forceIntegerToFloat = a, this.pos = 0, this.view = new DataView(new ArrayBuffer(this.initialBufferSize)), this.bytes = new Uint8Array(this.view.buffer);\n        }\n        return t.prototype.getUint8Array = function () {\n          return this.bytes.subarray(0, this.pos);\n        }, t.prototype.reinitializeState = function () {\n          this.pos = 0;\n        }, t.prototype.encode = function (t) {\n          return this.reinitializeState(), this.doEncode(t, 1), this.getUint8Array();\n        }, t.prototype.doEncode = function (t, e) {\n          if (e > this.maxDepth) throw new Error(\"Too deep objects in depth \" + e);\n          null == t ? this.encodeNil() : \"boolean\" == typeof t ? this.encodeBoolean(t) : \"number\" == typeof t ? this.encodeNumber(t) : \"string\" == typeof t ? this.encodeString(t) : \"bigint\" == typeof t ? this.encodebigint(t) : this.encodeObject(t, e);\n        }, t.prototype.ensureBufferSizeToWrite = function (t) {\n          var e = this.pos + t;\n          this.view.byteLength < e && this.resizeBuffer(2 * e);\n        }, t.prototype.resizeBuffer = function (t) {\n          var e = new ArrayBuffer(t),\n            r = new Uint8Array(e),\n            n = new DataView(e);\n          r.set(this.bytes), this.view = n, this.bytes = r;\n        }, t.prototype.encodeNil = function () {\n          this.writeU8(192);\n        }, t.prototype.encodeBoolean = function (t) {\n          !1 === t ? this.writeU8(194) : this.writeU8(195);\n        }, t.prototype.encodeNumber = function (t) {\n          Number.isSafeInteger(t) && !this.forceIntegerToFloat ? t >= 0 ? t < 128 ? this.writeU8(t) : t < 256 ? (this.writeU8(204), this.writeU8(t)) : t < 65536 ? (this.writeU8(205), this.writeU16(t)) : t < 4294967296 ? (this.writeU8(206), this.writeU32(t)) : (this.writeU8(207), this.writeU64(t)) : t >= -32 ? this.writeU8(224 | t + 32) : t >= -128 ? (this.writeU8(208), this.writeI8(t)) : t >= -32768 ? (this.writeU8(209), this.writeI16(t)) : t >= -2147483648 ? (this.writeU8(210), this.writeI32(t)) : (this.writeU8(211), this.writeI64(t)) : this.forceFloat32 ? (this.writeU8(202), this.writeF32(t)) : (this.writeU8(203), this.writeF64(t));\n        }, t.prototype.encodebigint = function (t) {\n          t >= BigInt(0) ? t < BigInt(128) ? this.writeU8(Number(t)) : t < BigInt(256) ? (this.writeU8(204), this.writeU8(Number(t))) : t < BigInt(65536) ? (this.writeU8(205), this.writeU16(Number(t))) : t < BigInt(4294967296) ? (this.writeU8(206), this.writeU32(Number(t))) : (this.writeU8(207), this.writeBig64(t)) : t >= BigInt(-32) ? this.writeU8(224 | Number(t) + 32) : t >= BigInt(-128) ? (this.writeU8(208), this.writeI8(Number(t))) : t >= BigInt(-32768) ? (this.writeU8(209), this.writeI16(Number(t))) : t >= BigInt(-2147483648) ? (this.writeU8(210), this.writeI32(Number(t))) : (this.writeU8(211), this.writeBig64(t));\n        }, t.prototype.writeStringHeader = function (t) {\n          if (t < 32) this.writeU8(160 + t);else if (t < 256) this.writeU8(217), this.writeU8(t);else if (t < 65536) this.writeU8(218), this.writeU16(t);else {\n            if (!(t < 4294967296)) throw new Error(\"Too long string: \" + t + \" bytes in UTF-8\");\n            this.writeU8(219), this.writeU32(t);\n          }\n        }, t.prototype.encodeString = function (t) {\n          var e = t.length;\n          if (o && e > h) {\n            var r = s(t);\n            this.ensureBufferSizeToWrite(5 + r), this.writeStringHeader(r), u(t, this.bytes, this.pos), this.pos += r;\n          } else {\n            r = s(t);\n            this.ensureBufferSizeToWrite(5 + r), this.writeStringHeader(r), function (t, e, r) {\n              for (var n = t.length, i = r, o = 0; o < n;) {\n                var s = t.charCodeAt(o++);\n                if (0 != (4294967168 & s)) {\n                  if (0 == (4294965248 & s)) e[i++] = s >> 6 & 31 | 192;else {\n                    if (s >= 55296 && s <= 56319 && o < n) {\n                      var a = t.charCodeAt(o);\n                      56320 == (64512 & a) && (++o, s = ((1023 & s) << 10) + (1023 & a) + 65536);\n                    }\n                    0 == (4294901760 & s) ? (e[i++] = s >> 12 & 15 | 224, e[i++] = s >> 6 & 63 | 128) : (e[i++] = s >> 18 & 7 | 240, e[i++] = s >> 12 & 63 | 128, e[i++] = s >> 6 & 63 | 128);\n                  }\n                  e[i++] = 63 & s | 128;\n                } else e[i++] = s;\n              }\n            }(t, this.bytes, this.pos), this.pos += r;\n          }\n        }, t.prototype.encodeObject = function (t, e) {\n          var r = this.extensionCodec.tryToEncode(t, this.context);\n          if (null != r) this.encodeExtension(r);else if (Array.isArray(t)) this.encodeArray(t, e);else if (ArrayBuffer.isView(t)) this.encodeBinary(t);else {\n            if (\"object\" != typeof t) throw new Error(\"Unrecognized object: \" + Object.prototype.toString.apply(t));\n            this.encodeMap(t, e);\n          }\n        }, t.prototype.encodeBinary = function (t) {\n          var e = t.byteLength;\n          if (e < 256) this.writeU8(196), this.writeU8(e);else if (e < 65536) this.writeU8(197), this.writeU16(e);else {\n            if (!(e < 4294967296)) throw new Error(\"Too large binary: \" + e);\n            this.writeU8(198), this.writeU32(e);\n          }\n          var r = B(t);\n          this.writeU8a(r);\n        }, t.prototype.encodeArray = function (t, e) {\n          var r,\n            n,\n            i = t.length;\n          if (i < 16) this.writeU8(144 + i);else if (i < 65536) this.writeU8(220), this.writeU16(i);else {\n            if (!(i < 4294967296)) throw new Error(\"Too large array: \" + i);\n            this.writeU8(221), this.writeU32(i);\n          }\n          try {\n            for (var o = E(t), s = o.next(); !s.done; s = o.next()) {\n              var a = s.value;\n              this.doEncode(a, e + 1);\n            }\n          } catch (t) {\n            r = {\n              error: t\n            };\n          } finally {\n            try {\n              s && !s.done && (n = o.return) && n.call(o);\n            } finally {\n              if (r) throw r.error;\n            }\n          }\n        }, t.prototype.countWithoutUndefined = function (t, e) {\n          var r,\n            n,\n            i = 0;\n          try {\n            for (var o = E(e), s = o.next(); !s.done; s = o.next()) {\n              void 0 !== t[s.value] && i++;\n            }\n          } catch (t) {\n            r = {\n              error: t\n            };\n          } finally {\n            try {\n              s && !s.done && (n = o.return) && n.call(o);\n            } finally {\n              if (r) throw r.error;\n            }\n          }\n          return i;\n        }, t.prototype.encodeMap = function (t, e) {\n          var r,\n            n,\n            i = Object.keys(t);\n          this.sortKeys && i.sort();\n          var o = this.ignoreUndefined ? this.countWithoutUndefined(t, i) : i.length;\n          if (o < 16) this.writeU8(128 + o);else if (o < 65536) this.writeU8(222), this.writeU16(o);else {\n            if (!(o < 4294967296)) throw new Error(\"Too large map object: \" + o);\n            this.writeU8(223), this.writeU32(o);\n          }\n          try {\n            for (var s = E(i), a = s.next(); !a.done; a = s.next()) {\n              var h = a.value,\n                u = t[h];\n              this.ignoreUndefined && void 0 === u || (this.encodeString(h), this.doEncode(u, e + 1));\n            }\n          } catch (t) {\n            r = {\n              error: t\n            };\n          } finally {\n            try {\n              a && !a.done && (n = s.return) && n.call(s);\n            } finally {\n              if (r) throw r.error;\n            }\n          }\n        }, t.prototype.encodeExtension = function (t) {\n          var e = t.data.length;\n          if (1 === e) this.writeU8(212);else if (2 === e) this.writeU8(213);else if (4 === e) this.writeU8(214);else if (8 === e) this.writeU8(215);else if (16 === e) this.writeU8(216);else if (e < 256) this.writeU8(199), this.writeU8(e);else if (e < 65536) this.writeU8(200), this.writeU16(e);else {\n            if (!(e < 4294967296)) throw new Error(\"Too large extension object: \" + e);\n            this.writeU8(201), this.writeU32(e);\n          }\n          this.writeI8(t.type), this.writeU8a(t.data);\n        }, t.prototype.writeU8 = function (t) {\n          this.ensureBufferSizeToWrite(1), this.view.setUint8(this.pos, t), this.pos++;\n        }, t.prototype.writeU8a = function (t) {\n          var e = t.length;\n          this.ensureBufferSizeToWrite(e), this.bytes.set(t, this.pos), this.pos += e;\n        }, t.prototype.writeI8 = function (t) {\n          this.ensureBufferSizeToWrite(1), this.view.setInt8(this.pos, t), this.pos++;\n        }, t.prototype.writeU16 = function (t) {\n          this.ensureBufferSizeToWrite(2), this.view.setUint16(this.pos, t), this.pos += 2;\n        }, t.prototype.writeI16 = function (t) {\n          this.ensureBufferSizeToWrite(2), this.view.setInt16(this.pos, t), this.pos += 2;\n        }, t.prototype.writeU32 = function (t) {\n          this.ensureBufferSizeToWrite(4), this.view.setUint32(this.pos, t), this.pos += 4;\n        }, t.prototype.writeI32 = function (t) {\n          this.ensureBufferSizeToWrite(4), this.view.setInt32(this.pos, t), this.pos += 4;\n        }, t.prototype.writeF32 = function (t) {\n          this.ensureBufferSizeToWrite(4), this.view.setFloat32(this.pos, t), this.pos += 4;\n        }, t.prototype.writeF64 = function (t) {\n          this.ensureBufferSizeToWrite(8), this.view.setFloat64(this.pos, t), this.pos += 8;\n        }, t.prototype.writeU64 = function (t) {\n          this.ensureBufferSizeToWrite(8), function (t, e, r) {\n            var n = r / 4294967296,\n              i = r;\n            t.setUint32(e, n), t.setUint32(e + 4, i);\n          }(this.view, this.pos, t), this.pos += 8;\n        }, t.prototype.writeI64 = function (t) {\n          this.ensureBufferSizeToWrite(8), d(this.view, this.pos, t), this.pos += 8;\n        }, t.prototype.writeBig64 = function (t) {\n          this.ensureBufferSizeToWrite(8), function (t, e, r) {\n            var n = Number(r / BigInt(4294967296)),\n              i = Number(r % BigInt(4294967296));\n            n < 0 && 0 !== i && (n -= 1), t.setUint32(e, n), t.setUint32(e + 4, i);\n          }(this.view, this.pos, t), this.pos += 8;\n        }, t;\n      }(),\n      A = {};\n    function T(t, e) {\n      return void 0 === e && (e = A), new I(e.extensionCodec, e.context, e.maxDepth, e.initialBufferSize, e.sortKeys, e.forceFloat32, e.ignoreUndefined, e.forceIntegerToFloat).encode(t);\n    }\n    function L(t) {\n      return (t < 0 ? \"-\" : \"\") + \"0x\" + Math.abs(t).toString(16).padStart(2, \"0\");\n    }\n    var M = function () {\n        function t(t, e) {\n          void 0 === t && (t = 16), void 0 === e && (e = 16), this.maxKeyLength = t, this.maxLengthPerKey = e, this.hit = 0, this.miss = 0, this.caches = [];\n          for (var r = 0; r < this.maxKeyLength; r++) this.caches.push([]);\n        }\n        return t.prototype.canBeCached = function (t) {\n          return t > 0 && t <= this.maxKeyLength;\n        }, t.prototype.get = function (t, e, r) {\n          var n = this.caches[r - 1],\n            i = n.length;\n          t: for (var o = 0; o < i; o++) {\n            for (var s = n[o], a = s.bytes, h = 0; h < r; h++) if (a[h] !== t[e + h]) continue t;\n            return s.value;\n          }\n          return null;\n        }, t.prototype.store = function (t, e) {\n          var r = this.caches[t.length - 1],\n            n = {\n              bytes: t,\n              value: e\n            };\n          r.length >= this.maxLengthPerKey ? r[Math.random() * r.length | 0] = n : r.push(n);\n        }, t.prototype.decode = function (t, e, r) {\n          var n = this.get(t, e, r);\n          if (null != n) return this.hit++, n;\n          this.miss++;\n          var i = c(t, e, r),\n            o = Uint8Array.prototype.slice.call(t, e, e + r);\n          return this.store(o, i), i;\n        }, t;\n      }(),\n      k = function (t, e, r, n) {\n        return new (r || (r = Promise))(function (i, o) {\n          function s(t) {\n            try {\n              h(n.next(t));\n            } catch (t) {\n              o(t);\n            }\n          }\n          function a(t) {\n            try {\n              h(n.throw(t));\n            } catch (t) {\n              o(t);\n            }\n          }\n          function h(t) {\n            var e;\n            t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function (t) {\n              t(e);\n            })).then(s, a);\n          }\n          h((n = n.apply(t, e || [])).next());\n        });\n      },\n      z = function (t, e) {\n        var r,\n          n,\n          i,\n          o,\n          s = {\n            label: 0,\n            sent: function () {\n              if (1 & i[0]) throw i[1];\n              return i[1];\n            },\n            trys: [],\n            ops: []\n          };\n        return o = {\n          next: a(0),\n          throw: a(1),\n          return: a(2)\n        }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n          return this;\n        }), o;\n        function a(o) {\n          return function (a) {\n            return function (o) {\n              if (r) throw new TypeError(\"Generator is already executing.\");\n              for (; s;) try {\n                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;\n                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {\n                  case 0:\n                  case 1:\n                    i = o;\n                    break;\n                  case 4:\n                    return s.label++, {\n                      value: o[1],\n                      done: !1\n                    };\n                  case 5:\n                    s.label++, n = o[1], o = [0];\n                    continue;\n                  case 7:\n                    o = s.ops.pop(), s.trys.pop();\n                    continue;\n                  default:\n                    if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n                      s = 0;\n                      continue;\n                    }\n                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {\n                      s.label = o[1];\n                      break;\n                    }\n                    if (6 === o[0] && s.label < i[1]) {\n                      s.label = i[1], i = o;\n                      break;\n                    }\n                    if (i && s.label < i[2]) {\n                      s.label = i[2], s.ops.push(o);\n                      break;\n                    }\n                    i[2] && s.ops.pop(), s.trys.pop();\n                    continue;\n                }\n                o = e.call(t, s);\n              } catch (t) {\n                o = [6, t], n = 0;\n              } finally {\n                r = i = 0;\n              }\n              if (5 & o[0]) throw o[1];\n              return {\n                value: o[0] ? o[1] : void 0,\n                done: !0\n              };\n            }([o, a]);\n          };\n        }\n      },\n      D = function (t) {\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var e,\n          r = t[Symbol.asyncIterator];\n        return r ? r.call(t) : (t = \"function\" == typeof __values ? __values(t) : t[Symbol.iterator](), e = {}, n(\"next\"), n(\"throw\"), n(\"return\"), e[Symbol.asyncIterator] = function () {\n          return this;\n        }, e);\n        function n(r) {\n          e[r] = t[r] && function (e) {\n            return new Promise(function (n, i) {\n              (function (t, e, r, n) {\n                Promise.resolve(n).then(function (e) {\n                  t({\n                    value: e,\n                    done: r\n                  });\n                }, e);\n              })(n, i, (e = t[r](e)).done, e.value);\n            });\n          };\n        }\n      },\n      N = function (t) {\n        return this instanceof N ? (this.v = t, this) : new N(t);\n      },\n      C = function (t, e, r) {\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var n,\n          i = r.apply(t, e || []),\n          o = [];\n        return n = {}, s(\"next\"), s(\"throw\"), s(\"return\"), n[Symbol.asyncIterator] = function () {\n          return this;\n        }, n;\n        function s(t) {\n          i[t] && (n[t] = function (e) {\n            return new Promise(function (r, n) {\n              o.push([t, e, r, n]) > 1 || a(t, e);\n            });\n          });\n        }\n        function a(t, e) {\n          try {\n            (r = i[t](e)).value instanceof N ? Promise.resolve(r.value.v).then(h, u) : c(o[0][2], r);\n          } catch (t) {\n            c(o[0][3], t);\n          }\n          var r;\n        }\n        function h(t) {\n          a(\"next\", t);\n        }\n        function u(t) {\n          a(\"throw\", t);\n        }\n        function c(t, e) {\n          t(e), o.shift(), o.length && a(o[0][0], o[0][1]);\n        }\n      },\n      P = new DataView(new ArrayBuffer(0)),\n      F = new Uint8Array(P.buffer),\n      j = function () {\n        try {\n          P.getInt8(0);\n        } catch (t) {\n          return t.constructor;\n        }\n        throw new Error(\"never reached\");\n      }(),\n      _ = new j(\"Insufficient data\"),\n      W = new M(),\n      O = function () {\n        function t(t, e, r, n, i, o, s, a) {\n          void 0 === t && (t = S.defaultCodec), void 0 === e && (e = void 0), void 0 === r && (r = 4294967295), void 0 === n && (n = 4294967295), void 0 === i && (i = 4294967295), void 0 === o && (o = 4294967295), void 0 === s && (s = 4294967295), void 0 === a && (a = W), this.extensionCodec = t, this.context = e, this.maxStrLength = r, this.maxBinLength = n, this.maxArrayLength = i, this.maxMapLength = o, this.maxExtLength = s, this.keyDecoder = a, this.totalPos = 0, this.pos = 0, this.view = P, this.bytes = F, this.headByte = -1, this.stack = [];\n        }\n        return t.prototype.reinitializeState = function () {\n          this.totalPos = 0, this.headByte = -1;\n        }, t.prototype.setBuffer = function (t) {\n          this.bytes = B(t), this.view = function (t) {\n            if (t instanceof ArrayBuffer) return new DataView(t);\n            var e = B(t);\n            return new DataView(e.buffer, e.byteOffset, e.byteLength);\n          }(this.bytes), this.pos = 0;\n        }, t.prototype.appendBuffer = function (t) {\n          if (-1 !== this.headByte || this.hasRemaining()) {\n            var e = this.bytes.subarray(this.pos),\n              r = B(t),\n              n = new Uint8Array(e.length + r.length);\n            n.set(e), n.set(r, e.length), this.setBuffer(n);\n          } else this.setBuffer(t);\n        }, t.prototype.hasRemaining = function (t) {\n          return void 0 === t && (t = 1), this.view.byteLength - this.pos >= t;\n        }, t.prototype.createNoExtraBytesError = function (t) {\n          var e = this.view,\n            r = this.pos;\n          return new RangeError(\"Extra \" + (e.byteLength - r) + \" of \" + e.byteLength + \" byte(s) found at buffer[\" + t + \"]\");\n        }, t.prototype.decode = function (t) {\n          return this.reinitializeState(), this.setBuffer(t), this.doDecodeSingleSync();\n        }, t.prototype.doDecodeSingleSync = function () {\n          var t = this.doDecodeSync();\n          if (this.hasRemaining()) throw this.createNoExtraBytesError(this.pos);\n          return t;\n        }, t.prototype.decodeAsync = function (t) {\n          var e, r, n, i;\n          return k(this, void 0, void 0, function () {\n            var o, s, a, h, u, c, f, l;\n            return z(this, function (p) {\n              switch (p.label) {\n                case 0:\n                  o = !1, p.label = 1;\n                case 1:\n                  p.trys.push([1, 6, 7, 12]), e = D(t), p.label = 2;\n                case 2:\n                  return [4, e.next()];\n                case 3:\n                  if ((r = p.sent()).done) return [3, 5];\n                  if (a = r.value, o) throw this.createNoExtraBytesError(this.totalPos);\n                  this.appendBuffer(a);\n                  try {\n                    s = this.doDecodeSync(), o = !0;\n                  } catch (t) {\n                    if (!(t instanceof j)) throw t;\n                  }\n                  this.totalPos += this.pos, p.label = 4;\n                case 4:\n                  return [3, 2];\n                case 5:\n                  return [3, 12];\n                case 6:\n                  return h = p.sent(), n = {\n                    error: h\n                  }, [3, 12];\n                case 7:\n                  return p.trys.push([7,, 10, 11]), r && !r.done && (i = e.return) ? [4, i.call(e)] : [3, 9];\n                case 8:\n                  p.sent(), p.label = 9;\n                case 9:\n                  return [3, 11];\n                case 10:\n                  if (n) throw n.error;\n                  return [7];\n                case 11:\n                  return [7];\n                case 12:\n                  if (o) {\n                    if (this.hasRemaining()) throw this.createNoExtraBytesError(this.totalPos);\n                    return [2, s];\n                  }\n                  throw c = (u = this).headByte, f = u.pos, l = u.totalPos, new RangeError(\"Insufficient data in parcing \" + L(c) + \" at \" + l + \" (\" + f + \" in the current buffer)\");\n              }\n            });\n          });\n        }, t.prototype.decodeArrayStream = function (t) {\n          return this.decodeMultiAsync(t, !0);\n        }, t.prototype.decodeStream = function (t) {\n          return this.decodeMultiAsync(t, !1);\n        }, t.prototype.decodeMultiAsync = function (t, e) {\n          return C(this, arguments, function () {\n            var r, n, i, o, s, a, h, u, c;\n            return z(this, function (f) {\n              switch (f.label) {\n                case 0:\n                  r = e, n = -1, f.label = 1;\n                case 1:\n                  f.trys.push([1, 13, 14, 19]), i = D(t), f.label = 2;\n                case 2:\n                  return [4, N(i.next())];\n                case 3:\n                  if ((o = f.sent()).done) return [3, 12];\n                  if (s = o.value, e && 0 === n) throw this.createNoExtraBytesError(this.totalPos);\n                  this.appendBuffer(s), r && (n = this.readArraySize(), r = !1, this.complete()), f.label = 4;\n                case 4:\n                  f.trys.push([4, 9,, 10]), f.label = 5;\n                case 5:\n                  return [4, N(this.doDecodeSync())];\n                case 6:\n                  return [4, f.sent()];\n                case 7:\n                  return f.sent(), 0 == --n ? [3, 8] : [3, 5];\n                case 8:\n                  return [3, 10];\n                case 9:\n                  if (!((a = f.sent()) instanceof j)) throw a;\n                  return [3, 10];\n                case 10:\n                  this.totalPos += this.pos, f.label = 11;\n                case 11:\n                  return [3, 2];\n                case 12:\n                  return [3, 19];\n                case 13:\n                  return h = f.sent(), u = {\n                    error: h\n                  }, [3, 19];\n                case 14:\n                  return f.trys.push([14,, 17, 18]), o && !o.done && (c = i.return) ? [4, N(c.call(i))] : [3, 16];\n                case 15:\n                  f.sent(), f.label = 16;\n                case 16:\n                  return [3, 18];\n                case 17:\n                  if (u) throw u.error;\n                  return [7];\n                case 18:\n                  return [7];\n                case 19:\n                  return [2];\n              }\n            });\n          });\n        }, t.prototype.doDecodeSync = function () {\n          t: for (;;) {\n            var t = this.readHeadByte(),\n              e = void 0;\n            if (t >= 224) e = t - 256;else if (t < 192) {\n              if (t < 128) e = t;else if (t < 144) {\n                if (0 !== (n = t - 128)) {\n                  this.pushMapState(n), this.complete();\n                  continue t;\n                }\n                e = {};\n              } else if (t < 160) {\n                if (0 !== (n = t - 144)) {\n                  this.pushArrayState(n), this.complete();\n                  continue t;\n                }\n                e = [];\n              } else {\n                var r = t - 160;\n                e = this.decodeUtf8String(r, 0);\n              }\n            } else if (192 === t) e = null;else if (194 === t) e = !1;else if (195 === t) e = !0;else if (202 === t) e = this.readF32();else if (203 === t) e = this.readF64();else if (204 === t) e = this.readU8();else if (205 === t) e = this.readU16();else if (206 === t) e = this.readU32();else if (207 === t) e = this.readU64();else if (208 === t) e = this.readI8();else if (209 === t) e = this.readI16();else if (210 === t) e = this.readI32();else if (211 === t) e = this.readI64();else if (217 === t) {\n              r = this.lookU8();\n              e = this.decodeUtf8String(r, 1);\n            } else if (218 === t) {\n              r = this.lookU16();\n              e = this.decodeUtf8String(r, 2);\n            } else if (219 === t) {\n              r = this.lookU32();\n              e = this.decodeUtf8String(r, 4);\n            } else if (220 === t) {\n              if (0 !== (n = this.readU16())) {\n                this.pushArrayState(n), this.complete();\n                continue t;\n              }\n              e = [];\n            } else if (221 === t) {\n              if (0 !== (n = this.readU32())) {\n                this.pushArrayState(n), this.complete();\n                continue t;\n              }\n              e = [];\n            } else if (222 === t) {\n              if (0 !== (n = this.readU16())) {\n                this.pushMapState(n), this.complete();\n                continue t;\n              }\n              e = {};\n            } else if (223 === t) {\n              if (0 !== (n = this.readU32())) {\n                this.pushMapState(n), this.complete();\n                continue t;\n              }\n              e = {};\n            } else if (196 === t) {\n              var n = this.lookU8();\n              e = this.decodeBinary(n, 1);\n            } else if (197 === t) {\n              n = this.lookU16();\n              e = this.decodeBinary(n, 2);\n            } else if (198 === t) {\n              n = this.lookU32();\n              e = this.decodeBinary(n, 4);\n            } else if (212 === t) e = this.decodeExtension(1, 0);else if (213 === t) e = this.decodeExtension(2, 0);else if (214 === t) e = this.decodeExtension(4, 0);else if (215 === t) e = this.decodeExtension(8, 0);else if (216 === t) e = this.decodeExtension(16, 0);else if (199 === t) {\n              n = this.lookU8();\n              e = this.decodeExtension(n, 1);\n            } else if (200 === t) {\n              n = this.lookU16();\n              e = this.decodeExtension(n, 2);\n            } else {\n              if (201 !== t) throw new Error(\"Unrecognized type byte: \" + L(t));\n              n = this.lookU32();\n              e = this.decodeExtension(n, 4);\n            }\n            this.complete();\n            for (var i = this.stack; i.length > 0;) {\n              var o = i[i.length - 1];\n              if (0 === o.type) {\n                if (o.array[o.position] = e, o.position++, o.position !== o.size) continue t;\n                i.pop(), e = o.array;\n              } else {\n                if (1 === o.type) {\n                  if (s = void 0, \"string\" !== (s = typeof e) && \"number\" !== s) throw new Error(\"The type of key must be string or number but \" + typeof e);\n                  o.key = e, o.type = 2;\n                  continue t;\n                }\n                if (o.map[o.key] = e, o.readCount++, o.readCount !== o.size) {\n                  o.key = null, o.type = 1;\n                  continue t;\n                }\n                i.pop(), e = o.map;\n              }\n            }\n            return e;\n          }\n          var s;\n        }, t.prototype.readHeadByte = function () {\n          return -1 === this.headByte && (this.headByte = this.readU8()), this.headByte;\n        }, t.prototype.complete = function () {\n          this.headByte = -1;\n        }, t.prototype.readArraySize = function () {\n          var t = this.readHeadByte();\n          switch (t) {\n            case 220:\n              return this.readU16();\n            case 221:\n              return this.readU32();\n            default:\n              if (t < 160) return t - 144;\n              throw new Error(\"Unrecognized array type byte: \" + L(t));\n          }\n        }, t.prototype.pushMapState = function (t) {\n          if (t > this.maxMapLength) throw new Error(\"Max length exceeded: map length (\" + t + \") > maxMapLengthLength (\" + this.maxMapLength + \")\");\n          this.stack.push({\n            type: 1,\n            size: t,\n            key: null,\n            readCount: 0,\n            map: {}\n          });\n        }, t.prototype.pushArrayState = function (t) {\n          if (t > this.maxArrayLength) throw new Error(\"Max length exceeded: array length (\" + t + \") > maxArrayLength (\" + this.maxArrayLength + \")\");\n          this.stack.push({\n            type: 0,\n            size: t,\n            array: new Array(t),\n            position: 0\n          });\n        }, t.prototype.decodeUtf8String = function (t, e) {\n          var r;\n          if (t > this.maxStrLength) throw new Error(\"Max length exceeded: UTF-8 byte length (\" + t + \") > maxStrLength (\" + this.maxStrLength + \")\");\n          if (this.bytes.byteLength < this.pos + e + t) throw _;\n          var n,\n            i = this.pos + e;\n          return n = this.stateIsMapKey() && (null === (r = this.keyDecoder) || void 0 === r ? void 0 : r.canBeCached(t)) ? this.keyDecoder.decode(this.bytes, i, t) : o && t > l ? function (t, e, r) {\n            var n = t.subarray(e, e + r);\n            return f.decode(n);\n          }(this.bytes, i, t) : c(this.bytes, i, t), this.pos += e + t, n;\n        }, t.prototype.stateIsMapKey = function () {\n          return this.stack.length > 0 && 1 === this.stack[this.stack.length - 1].type;\n        }, t.prototype.decodeBinary = function (t, e) {\n          if (t > this.maxBinLength) throw new Error(\"Max length exceeded: bin length (\" + t + \") > maxBinLength (\" + this.maxBinLength + \")\");\n          if (!this.hasRemaining(t + e)) throw _;\n          var r = this.pos + e,\n            n = this.bytes.subarray(r, r + t);\n          return this.pos += e + t, n;\n        }, t.prototype.decodeExtension = function (t, e) {\n          if (t > this.maxExtLength) throw new Error(\"Max length exceeded: ext length (\" + t + \") > maxExtLength (\" + this.maxExtLength + \")\");\n          var r = this.view.getInt8(this.pos + e),\n            n = this.decodeBinary(t, e + 1);\n          return this.extensionCodec.decode(n, r, this.context);\n        }, t.prototype.lookU8 = function () {\n          return this.view.getUint8(this.pos);\n        }, t.prototype.lookU16 = function () {\n          return this.view.getUint16(this.pos);\n        }, t.prototype.lookU32 = function () {\n          return this.view.getUint32(this.pos);\n        }, t.prototype.readU8 = function () {\n          var t = this.view.getUint8(this.pos);\n          return this.pos++, t;\n        }, t.prototype.readI8 = function () {\n          var t = this.view.getInt8(this.pos);\n          return this.pos++, t;\n        }, t.prototype.readU16 = function () {\n          var t = this.view.getUint16(this.pos);\n          return this.pos += 2, t;\n        }, t.prototype.readI16 = function () {\n          var t = this.view.getInt16(this.pos);\n          return this.pos += 2, t;\n        }, t.prototype.readU32 = function () {\n          var t = this.view.getUint32(this.pos);\n          return this.pos += 4, t;\n        }, t.prototype.readI32 = function () {\n          var t = this.view.getInt32(this.pos);\n          return this.pos += 4, t;\n        }, t.prototype.readU64 = function () {\n          var t,\n            e,\n            r,\n            n,\n            i = (t = this.view, e = this.pos, r = t.getUint32(e), n = t.getUint32(e + 4), r > Math.floor(Number.MAX_SAFE_INTEGER / 4294967296) ? BigInt(r) * BigInt(4294967296) + BigInt(n) : 4294967296 * r + n);\n          return this.pos += 8, i;\n        }, t.prototype.readI64 = function () {\n          var t = y(this.view, this.pos);\n          return this.pos += 8, t;\n        }, t.prototype.readF32 = function () {\n          var t = this.view.getFloat32(this.pos);\n          return this.pos += 4, t;\n        }, t.prototype.readF64 = function () {\n          var t = this.view.getFloat64(this.pos);\n          return this.pos += 8, t;\n        }, t;\n      }(),\n      R = {};\n    function V(t, e) {\n      return void 0 === e && (e = R), new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decode(t);\n    }\n    var K = function (t, e) {\n        var r,\n          n,\n          i,\n          o,\n          s = {\n            label: 0,\n            sent: function () {\n              if (1 & i[0]) throw i[1];\n              return i[1];\n            },\n            trys: [],\n            ops: []\n          };\n        return o = {\n          next: a(0),\n          throw: a(1),\n          return: a(2)\n        }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n          return this;\n        }), o;\n        function a(o) {\n          return function (a) {\n            return function (o) {\n              if (r) throw new TypeError(\"Generator is already executing.\");\n              for (; s;) try {\n                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;\n                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {\n                  case 0:\n                  case 1:\n                    i = o;\n                    break;\n                  case 4:\n                    return s.label++, {\n                      value: o[1],\n                      done: !1\n                    };\n                  case 5:\n                    s.label++, n = o[1], o = [0];\n                    continue;\n                  case 7:\n                    o = s.ops.pop(), s.trys.pop();\n                    continue;\n                  default:\n                    if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n                      s = 0;\n                      continue;\n                    }\n                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {\n                      s.label = o[1];\n                      break;\n                    }\n                    if (6 === o[0] && s.label < i[1]) {\n                      s.label = i[1], i = o;\n                      break;\n                    }\n                    if (i && s.label < i[2]) {\n                      s.label = i[2], s.ops.push(o);\n                      break;\n                    }\n                    i[2] && s.ops.pop(), s.trys.pop();\n                    continue;\n                }\n                o = e.call(t, s);\n              } catch (t) {\n                o = [6, t], n = 0;\n              } finally {\n                r = i = 0;\n              }\n              if (5 & o[0]) throw o[1];\n              return {\n                value: o[0] ? o[1] : void 0,\n                done: !0\n              };\n            }([o, a]);\n          };\n        }\n      },\n      G = function (t) {\n        return this instanceof G ? (this.v = t, this) : new G(t);\n      },\n      H = function (t, e, r) {\n        if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n        var n,\n          i = r.apply(t, e || []),\n          o = [];\n        return n = {}, s(\"next\"), s(\"throw\"), s(\"return\"), n[Symbol.asyncIterator] = function () {\n          return this;\n        }, n;\n        function s(t) {\n          i[t] && (n[t] = function (e) {\n            return new Promise(function (r, n) {\n              o.push([t, e, r, n]) > 1 || a(t, e);\n            });\n          });\n        }\n        function a(t, e) {\n          try {\n            (r = i[t](e)).value instanceof G ? Promise.resolve(r.value.v).then(h, u) : c(o[0][2], r);\n          } catch (t) {\n            c(o[0][3], t);\n          }\n          var r;\n        }\n        function h(t) {\n          a(\"next\", t);\n        }\n        function u(t) {\n          a(\"throw\", t);\n        }\n        function c(t, e) {\n          t(e), o.shift(), o.length && a(o[0][0], o[0][1]);\n        }\n      };\n    function X(t) {\n      if (null == t) throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n    }\n    function q(t) {\n      return null != t[Symbol.asyncIterator] ? t : function (t) {\n        return H(this, arguments, function () {\n          var e, r, n, i;\n          return K(this, function (o) {\n            switch (o.label) {\n              case 0:\n                e = t.getReader(), o.label = 1;\n              case 1:\n                o.trys.push([1,, 9, 10]), o.label = 2;\n              case 2:\n                return [4, G(e.read())];\n              case 3:\n                return r = o.sent(), n = r.done, i = r.value, n ? [4, G(void 0)] : [3, 5];\n              case 4:\n                return [2, o.sent()];\n              case 5:\n                return X(i), [4, G(i)];\n              case 6:\n                return [4, o.sent()];\n              case 7:\n                return o.sent(), [3, 2];\n              case 8:\n                return [3, 10];\n              case 9:\n                return e.releaseLock(), [7];\n              case 10:\n                return [2];\n            }\n          });\n        });\n      }(t);\n    }\n    var J = function (t, e, r, n) {\n        return new (r || (r = Promise))(function (i, o) {\n          function s(t) {\n            try {\n              h(n.next(t));\n            } catch (t) {\n              o(t);\n            }\n          }\n          function a(t) {\n            try {\n              h(n.throw(t));\n            } catch (t) {\n              o(t);\n            }\n          }\n          function h(t) {\n            var e;\n            t.done ? i(t.value) : (e = t.value, e instanceof r ? e : new r(function (t) {\n              t(e);\n            })).then(s, a);\n          }\n          h((n = n.apply(t, e || [])).next());\n        });\n      },\n      Q = function (t, e) {\n        var r,\n          n,\n          i,\n          o,\n          s = {\n            label: 0,\n            sent: function () {\n              if (1 & i[0]) throw i[1];\n              return i[1];\n            },\n            trys: [],\n            ops: []\n          };\n        return o = {\n          next: a(0),\n          throw: a(1),\n          return: a(2)\n        }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n          return this;\n        }), o;\n        function a(o) {\n          return function (a) {\n            return function (o) {\n              if (r) throw new TypeError(\"Generator is already executing.\");\n              for (; s;) try {\n                if (r = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;\n                switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {\n                  case 0:\n                  case 1:\n                    i = o;\n                    break;\n                  case 4:\n                    return s.label++, {\n                      value: o[1],\n                      done: !1\n                    };\n                  case 5:\n                    s.label++, n = o[1], o = [0];\n                    continue;\n                  case 7:\n                    o = s.ops.pop(), s.trys.pop();\n                    continue;\n                  default:\n                    if (!(i = s.trys, (i = i.length > 0 && i[i.length - 1]) || 6 !== o[0] && 2 !== o[0])) {\n                      s = 0;\n                      continue;\n                    }\n                    if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {\n                      s.label = o[1];\n                      break;\n                    }\n                    if (6 === o[0] && s.label < i[1]) {\n                      s.label = i[1], i = o;\n                      break;\n                    }\n                    if (i && s.label < i[2]) {\n                      s.label = i[2], s.ops.push(o);\n                      break;\n                    }\n                    i[2] && s.ops.pop(), s.trys.pop();\n                    continue;\n                }\n                o = e.call(t, s);\n              } catch (t) {\n                o = [6, t], n = 0;\n              } finally {\n                r = i = 0;\n              }\n              if (5 & o[0]) throw o[1];\n              return {\n                value: o[0] ? o[1] : void 0,\n                done: !0\n              };\n            }([o, a]);\n          };\n        }\n      };\n    function Y(t, e) {\n      return void 0 === e && (e = R), J(this, void 0, void 0, function () {\n        var r;\n        return Q(this, function (n) {\n          return r = q(t), [2, new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decodeAsync(r)];\n        });\n      });\n    }\n    function Z(t, e) {\n      void 0 === e && (e = R);\n      var r = q(t);\n      return new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decodeArrayStream(r);\n    }\n    function $(t, e) {\n      void 0 === e && (e = R);\n      var r = q(t);\n      return new O(e.extensionCodec, e.context, e.maxStrLength, e.maxBinLength, e.maxArrayLength, e.maxMapLength, e.maxExtLength).decodeStream(r);\n    }\n  }]);\n});","map":{"version":3,"mappings":"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","names":["root","factory","exports","module","define","amd","MessagePack","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","default","object","property","prototype","hasOwnProperty","p","s","TEXT_ENCODING_AVAILABLE","process","TextEncoder","TextDecoder","utf8Count","str","strLength","length","byteLength","pos","charCodeAt","extra","sharedTextEncoder","undefined","TEXT_ENCODER_THRESHOLD","utf8EncodeTE","encodeInto","output","outputOffset","subarray","set","encode","utf8DecodeJs","bytes","inputOffset","offset","end","units","result","byte1","push","byte2","byte3","unit","String","fromCharCode","apply","sharedTextDecoder","TEXT_DECODER_THRESHOLD","type","data","setInt64","view","high","Math","floor","low","setUint32","getInt64","getInt32","getUint32","exceeds_min_safe_int","Number","MIN_SAFE_INTEGER","exceeds_max_safe_int","MAX_SAFE_INTEGER","BigInt","EXT_TIMESTAMP","encodeTimeSpecToTimestamp","sec","nsec","rv","Uint8Array","DataView","buffer","secHigh","secLow","encodeDateToTimeSpec","date","msec","getTime","nsecInSec","encodeTimestampExtension","Date","decodeTimestampToTimeSpec","byteOffset","nsec30AndSecHigh2","Error","decodeTimestampExtension","timeSpec","timestampExtension","decode","S","register","encoders","decoders","index","builtInEncoders","builtInDecoders","context","encoder","ExtData","decoder","ExtensionCodec","ensureUint8Array","ArrayBuffer","isView","from","I","extensionCodec","maxDepth","initialBufferSize","sortKeys","forceFloat32","ignoreUndefined","forceIntegerToFloat","defaultCodec","reinitializeState","doEncode","getUint8Array","depth","encodeNil","encodeBoolean","encodeNumber","encodeString","encodebigint","encodeObject","sizeToWrite","requiredSize","resizeBuffer","newSize","newBuffer","newBytes","newView","writeU8","isSafeInteger","writeU16","writeU32","writeU64","writeI8","writeI16","writeI32","writeI64","writeF32","writeF64","writeBig64","ensureBufferSizeToWrite","writeStringHeader","utf8EncodeJs","ext","tryToEncode","encodeExtension","Array","isArray","encodeArray","encodeBinary","toString","encodeMap","size","writeU8a","item","keys","count","sort","countWithoutUndefined","a","setUint8","values","setInt8","setUint16","setInt16","setInt32","setFloat32","setFloat64","setUint64","setBigInt64","defaultEncodeOptions","options","prettyByte","byte","abs","padStart","M","maxKeyLength","maxLengthPerKey","caches","records","recordsLength","FIND_CHUNK","record","recordBytes","j","e","random","cachedValue","hit","miss","slicedCopyOfBytes","slice","store","EMPTY_VIEW","EMPTY_BYTES","DataViewIndexOutOfBoundsError","getInt8","constructor","MORE_DATA","sharedCachedKeyDecoder","O","maxStrLength","maxBinLength","maxArrayLength","maxMapLength","maxExtLength","keyDecoder","totalPos","headByte","bufferView","createDataView","hasRemaining","remainingData","newData","concated","setBuffer","posToShow","RangeError","doDecodeSingleSync","doDecodeSync","createNoExtraBytesError","stream","decoded","appendBuffer","u","decodeMultiAsync","isArrayHeaderRequired","arrayItemsLeft","readArraySize","complete","f","DECODE","readHeadByte","pushMapState","pushArrayState","decodeUtf8String","readF32","readF64","readU8","readU16","readU32","readU64","readI8","readI16","readI32","readI64","lookU8","lookU16","lookU32","decodeBinary","decodeExtension","stack","state","array","position","pop","keyType","map","readCount","headerOffset","stateIsMapKey","canBeCached","stringBytes","utf8DecodeTD","headOffset","extType","getUint8","getUint16","getInt16","getFloat32","getFloat64","defaultDecodeOptions","assertNonNull","ensureAsyncIterabe","streamLike","asyncIterator","reader","getReader","read","done","releaseLock","asyncIterableFromStream","decodeAsync","decodeArrayStream","decodeStream"],"sourceRoot":"","sources":["webpack://MessagePack/webpack/universalModuleDefinition","webpack://MessagePack/webpack/bootstrap","webpack://MessagePack/src/utils/utf8.ts","webpack://MessagePack/src/ExtData.ts","webpack://MessagePack/src/utils/int.ts","webpack://MessagePack/src/timestamp.ts","webpack://MessagePack/src/ExtensionCodec.ts","webpack://MessagePack/src/utils/typedArrays.ts","webpack://MessagePack/src/Encoder.ts","webpack://MessagePack/src/encode.ts","webpack://MessagePack/src/utils/prettyByte.ts","webpack://MessagePack/src/CachedKeyDecoder.ts","webpack://MessagePack/src/Decoder.ts","webpack://MessagePack/src/decode.ts","webpack://MessagePack/src/utils/stream.ts","webpack://MessagePack/src/decodeAsync.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MessagePack\"] = factory();\n\telse\n\t\troot[\"MessagePack\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export const TEXT_ENCODING_AVAILABLE =\n  typeof process !== \"undefined\" &&\n  process.env.TEXT_ENCODING !== \"never\" &&\n  typeof TextEncoder !== \"undefined\" &&\n  typeof TextDecoder !== \"undefined\";\n\nexport function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\nconst sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;\nexport const TEXT_ENCODER_THRESHOLD = typeof process !== \"undefined\" && process.env.TEXT_ENCODING !== \"force\" ? 200 : 0;\n\nfunction utf8EncodeTEencode(str: string, output: Uint8Array, outputOffset: number): void {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  output.set(sharedTextEncoder!.encode(str), outputOffset);\n}\n\nfunction utf8EncodeTEencodeInto(str: string, output: Uint8Array, outputOffset: number): void {\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  sharedTextEncoder!.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport const utf8EncodeTE = sharedTextEncoder?.encodeInto ? utf8EncodeTEencodeInto : utf8EncodeTEencode;\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++];\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++] & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++] & 0x3f;\n      const byte3 = bytes[offset++] & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++] & 0x3f;\n      const byte3 = bytes[offset++] & 0x3f;\n      const byte4 = bytes[offset++] & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;\nexport const TEXT_DECODER_THRESHOLD = typeof process !== \"undefined\" && process.env.TEXT_DECODER !== \"force\" ? 200 : 0;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  return sharedTextDecoder!.decode(stringBytes);\n}\n","/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  constructor(readonly type: number, readonly data: Uint8Array) {}\n}\n","// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setBigInt64(view: DataView, offset: number, value: bigint): void {\n  let high = Number(value / BigInt(0x1_0000_0000));\n  const low = Number(value % BigInt(0x1_0000_0000));\n  if (high < 0 && low !== 0) {\n    // simulate Math.floor for negative high\n    high -= 1;\n  }\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number) {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n\n  const exceeds_min_safe_int =\n    high < Math.floor(Number.MIN_SAFE_INTEGER / 0x1_0000_0000) ||\n    (high === Math.floor(Number.MIN_SAFE_INTEGER / 0x1_0000_0000) && low === 0);\n\n  const exceeds_max_safe_int = high > Math.floor(Number.MAX_SAFE_INTEGER / 0x1_0000_0000);\n\n  if (exceeds_min_safe_int || exceeds_max_safe_int) {\n    return BigInt(high) * BigInt(0x1_0000_0000) + BigInt(low);\n  }\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number) {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n\n  const exceeds_max_safe_int = high > Math.floor(Number.MAX_SAFE_INTEGER / 0x1_0000_0000);\n\n  if (exceeds_max_safe_int) {\n    return BigInt(high) * BigInt(0x1_0000_0000) + BigInt(low);\n  }\n  return high * 0x1_0000_0000 + low;\n}\n","// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { getInt64, setInt64 } from \"./utils/int\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4) as number;\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new Error(`Unrecognized data size for timestamp: ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n","// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData\";\nimport { timestampExtension } from \"./timestamp\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (input: unknown, context: ContextType) => Uint8Array | null;\n\n// immutable interfce to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = 1 + type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encoder = this.builtInEncoders[i];\n      if (encoder != null) {\n        const data = encoder(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encoder = this.encoders[i];\n      if (encoder != null) {\n        const data = encoder(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decoder = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decoder) {\n      return decoder(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n","export function ensureUint8Array(buffer: ArrayLike<number> | Uint8Array | ArrayBufferView | ArrayBuffer) {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (buffer instanceof ArrayBuffer) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n\nexport function createDataView(buffer: ArrayLike<number> | ArrayBufferView | ArrayBuffer): DataView {\n  if (buffer instanceof ArrayBuffer) {\n    return new DataView(buffer);\n  }\n\n  const bufferView = ensureUint8Array(buffer);\n  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);\n}\n","import { utf8EncodeJs, utf8Count, TEXT_ENCODING_AVAILABLE, TEXT_ENCODER_THRESHOLD, utf8EncodeTE } from \"./utils/utf8\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { setInt64, setUint64, setBigInt64 } from \"./utils/int\";\nimport { ensureUint8Array } from \"./utils/typedArrays\";\nimport { ExtData } from \"./ExtData\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport class Encoder<ContextType> {\n  private pos = 0;\n  private view = new DataView(new ArrayBuffer(this.initialBufferSize));\n  private bytes = new Uint8Array(this.view.buffer);\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxDepth = DEFAULT_MAX_DEPTH,\n    private readonly initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE,\n    private readonly sortKeys = false,\n    private readonly forceFloat32 = false,\n    private readonly ignoreUndefined = false,\n    private readonly forceIntegerToFloat = false,\n  ) {}\n\n  private getUint8Array(): Uint8Array {\n    return this.bytes.subarray(0, this.pos);\n  }\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  public encode(object: unknown): Uint8Array {\n    this.reinitializeState();\n    this.doEncode(object, 1);\n    return this.getUint8Array();\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      this.encodeNumber(object);\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else if (typeof object === \"bigint\") {\n      this.encodebigint(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n  private encodeNumber(object: number) {\n    if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // nagative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        }\n      }\n    } else {\n      // non-integer numbers\n      if (this.forceFloat32) {\n        // float 32\n        this.writeU8(0xca);\n        this.writeF32(object);\n      } else {\n        // float 64\n        this.writeU8(0xcb);\n        this.writeF64(object);\n      }\n    }\n  }\n\n  private encodebigint(object: bigint) {\n    if (object >= BigInt(0)) {\n      if (object < BigInt(0x80)) {\n        // positive fixint\n        this.writeU8(Number(object));\n      } else if (object < BigInt(0x100)) {\n        // uint 8\n        this.writeU8(0xcc);\n        this.writeU8(Number(object));\n      } else if (object < BigInt(0x10000)) {\n        // uint 16\n        this.writeU8(0xcd);\n        this.writeU16(Number(object));\n      } else if (object < BigInt(0x100000000)) {\n        // uint 32\n        this.writeU8(0xce);\n        this.writeU32(Number(object));\n      } else {\n        // uint 64\n        this.writeU8(0xcf);\n        this.writeBig64(object);\n      }\n    } else {\n      if (object >= BigInt(-0x20)) {\n        // nagative fixint\n        this.writeU8(0xe0 | (Number(object) + 0x20));\n      } else if (object >= BigInt(-0x80)) {\n        // int 8\n        this.writeU8(0xd0);\n        this.writeI8(Number(object));\n      } else if (object >= BigInt(-0x8000)) {\n        // int 16\n        this.writeU8(0xd1);\n        this.writeI16(Number(object));\n      } else if (object >= BigInt(-0x80000000)) {\n        // int 32\n        this.writeU8(0xd2);\n        this.writeI32(Number(object));\n      } else {\n        // int 64\n        this.writeU8(0xd3);\n        this.writeBig64(object);\n      }\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n    const strLength = object.length;\n\n    if (TEXT_ENCODING_AVAILABLE && strLength > TEXT_ENCODER_THRESHOLD) {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeTE(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    } else {\n      const byteLength = utf8Count(object);\n      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n      this.writeStringHeader(byteLength);\n      utf8EncodeJs(object, this.bytes, this.pos);\n      this.pos += byteLength;\n    }\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBig64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    setBigInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n}\n","import { ExtensionCodecType } from \"./ExtensionCodec\";\nimport { Encoder } from \"./Encoder\";\nimport { ContextOf, SplitUndefined } from \"./context\";\n\nexport type EncodeOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n    maxDepth: number;\n    initialBufferSize: number;\n    sortKeys: boolean;\n\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * The default is `false`. Note that it needs more time to encode.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point,\n     * with the `forceFloat32` option taken into account.\n     *\n     * The default is `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst defaultEncodeOptions: EncodeOptions = {};\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType>(\n  value: unknown,\n  options: EncodeOptions<SplitUndefined<ContextType>> = defaultEncodeOptions as any,\n): Uint8Array {\n  const encoder = new Encoder<ContextType>(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxDepth,\n    options.initialBufferSize,\n    options.sortKeys,\n    options.forceFloat32,\n    options.ignoreUndefined,\n    options.forceIntegerToFloat,\n  );\n  return encoder.encode(value);\n}\n","export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n","import { utf8DecodeJs } from \"./utils/utf8\";\n\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly value: string;\n}\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n\n  constructor(readonly maxKeyLength = DEFAULT_MAX_KEY_LENGTH, readonly maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    // avoid `new Array(N)` to create a non-sparse array for performance.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number) {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private get(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1];\n    const recordsLength = records.length;\n\n    FIND_CHUNK: for (let i = 0; i < recordsLength; i++) {\n      const record = records[i];\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.value;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1];\n    const record: KeyCacheRecord = { bytes, value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to a randomized position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.get(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const value = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, value);\n    return value;\n  }\n}\n","import { prettyByte } from \"./utils/prettyByte\";\nimport { ExtensionCodec, ExtensionCodecType } from \"./ExtensionCodec\";\nimport { getInt64, getUint64 } from \"./utils/int\";\nimport { utf8DecodeJs, TEXT_ENCODING_AVAILABLE, TEXT_DECODER_THRESHOLD, utf8DecodeTD } from \"./utils/utf8\";\nimport { createDataView, ensureUint8Array } from \"./utils/typedArrays\";\nimport { CachedKeyDecoder, KeyDecoder } from \"./CachedKeyDecoder\";\n\nconst enum State {\n  ARRAY,\n  MAP_KEY,\n  MAP_VALUE,\n}\n\ntype MapKeyType = string | number;\n\nconst isValidMapKeyType = (key: unknown): key is MapKeyType => {\n  const keyType = typeof key;\n\n  return keyType === \"string\" || keyType === \"number\";\n};\n\ntype StackMapState = {\n  type: State.MAP_KEY | State.MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: State.ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);\n\n// IE11: Hack to support IE11.\n// IE11: Drop this hack and just use RangeError when IE11 is obsolete.\nexport const DataViewIndexOutOfBoundsError: typeof Error = (() => {\n  try {\n    // IE11: The spec says it should throw RangeError,\n    // IE11: but in IE11 it throws TypeError.\n    EMPTY_VIEW.getInt8(0);\n  } catch (e) {\n    return e.constructor;\n  }\n  throw new Error(\"never reached\");\n})();\n\nconst MORE_DATA = new DataViewIndexOutOfBoundsError(\"Insufficient data\");\n\nconst DEFAULT_MAX_LENGTH = 0xffff_ffff; // uint32_max\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType> {\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack: Array<StackState> = [];\n\n  public constructor(\n    private readonly extensionCodec: ExtensionCodecType<ContextType> = ExtensionCodec.defaultCodec as any,\n    private readonly context: ContextType = undefined as any,\n    private readonly maxStrLength = DEFAULT_MAX_LENGTH,\n    private readonly maxBinLength = DEFAULT_MAX_LENGTH,\n    private readonly maxArrayLength = DEFAULT_MAX_LENGTH,\n    private readonly maxMapLength = DEFAULT_MAX_LENGTH,\n    private readonly maxExtLength = DEFAULT_MAX_LENGTH,\n    private readonly keyDecoder: KeyDecoder | null = sharedCachedKeyDecoder,\n  ) {}\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | ArrayBuffer): void {\n    this.bytes = ensureUint8Array(buffer);\n    this.view = createDataView(this.bytes);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number>) {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining()) {\n      this.setBuffer(buffer);\n    } else {\n      // retried because data is insufficient\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n      const concated = new Uint8Array(remainingData.length + newData.length);\n      concated.set(remainingData);\n      concated.set(newData, remainingData.length);\n      this.setBuffer(concated);\n    }\n  }\n\n  private hasRemaining(size = 1) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createNoExtraBytesError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  public decode(buffer: ArrayLike<number> | ArrayBuffer): unknown {\n    this.reinitializeState();\n    this.setBuffer(buffer);\n    return this.doDecodeSingleSync();\n  }\n\n  private doDecodeSingleSync(): unknown {\n    const object = this.doDecodeSync();\n    if (this.hasRemaining()) {\n      throw this.createNoExtraBytesError(this.pos);\n    }\n    return object;\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number>>): Promise<unknown> {\n    let decoded = false;\n    let object: unknown;\n    for await (const buffer of stream) {\n      if (decoded) {\n        throw this.createNoExtraBytesError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      try {\n        object = this.doDecodeSync();\n        decoded = true;\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n\n    if (decoded) {\n      if (this.hasRemaining()) {\n        throw this.createNoExtraBytesError(this.totalPos);\n      }\n      return object;\n    }\n\n    const { headByte, pos, totalPos } = this;\n    throw new RangeError(\n      `Insufficient data in parcing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n    );\n  }\n\n  public decodeArrayStream(stream: AsyncIterable<ArrayLike<number>>) {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number>>) {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number>>, isArray: boolean) {\n    let isArrayHeaderRequired = isArray;\n    let arrayItemsLeft = -1;\n\n    for await (const buffer of stream) {\n      if (isArray && arrayItemsLeft === 0) {\n        throw this.createNoExtraBytesError(this.totalPos);\n      }\n\n      this.appendBuffer(buffer);\n\n      if (isArrayHeaderRequired) {\n        arrayItemsLeft = this.readArraySize();\n        isArrayHeaderRequired = false;\n        this.complete();\n      }\n\n      try {\n        while (true) {\n          yield this.doDecodeSync();\n          if (--arrayItemsLeft === 0) {\n            break;\n          }\n        }\n      } catch (e) {\n        if (!(e instanceof DataViewIndexOutOfBoundsError)) {\n          throw e; // rethrow\n        }\n        // fallthrough\n      }\n      this.totalPos += this.pos;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeUtf8String(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        object = this.readU64();\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        object = this.readI64();\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeUtf8String(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeUtf8String(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeUtf8String(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new Error(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack[stack.length - 1];\n        if (state.type === State.ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            stack.pop();\n            object = state.array;\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === State.MAP_KEY) {\n          if (!isValidMapKeyType(object)) {\n            throw new Error(\"The type of key must be string or number but \" + typeof object);\n          }\n\n          state.key = object;\n          state.type = State.MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            stack.pop();\n            object = state.map;\n          } else {\n            state.key = null;\n            state.type = State.MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new Error(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new Error(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.push({\n      type: State.MAP_KEY,\n      size,\n      key: null,\n      readCount: 0,\n      map: {},\n    });\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new Error(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.push({\n      type: State.ARRAY,\n      size,\n      array: new Array<unknown>(size),\n      position: 0,\n    });\n  }\n\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new Error(`Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`);\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else if (TEXT_ENCODING_AVAILABLE && byteLength > TEXT_DECODER_THRESHOLD) {\n      object = utf8DecodeTD(this.bytes, offset, byteLength);\n    } else {\n      object = utf8DecodeJs(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack[this.stack.length - 1];\n      return state.type === State.MAP_KEY;\n    }\n    return false;\n  }\n\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new Error(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new Error(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): bigint | number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): bigint | number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n","import { ExtensionCodecType } from \"./ExtensionCodec\";\nimport { Decoder } from \"./Decoder\";\nimport { ContextOf, SplitUndefined } from \"./context\";\n\nexport type DecodeOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Maximum string length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     * Default to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport const defaultDecodeOptions: DecodeOptions = {};\n\n/**\n * It decodes a MessagePack-encoded buffer.\n *\n * This is a synchronous decoding function. See other variants for asynchronous decoding: `decodeAsync()`, `decodeStream()`, `decodeArrayStream()`.\n */\nexport function decode<ContextType>(\n  buffer: ArrayLike<number> | ArrayBuffer,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): unknown {\n  const decoder = new Decoder<ContextType>(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decode(buffer);\n}\n","// utility for whatwg streams\n\n// The living standard of whatwg streams says\n// ReadableStream is also AsyncIterable, but\n// as of June 2019, no browser implements it.\n// See https://streams.spec.whatwg.org/ for details\nexport type ReadableStreamLike<T> = AsyncIterable<T> | ReadableStream<T>;\n\nexport function isAsyncIterable<T>(object: ReadableStreamLike<T>): object is AsyncIterable<T> {\n  return (object as any)[Symbol.asyncIterator] != null;\n}\n\nfunction assertNonNull<T>(value: T | null | undefined): asserts value is T {\n  if (value == null) {\n    throw new Error(\"Assertion Failure: value must not be null nor undefined\");\n  }\n}\n\nexport async function* asyncIterableFromStream<T>(stream: ReadableStream<T>): AsyncIterable<T> {\n  const reader = stream.getReader();\n\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        return;\n      }\n      assertNonNull(value);\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function ensureAsyncIterabe<T>(streamLike: ReadableStreamLike<T>): AsyncIterable<T> {\n  if (isAsyncIterable(streamLike)) {\n    return streamLike;\n  } else {\n    return asyncIterableFromStream(streamLike);\n  }\n}\n","import { Decoder } from \"./Decoder\";\nimport { defaultDecodeOptions, DecodeOptions } from \"./decode\";\nimport { ensureAsyncIterabe, ReadableStreamLike } from \"./utils/stream\";\nimport { SplitUndefined } from \"./context\";\n\nexport async function decodeAsync<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number>>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n): Promise<unknown> {\n  const stream = ensureAsyncIterabe(streamLike);\n\n  const decoder = new Decoder<ContextType>(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n  return decoder.decodeAsync(stream);\n}\n\nexport function decodeArrayStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number>>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n) {\n  const stream = ensureAsyncIterabe(streamLike);\n\n  const decoder = new Decoder<ContextType>(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeArrayStream(stream);\n}\n\nexport function decodeStream<ContextType>(\n  streamLike: ReadableStreamLike<ArrayLike<number>>,\n  options: DecodeOptions<SplitUndefined<ContextType>> = defaultDecodeOptions as any,\n) {\n  const stream = ensureAsyncIterabe(streamLike);\n\n  const decoder = new Decoder<ContextType>(\n    options.extensionCodec,\n    (options as typeof options & { context: any }).context,\n    options.maxStrLength,\n    options.maxBinLength,\n    options.maxArrayLength,\n    options.maxMapLength,\n    options.maxExtLength,\n  );\n\n  return decoder.decodeStream(stream);\n}\n"]},"metadata":{},"sourceType":"script"}