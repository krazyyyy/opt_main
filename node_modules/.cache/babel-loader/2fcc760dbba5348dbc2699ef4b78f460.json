{"ast":null,"code":"import { fetch } from 'cross-fetch';\nclass URLTokenBaseHTTPError extends Error {\n  constructor(message, response) {\n    super(message);\n    this.response = response;\n    this.name = 'URLTokenBaseHTTPError';\n    this.response = response;\n  }\n}\n/**\n * Implementation of BaseHTTPClient that uses a URL and a token\n * and make the REST queries using fetch.\n * This is the default implementation of BaseHTTPClient.\n */\nexport class URLTokenBaseHTTPClient {\n  constructor(tokenHeader, baseServer, port) {\n    let defaultHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.defaultHeaders = defaultHeaders;\n    // Append a trailing slash so we can use relative paths. Without the trailing\n    // slash, the last path segment will be replaced by the relative path. See\n    // usage in `addressWithPath`.\n    const fixedBaseServer = baseServer.endsWith('/') ? baseServer : `${baseServer}/`;\n    const baseServerURL = new URL(fixedBaseServer);\n    if (typeof port !== 'undefined') {\n      baseServerURL.port = port.toString();\n    }\n    if (baseServerURL.protocol.length === 0) {\n      throw new Error('Invalid base server URL, protocol must be defined.');\n    }\n    this.baseURL = baseServerURL;\n    this.tokenHeader = tokenHeader;\n  }\n  /**\n   * Compute the URL for a path relative to the instance's address\n   * @param relativePath - A path string\n   * @param query - An optional key-value object of query parameters to add to the URL. If the\n   *   relativePath already has query parameters on it, the additional parameters defined here will\n   *   be added to the URL without modifying those (unless a key collision occurs).\n   * @returns A URL string\n   */\n  getURL(relativePath, query) {\n    let fixedRelativePath;\n    if (relativePath.startsWith('./')) {\n      fixedRelativePath = relativePath;\n    } else if (relativePath.startsWith('/')) {\n      fixedRelativePath = `.${relativePath}`;\n    } else {\n      fixedRelativePath = `./${relativePath}`;\n    }\n    const address = new URL(fixedRelativePath, this.baseURL);\n    if (query) {\n      for (const [key, value] of Object.entries(query)) {\n        address.searchParams.set(key, value);\n      }\n    }\n    return address.toString();\n  }\n  static formatFetchResponseHeaders(headers) {\n    const headersObj = {};\n    headers.forEach((key, value) => {\n      headersObj[key] = value;\n    });\n    return headersObj;\n  }\n  static async checkHttpError(res) {\n    if (res.ok) {\n      return;\n    }\n    let body = null;\n    let bodyErrorMessage = null;\n    try {\n      body = new Uint8Array(await res.arrayBuffer());\n      const decoded = JSON.parse(Buffer.from(body).toString());\n      if (decoded.message) {\n        bodyErrorMessage = decoded.message;\n      }\n    } catch (_) {\n      // ignore any error that happened while we are parsing the error response\n    }\n    let message = `Network request error. Received status ${res.status} (${res.statusText})`;\n    if (bodyErrorMessage) {\n      message += `: ${bodyErrorMessage}`;\n    }\n    throw new URLTokenBaseHTTPError(message, {\n      body,\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    });\n  }\n  static async formatFetchResponse(res) {\n    await this.checkHttpError(res);\n    return {\n      body: new Uint8Array(await res.arrayBuffer()),\n      status: res.status,\n      headers: URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)\n    };\n  }\n  async get(relativePath, query) {\n    let requestHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      mode: 'cors',\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async post(relativePath, data, query) {\n    let requestHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'POST',\n      mode: 'cors',\n      body: data,\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n  async delete(relativePath, data, query) {\n    let requestHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    // Expand headers for use in fetch\n    const headers = {\n      ...this.tokenHeader,\n      ...this.defaultHeaders,\n      ...requestHeaders\n    };\n    const res = await fetch(this.getURL(relativePath, query), {\n      method: 'DELETE',\n      mode: 'cors',\n      body: data,\n      headers\n    });\n    return URLTokenBaseHTTPClient.formatFetchResponse(res);\n  }\n}","map":{"version":3,"mappings":"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","names":["fetch","URLTokenBaseHTTPError","Error","constructor","message","response","name","URLTokenBaseHTTPClient","tokenHeader","baseServer","port","defaultHeaders","fixedBaseServer","endsWith","baseServerURL","URL","toString","protocol","length","baseURL","getURL","relativePath","query","fixedRelativePath","startsWith","address","key","value","Object","entries","searchParams","set","formatFetchResponseHeaders","headers","headersObj","forEach","checkHttpError","res","ok","body","bodyErrorMessage","Uint8Array","arrayBuffer","decoded","JSON","parse","Buffer","from","_","status","statusText","formatFetchResponse","get","requestHeaders","mode","post","data","method","delete"],"sourceRoot":"","sources":["../../../src/client/urlTokenBaseHTTPClient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}