{"ast":null,"code":"const address = require('../encoding/address');\nconst makeTxn = require('../makeTxn');\nconst group = require('../group');\nconst logicsig = require('../logicsig');\nconst logic = require('../logic/logic');\nconst templates = require('./templates');\nconst utils = require('../utils/utils');\nclass Split {\n  /**\n   * Split splits money sent to some account to two recipients at some ratio.\n   * This is a contract account.\n   *\n   * This allows either a two-transaction group, for executing a\n   * split, or single transaction, for closing the account.\n   *\n   * Withdrawals from this account are allowed as a group transaction which\n   * sends receiverOne and receiverTwo amounts with exactly the specified ratio:\n   * (rat1*amountForReceiverOne) = (rat2*amountForReceiverTwo)\n   * At least minPay must be sent to receiverOne.\n   * (CloseRemainderTo must be zero.)\n   *\n   * After expiryRound passes, all funds can be refunded to owner.\n   *\n   * @deprecated This feature will be removed in v2.\n   *\n   * Constructor Parameters:\n   * @param {string} owner: the address to refund funds to on timeout\n   * @param {string} receiverOne: the first recipient in the split account\n   * @param {string} receiverTwo: the second recipient in the split account\n   * @param {int} rat1: fraction of money to be paid to the 1st recipient\n   * @param {int} rat2: fraction of money to be paid to the 2nd recipient\n   * @param {int} expiryRound: the round at which the account expires\n   * @param {int} minPay: minimum amount to be paid out of the account\n   * @param {int} maxFee: half of the maximum fee used by each split forwarding group transaction\n   * @returns {Split}\n   */\n  constructor(owner, receiverOne, receiverTwo, rat1, rat2, expiryRound, minPay, maxFee) {\n    // don't need to validate owner, receiverone, receivertwo - they'll be validated by template.insert\n    if (!Number.isSafeInteger(rat2) || rat2 < 0) throw Error('rat2 must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(rat1) || rat1 < 0) throw Error('rat1 must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(expiryRound) || expiryRound < 0) throw Error('expiryRound must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(minPay) || minPay < 0) throw Error('minPay must be a positive number and smaller than 2^53-1');\n    if (!Number.isSafeInteger(maxFee) || maxFee < 0) throw Error('maxFee must be a positive number and smaller than 2^53-1');\n    const referenceProgramB64 = 'ASAIAQUCAAYHCAkmAyCztwQn0+DycN+vsk+vJWcsoz/b7NDS6i33HOkvTpf+YiC3qUpIgHGWE8/1LPh9SGCalSN7IaITeeWSXbfsS5wsXyC4kBQ38Z8zcwWVAym4S8vpFB/c0XC6R4mnPi9EBADsPDEQIhIxASMMEDIEJBJAABkxCSgSMQcyAxIQMQglEhAxAiEEDRAiQAAuMwAAMwEAEjEJMgMSEDMABykSEDMBByoSEDMACCEFCzMBCCEGCxIQMwAIIQcPEBA=';\n    const referenceProgramBytes = Buffer.from(referenceProgramB64, 'base64');\n    const referenceOffsets = [4 /* timeout */, 7 /* rat2 */, 8 /* rat1 */, 9 /* minPay */, 10 /* owner */, 14 /* receiver1 */, 47 /* receiver2 */, 80];\n    const injectionVector = [maxFee, expiryRound, rat2, rat1, minPay, owner, receiverOne, receiverTwo];\n    const injectionTypes = [templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.INT, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS, templates.valTypes.ADDRESS];\n    const injectedBytes = templates.inject(referenceProgramBytes, referenceOffsets, injectionVector, injectionTypes);\n    this.programBytes = injectedBytes;\n    const lsig = logicsig.makeLogicSig(injectedBytes, undefined);\n    this.address = lsig.address();\n  }\n  /**\n   * returns the program bytes\n   * @returns {Uint8Array}\n   */\n  getProgram() {\n    return this.programBytes;\n  }\n  /**\n   * returns the string address of the contract\n   * @returns {string}\n   */\n  getAddress() {\n    return this.address;\n  }\n}\n/**\n * returns a group transactions array which transfer funds according to the contract's ratio\n *\n * @deprecated This feature will be removed in v2.\n *\n * @param {Uint8Array} contract: bytes representing the contract in question\n * @param {int} amount: the amount to be transferred\n * @param {int} firstRound: the first round on which the transaction group will be valid\n * @param {int} lastRound: the last round on which the transaction group will be valid\n * @param {int} fee: the fee to pay in microAlgos\n * @param {string} genesisHash: the b64-encoded genesis hash indicating the network for this transaction\n * @returns {Uint8Array}\n */\nfunction getSplitFundsTransaction(contract, amount, firstRound, lastRound, fee, genesisHash) {\n  const programOutputs = logic.readProgram(contract, undefined);\n  const ints = programOutputs[0];\n  const byteArrays = programOutputs[1];\n  let rat2 = ints[6];\n  let rat1 = ints[5];\n  let amountForReceiverOne = 0;\n  // reduce fractions\n  const gcdFn = (a, b) => {\n    if (typeof a !== 'number' || typeof b !== 'number') throw new Error('gcd operates only on positive integers');\n    if (!b) {\n      return a;\n    }\n    return gcdFn(b, a % b);\n  };\n  const gcd = gcdFn(rat2, rat1);\n  rat2 = Math.floor(rat2 / gcd);\n  rat1 = Math.floor(rat1 / gcd);\n  const ratio = rat1 / rat2;\n  amountForReceiverOne = Math.round(amount / (1 + ratio));\n  const amountForReceiverTwo = amount - amountForReceiverOne;\n  if (rat1 * amountForReceiverOne !== rat2 * amountForReceiverTwo) {\n    throw Error('could not split funds in a way that satisfied the contract ratio');\n  }\n  const logicSig = logicsig.makeLogicSig(contract, undefined); // no args\n  const from = logicSig.address();\n  const receiverOne = address.encodeAddress(byteArrays[1]);\n  const receiverTwo = address.encodeAddress(byteArrays[2]);\n  const tx1 = makeTxn.makePaymentTxn(from, receiverOne, fee, amountForReceiverOne, undefined, firstRound, lastRound, undefined, genesisHash);\n  const tx2 = makeTxn.makePaymentTxn(from, receiverTwo, fee, amountForReceiverTwo, undefined, firstRound, lastRound, undefined, genesisHash);\n  const txns = [tx1, tx2];\n  const txGroup = group.assignGroupID(txns);\n  const signedTxns = txGroup.map(txn => logicsig.signLogicSigTransactionObject(txn, logicsig).blob);\n  return utils.concatArrays(signedTxns[0], signedTxns[1]);\n}\nmodule.exports = {\n  Split,\n  getSplitFundsTransaction\n};","map":{"version":3,"mappings":"AAAA,MAAMA,OAAO,GAAGC,OAAO,CAAC,qBAAqB,CAAC;AAC9C,MAAMC,OAAO,GAAGD,OAAO,CAAC,YAAY,CAAC;AACrC,MAAME,KAAK,GAAGF,OAAO,CAAC,UAAU,CAAC;AACjC,MAAMG,QAAQ,GAAGH,OAAO,CAAC,aAAa,CAAC;AACvC,MAAMI,KAAK,GAAGJ,OAAO,CAAC,gBAAgB,CAAC;AACvC,MAAMK,SAAS,GAAGL,OAAO,CAAC,aAAa,CAAC;AACxC,MAAMM,KAAK,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AAEvC,MAAMO,KAAK;EACT;;;;;;;;;;;;;;;;;;;;;;;;;;;;EA4BAC,YACEC,KAAK,EACLC,WAAW,EACXC,WAAW,EACXC,IAAI,EACJC,IAAI,EACJC,WAAW,EACXC,MAAM,EACNC,MAAM;IAEN;IACA,IAAI,CAACC,MAAM,CAACC,aAAa,CAACL,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,EACzC,MAAMM,KAAK,CAAC,wDAAwD,CAAC;IACvE,IAAI,CAACF,MAAM,CAACC,aAAa,CAACN,IAAI,CAAC,IAAIA,IAAI,GAAG,CAAC,EACzC,MAAMO,KAAK,CAAC,wDAAwD,CAAC;IACvE,IAAI,CAACF,MAAM,CAACC,aAAa,CAACJ,WAAW,CAAC,IAAIA,WAAW,GAAG,CAAC,EACvD,MAAMK,KAAK,CACT,+DAA+D,CAChE;IACH,IAAI,CAACF,MAAM,CAACC,aAAa,CAACH,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,EAC7C,MAAMI,KAAK,CAAC,0DAA0D,CAAC;IACzE,IAAI,CAACF,MAAM,CAACC,aAAa,CAACF,MAAM,CAAC,IAAIA,MAAM,GAAG,CAAC,EAC7C,MAAMG,KAAK,CAAC,0DAA0D,CAAC;IAEzE,MAAMC,mBAAmB,GACvB,8QAA8Q;IAChR,MAAMC,qBAAqB,GAAGC,MAAM,CAACC,IAAI,CAACH,mBAAmB,EAAE,QAAQ,CAAC;IACxE,MAAMI,gBAAgB,GAAG,CACvB,CAAC,CAAC,eACF,CAAC,CAAC,YACF,CAAC,CAAC,YACF,CAAC,CAAC,cACF,EAAE,CAAC,aACH,EAAE,CAAC,iBACH,EAAE,CAAC,iBACH,EAAE,CACH;IACD,MAAMC,eAAe,GAAG,CACtBT,MAAM,EACNF,WAAW,EACXD,IAAI,EACJD,IAAI,EACJG,MAAM,EACNN,KAAK,EACLC,WAAW,EACXC,WAAW,CACZ;IACD,MAAMe,cAAc,GAAG,CACrBrB,SAAS,CAACsB,QAAQ,CAACC,GAAG,EACtBvB,SAAS,CAACsB,QAAQ,CAACC,GAAG,EACtBvB,SAAS,CAACsB,QAAQ,CAACC,GAAG,EACtBvB,SAAS,CAACsB,QAAQ,CAACC,GAAG,EACtBvB,SAAS,CAACsB,QAAQ,CAACC,GAAG,EACtBvB,SAAS,CAACsB,QAAQ,CAACE,OAAO,EAC1BxB,SAAS,CAACsB,QAAQ,CAACE,OAAO,EAC1BxB,SAAS,CAACsB,QAAQ,CAACE,OAAO,CAC3B;IACD,MAAMC,aAAa,GAAGzB,SAAS,CAAC0B,MAAM,CACpCV,qBAAqB,EACrBG,gBAAgB,EAChBC,eAAe,EACfC,cAAc,CACf;IACD,IAAI,CAACM,YAAY,GAAGF,aAAa;IACjC,MAAMG,IAAI,GAAG9B,QAAQ,CAAC+B,YAAY,CAACJ,aAAa,EAAEK,SAAS,CAAC;IAC5D,IAAI,CAACpC,OAAO,GAAGkC,IAAI,CAAClC,OAAO,EAAE;EAC/B;EAEA;;;;EAIAqC,UAAU;IACR,OAAO,IAAI,CAACJ,YAAY;EAC1B;EAEA;;;;EAIAK,UAAU;IACR,OAAO,IAAI,CAACtC,OAAO;EACrB;;AAEF;;;;;;;;;;;;;AAaA,SAASuC,wBAAwB,CAC/BC,QAAQ,EACRC,MAAM,EACNC,UAAU,EACVC,SAAS,EACTC,GAAG,EACHC,WAAW;EAEX,MAAMC,cAAc,GAAGzC,KAAK,CAAC0C,WAAW,CAACP,QAAQ,EAAEJ,SAAS,CAAC;EAC7D,MAAMY,IAAI,GAAGF,cAAc,CAAC,CAAC,CAAC;EAC9B,MAAMG,UAAU,GAAGH,cAAc,CAAC,CAAC,CAAC;EACpC,IAAIhC,IAAI,GAAGkC,IAAI,CAAC,CAAC,CAAC;EAClB,IAAInC,IAAI,GAAGmC,IAAI,CAAC,CAAC,CAAC;EAClB,IAAIE,oBAAoB,GAAG,CAAC;EAC5B;EACA,MAAMC,KAAK,GAAG,CAACC,CAAC,EAAEC,CAAC,KAAI;IACrB,IAAI,OAAOD,CAAC,KAAK,QAAQ,IAAI,OAAOC,CAAC,KAAK,QAAQ,EAChD,MAAM,IAAIjC,KAAK,CAAC,wCAAwC,CAAC;IAC3D,IAAI,CAACiC,CAAC,EAAE;MACN,OAAOD,CAAC;;IAEV,OAAOD,KAAK,CAACE,CAAC,EAAED,CAAC,GAAGC,CAAC,CAAC;EACxB,CAAC;EACD,MAAMC,GAAG,GAAGH,KAAK,CAACrC,IAAI,EAAED,IAAI,CAAC;EAC7BC,IAAI,GAAGyC,IAAI,CAACC,KAAK,CAAC1C,IAAI,GAAGwC,GAAG,CAAC;EAC7BzC,IAAI,GAAG0C,IAAI,CAACC,KAAK,CAAC3C,IAAI,GAAGyC,GAAG,CAAC;EAC7B,MAAMG,KAAK,GAAG5C,IAAI,GAAGC,IAAI;EACzBoC,oBAAoB,GAAGK,IAAI,CAACG,KAAK,CAACjB,MAAM,IAAI,CAAC,GAAGgB,KAAK,CAAC,CAAC;EACvD,MAAME,oBAAoB,GAAGlB,MAAM,GAAGS,oBAAoB;EAC1D,IAAIrC,IAAI,GAAGqC,oBAAoB,KAAKpC,IAAI,GAAG6C,oBAAoB,EAAE;IAC/D,MAAMvC,KAAK,CACT,kEAAkE,CACnE;;EAGH,MAAMwC,QAAQ,GAAGxD,QAAQ,CAAC+B,YAAY,CAACK,QAAQ,EAAEJ,SAAS,CAAC,CAAC,CAAC;EAC7D,MAAMZ,IAAI,GAAGoC,QAAQ,CAAC5D,OAAO,EAAE;EAC/B,MAAMW,WAAW,GAAGX,OAAO,CAAC6D,aAAa,CAACZ,UAAU,CAAC,CAAC,CAAC,CAAC;EACxD,MAAMrC,WAAW,GAAGZ,OAAO,CAAC6D,aAAa,CAACZ,UAAU,CAAC,CAAC,CAAC,CAAC;EACxD,MAAMa,GAAG,GAAG5D,OAAO,CAAC6D,cAAc,CAChCvC,IAAI,EACJb,WAAW,EACXiC,GAAG,EACHM,oBAAoB,EACpBd,SAAS,EACTM,UAAU,EACVC,SAAS,EACTP,SAAS,EACTS,WAAW,CACZ;EACD,MAAMmB,GAAG,GAAG9D,OAAO,CAAC6D,cAAc,CAChCvC,IAAI,EACJZ,WAAW,EACXgC,GAAG,EACHe,oBAAoB,EACpBvB,SAAS,EACTM,UAAU,EACVC,SAAS,EACTP,SAAS,EACTS,WAAW,CACZ;EACD,MAAMoB,IAAI,GAAG,CAACH,GAAG,EAAEE,GAAG,CAAC;EACvB,MAAME,OAAO,GAAG/D,KAAK,CAACgE,aAAa,CAACF,IAAI,CAAC;EAEzC,MAAMG,UAAU,GAAGF,OAAO,CAACG,GAAG,CAC3BC,GAAG,IAAKlE,QAAQ,CAACmE,6BAA6B,CAACD,GAAG,EAAElE,QAAQ,CAAC,CAACoE,IAAI,CACpE;EACD,OAAOjE,KAAK,CAACkE,YAAY,CAACL,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC;AACzD;AAEAM,MAAM,CAACC,OAAO,GAAG;EACfnE,KAAK;EACL+B;CACD","names":["address","require","makeTxn","group","logicsig","logic","templates","utils","Split","constructor","owner","receiverOne","receiverTwo","rat1","rat2","expiryRound","minPay","maxFee","Number","isSafeInteger","Error","referenceProgramB64","referenceProgramBytes","Buffer","from","referenceOffsets","injectionVector","injectionTypes","valTypes","INT","ADDRESS","injectedBytes","inject","programBytes","lsig","makeLogicSig","undefined","getProgram","getAddress","getSplitFundsTransaction","contract","amount","firstRound","lastRound","fee","genesisHash","programOutputs","readProgram","ints","byteArrays","amountForReceiverOne","gcdFn","a","b","gcd","Math","floor","ratio","round","amountForReceiverTwo","logicSig","encodeAddress","tx1","makePaymentTxn","tx2","txns","txGroup","assignGroupID","signedTxns","map","txn","signLogicSigTransactionObject","blob","concatArrays","module","exports"],"sourceRoot":"","sources":["../../../src/logicTemplates/split.js"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}