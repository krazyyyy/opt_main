{"ast":null,"code":"import * as nacl from './nacl/naclWrappers';\nimport * as address from './encoding/address';\nimport * as encoding from './encoding/encoding';\nimport * as txnBuilder from './transaction';\nimport * as utils from './utils/utils';\n/**\n Utilities for manipulating multisig transaction blobs.\n */\nexport const MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = 'Not enough multisig transactions to merge. Need at least two';\nexport const MULTISIG_MERGE_MISMATCH_ERROR_MSG = 'Cannot merge txs. txIDs differ';\nexport const MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = 'Cannot merge txs. Auth addrs differ';\nexport const MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = 'Cannot merge txs. Multisig preimages differ';\nexport const MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = 'Cannot merge txs. subsigs are mismatched.';\nconst MULTISIG_KEY_NOT_EXIST_ERROR_MSG = 'Key does not exist';\nexport const MULTISIG_NO_MUTATE_ERROR_MSG = 'Cannot mutate a multisig field as it would invalidate all existing signatures.';\nexport const MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG = 'Cannot sign a multisig transaction using `signTxn`. Use `partialSignTxn` instead.';\nexport const MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = 'Cannot add multisig signature. Signature is not of the correct length.';\n/**\n * createMultisigTransaction creates a raw, unsigned multisig transaction blob.\n * @param txn - the actual transaction.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nexport function createMultisigTransaction(txn, _ref) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref;\n  // construct the appendable multisigned transaction format\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  const subsigs = pks.map(pk => ({\n    pk: Buffer.from(pk)\n  }));\n  const msig = {\n    v: version,\n    thr: threshold,\n    subsig: subsigs\n  };\n  const txnForEncoding = txn.get_obj_for_encoding();\n  const signedTxn = {\n    msig,\n    txn: txnForEncoding\n  };\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(txnForEncoding.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * createMultisigTransactionWithSignature creates a multisig transaction blob with an included signature.\n * @param txn - the actual transaction to sign.\n * @param rawSig - a Buffer raw signature of that transaction\n * @param myPk - a public key that corresponds with rawSig\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param pks - ordered list of public keys in this multisig\n * @returns encoded multisig blob\n */\nfunction createMultisigTransactionWithSignature(txn, _ref2, _ref3) {\n  let {\n    rawSig,\n    myPk\n  } = _ref2;\n  let {\n    version,\n    threshold,\n    pks\n  } = _ref3;\n  // Create an empty encoded multisig transaction\n  const encodedMsig = createMultisigTransaction(txn, {\n    version,\n    threshold,\n    addrs: pks.map(pk => address.encodeAddress(pk))\n  });\n  // note: this is not signed yet, but will be shortly\n  const signedTxn = encoding.decode(encodedMsig);\n  let keyExist = false;\n  // append the multisig signature to the corresponding public key in the multisig blob\n  signedTxn.msig.subsig.forEach((subsig, i) => {\n    if (nacl.bytesEqual(subsig.pk, myPk)) {\n      keyExist = true;\n      signedTxn.msig.subsig[i].s = rawSig;\n    }\n  });\n  if (keyExist === false) {\n    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);\n  }\n  // if the address of this multisig is different from the transaction sender,\n  // we need to add the auth-addr field\n  const msigAddr = address.fromMultisigPreImg({\n    version,\n    threshold,\n    pks\n  });\n  if (address.encodeAddress(signedTxn.txn.snd) !== address.encodeAddress(msigAddr)) {\n    signedTxn.sgnr = Buffer.from(msigAddr);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\n/**\n * MultisigTransaction is a Transaction that also supports creating partially-signed multisig transactions.\n */\nexport class MultisigTransaction extends txnBuilder.Transaction {\n  /* eslint-disable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addLease() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  /**\n   * Override inherited method to throw an error, as mutating transactions are prohibited in this context\n   */\n  addRekey() {\n    throw new Error(MULTISIG_NO_MUTATE_ERROR_MSG);\n  }\n  signTxn(sk) {\n    throw new Error(MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG);\n  }\n  /* eslint-enable class-methods-use-this,@typescript-eslint/no-unused-vars,no-dupe-class-members */\n  /**\n   * partialSignTxn partially signs this transaction and returns a partially-signed multisig transaction,\n   * encoded with msgpack as a typed array.\n   * @param version - multisig version\n   * @param threshold - multisig threshold\n   * @param pks - multisig public key list, order is important.\n   * @param sk - an Algorand secret key to sign with.\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignTxn(_ref4, sk) {\n    let {\n      version,\n      threshold,\n      pks\n    } = _ref4;\n    // get signature verifier\n    const myPk = nacl.keyPairFromSecretKey(sk).publicKey;\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: this.rawSignTxn(sk),\n      myPk\n    }, {\n      version,\n      threshold,\n      pks\n    });\n  }\n  /**\n   * partialSignWithMultisigSignature partially signs this transaction with an external raw multisig signature and returns\n   * a partially-signed multisig transaction, encoded with msgpack as a typed array.\n   * @param metadata - multisig metadata\n   * @param signerAddr - address of the signer\n   * @param signature - raw multisig signature\n   * @returns an encoded, partially signed multisig transaction.\n   */\n  partialSignWithMultisigSignature(metadata, signerAddr, signature) {\n    if (!nacl.isValidSignatureLength(signature.length)) {\n      throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);\n    }\n    return createMultisigTransactionWithSignature(this, {\n      rawSig: signature,\n      myPk: address.decodeAddress(signerAddr).publicKey\n    }, metadata);\n  }\n  // eslint-disable-next-line camelcase\n  static from_obj_for_encoding(txnForEnc) {\n    return super.from_obj_for_encoding(txnForEnc);\n  }\n}\n/**\n * mergeMultisigTransactions takes a list of multisig transaction blobs, and merges them.\n * @param multisigTxnBlobs - a list of blobs representing encoded multisig txns\n * @returns typed array msg-pack encoded multisig txn\n */\nexport function mergeMultisigTransactions(multisigTxnBlobs) {\n  if (multisigTxnBlobs.length < 2) {\n    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);\n  }\n  const refSigTx = encoding.decode(multisigTxnBlobs[0]);\n  const refTxID = MultisigTransaction.from_obj_for_encoding(refSigTx.txn).txID();\n  const refAuthAddr = refSigTx.sgnr ? address.encodeAddress(refSigTx.sgnr) : undefined;\n  const refPreImage = {\n    version: refSigTx.msig.v,\n    threshold: refSigTx.msig.thr,\n    pks: refSigTx.msig.subsig.map(subsig => subsig.pk)\n  };\n  const refMsigAddr = address.encodeAddress(address.fromMultisigPreImg(refPreImage));\n  const newSubsigs = refSigTx.msig.subsig.map(sig => ({\n    ...sig\n  }));\n  for (let i = 1; i < multisigTxnBlobs.length; i++) {\n    const unisig = encoding.decode(multisigTxnBlobs[i]);\n    const unisigAlgoTxn = MultisigTransaction.from_obj_for_encoding(unisig.txn);\n    if (unisigAlgoTxn.txID() !== refTxID) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);\n    }\n    const authAddr = unisig.sgnr ? address.encodeAddress(unisig.sgnr) : undefined;\n    if (refAuthAddr !== authAddr) {\n      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);\n    }\n    // check multisig has same preimage as reference\n    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    const preimg = {\n      version: unisig.msig.v,\n      threshold: unisig.msig.thr,\n      pks: unisig.msig.subsig.map(subsig => subsig.pk)\n    };\n    const msgigAddr = address.encodeAddress(address.fromMultisigPreImg(preimg));\n    if (refMsigAddr !== msgigAddr) {\n      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);\n    }\n    // now, we can merge\n    unisig.msig.subsig.forEach((uniSubsig, index) => {\n      if (!uniSubsig.s) return;\n      const current = newSubsigs[index];\n      // we convert the Uint8Arrays uniSubsig.s and current.s to Buffers here because (as\n      // of Dec 2020) React overrides the buffer package with an older version that does\n      // not support Uint8Arrays in the comparison function. See this thread for more\n      // info: https://github.com/algorand/js-algorand-sdk/issues/252\n      if (current.s && Buffer.compare(Buffer.from(uniSubsig.s), Buffer.from(current.s)) !== 0) {\n        // mismatch\n        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);\n      }\n      current.s = uniSubsig.s;\n    });\n  }\n  const msig = {\n    v: refSigTx.msig.v,\n    thr: refSigTx.msig.thr,\n    subsig: newSubsigs\n  };\n  const signedTxn = {\n    msig,\n    txn: refSigTx.txn\n  };\n  if (typeof refAuthAddr !== 'undefined') {\n    signedTxn.sgnr = Buffer.from(address.decodeAddress(refAuthAddr).publicKey);\n  }\n  return new Uint8Array(encoding.encode(signedTxn));\n}\nexport function verifyMultisig(toBeVerified, msig, publicKey) {\n  const version = msig.v;\n  const threshold = msig.thr;\n  const subsigs = msig.subsig;\n  const pks = subsigs.map(subsig => subsig.pk);\n  if (msig.subsig.length < threshold) {\n    return false;\n  }\n  let pk;\n  try {\n    pk = address.fromMultisigPreImg({\n      version,\n      threshold,\n      pks\n    });\n  } catch (e) {\n    return false;\n  }\n  if (!utils.arrayEqual(pk, publicKey)) {\n    return false;\n  }\n  let counter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      counter += 1;\n    }\n  }\n  if (counter < threshold) {\n    return false;\n  }\n  let verifiedCounter = 0;\n  for (const subsig of subsigs) {\n    if (subsig.s !== undefined) {\n      if (nacl.verify(toBeVerified, subsig.s, subsig.pk)) {\n        verifiedCounter += 1;\n      }\n    }\n  }\n  if (verifiedCounter < threshold) {\n    return false;\n  }\n  return true;\n}\n/**\n * signMultisigTransaction takes a raw transaction (see signTransaction), a multisig preimage, a secret key, and returns\n * a multisig transaction, which is a blob representing a transaction and multisignature account preimage. The returned\n * multisig txn can accumulate additional signatures through mergeMultisigTransactions or appendSignMultisigTransaction.\n * @param txn - object with either payment or key registration fields\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key. The corresponding pk should be in the pre image.\n * @returns object containing txID, and blob of partially signed multisig transaction (with multisig preimage information)\n * If the final calculated fee is lower than the protocol minimum fee, the fee will be increased to match the minimum.\n */\nexport function signMultisigTransaction(txn, _ref5, sk) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref5;\n  // check that the from field matches the mSigPreImage. If from field is not populated, fill it in.\n  const expectedFromRaw = address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n  if (!Object.prototype.hasOwnProperty.call(txn, 'from')) {\n    // eslint-disable-next-line no-param-reassign\n    txn.from = expectedFromRaw;\n  }\n  // build pks for partialSign\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // `txn` needs to be handled differently if it's a constructed `Transaction` vs a dict of constructor args\n  const txnAlreadyBuilt = txn instanceof txnBuilder.Transaction;\n  let algoTxn;\n  let blob;\n  if (txnAlreadyBuilt) {\n    algoTxn = txn;\n    blob = MultisigTransaction.prototype.partialSignTxn.call(algoTxn, {\n      version,\n      threshold,\n      pks\n    }, sk);\n  } else {\n    algoTxn = new MultisigTransaction(txn);\n    blob = algoTxn.partialSignTxn({\n      version,\n      threshold,\n      pks\n    }, sk);\n  }\n  return {\n    txID: algoTxn.txID().toString(),\n    blob\n  };\n}\n/**\n * appendSignMultisigTransaction takes a multisig transaction blob, and appends our signature to it.\n * While we could derive public key preimagery from the partially-signed multisig transaction,\n * we ask the caller to pass it back in, to ensure they know what they are signing.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param sk - Algorand secret key\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignMultisigTransaction(multisigTxnBlob, _ref6, sk) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref6;\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignTxn({\n    version,\n    threshold,\n    pks\n  }, sk);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * appendMultisigTransactionSignature takes a multisig transaction blob, and appends a given raw signature to it.\n * This makes it possible to compile a multisig signature using only raw signatures from external methods.\n * @param multisigTxnBlob - an encoded multisig txn. Supports non-payment txn types.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - a list of Algorand addresses representing possible signers for this multisig. Order is important.\n * @param signerAddr - address of the signer\n * @param signature - raw multisig signature\n * @returns object containing txID, and blob representing encoded multisig txn\n */\nexport function appendSignRawMultisigSignature(multisigTxnBlob, _ref7, signerAddr, signature) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref7;\n  const pks = addrs.map(addr => address.decodeAddress(addr).publicKey);\n  // obtain underlying txn, sign it, and merge it\n  const multisigTxObj = encoding.decode(multisigTxnBlob);\n  const msigTxn = MultisigTransaction.from_obj_for_encoding(multisigTxObj.txn);\n  const partialSignedBlob = msigTxn.partialSignWithMultisigSignature({\n    version,\n    threshold,\n    pks\n  }, signerAddr, signature);\n  return {\n    txID: msigTxn.txID().toString(),\n    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])\n  };\n}\n/**\n * multisigAddress takes multisig metadata (preimage) and returns the corresponding human readable Algorand address.\n * @param version - multisig version\n * @param threshold - multisig threshold\n * @param addrs - list of Algorand addresses\n */\nexport function multisigAddress(_ref8) {\n  let {\n    version,\n    threshold,\n    addrs\n  } = _ref8;\n  return address.fromMultisigPreImgAddrs({\n    version,\n    threshold,\n    addrs\n  });\n}","map":{"version":3,"mappings":"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","names":["nacl","address","encoding","txnBuilder","utils","MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG","MULTISIG_MERGE_MISMATCH_ERROR_MSG","MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG","MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG","MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG","MULTISIG_KEY_NOT_EXIST_ERROR_MSG","MULTISIG_NO_MUTATE_ERROR_MSG","MULTISIG_USE_PARTIAL_SIGN_ERROR_MSG","MULTISIG_SIGNATURE_LENGTH_ERROR_MSG","createMultisigTransaction","txn","version","threshold","addrs","pks","map","addr","decodeAddress","publicKey","subsigs","pk","Buffer","from","msig","v","thr","subsig","txnForEncoding","get_obj_for_encoding","signedTxn","msigAddr","fromMultisigPreImg","encodeAddress","snd","sgnr","Uint8Array","encode","createMultisigTransactionWithSignature","rawSig","myPk","encodedMsig","decode","keyExist","forEach","i","bytesEqual","s","Error","MultisigTransaction","Transaction","addLease","addRekey","signTxn","sk","partialSignTxn","keyPairFromSecretKey","rawSignTxn","partialSignWithMultisigSignature","metadata","signerAddr","signature","isValidSignatureLength","length","from_obj_for_encoding","txnForEnc","mergeMultisigTransactions","multisigTxnBlobs","refSigTx","refTxID","txID","refAuthAddr","undefined","refPreImage","refMsigAddr","newSubsigs","sig","unisig","unisigAlgoTxn","authAddr","preimg","msgigAddr","uniSubsig","index","current","compare","verifyMultisig","toBeVerified","e","arrayEqual","counter","verifiedCounter","verify","signMultisigTransaction","expectedFromRaw","fromMultisigPreImgAddrs","Object","prototype","hasOwnProperty","call","txnAlreadyBuilt","algoTxn","blob","toString","appendSignMultisigTransaction","multisigTxnBlob","multisigTxObj","msigTxn","partialSignedBlob","appendSignRawMultisigSignature","multisigAddress"],"sourceRoot":"","sources":["../../src/multisig.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}